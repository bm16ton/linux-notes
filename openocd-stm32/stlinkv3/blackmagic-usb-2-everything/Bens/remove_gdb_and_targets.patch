From 03fb8769cecf2187d8cd31f9d47c83f157d9052a Mon Sep 17 00:00:00 2001
From: "Satoshi N. M" <snmatsutake@yahoo.co.jp>
Date: Sat, 23 Dec 2017 17:21:33 -0800
Subject: [PATCH] Remove targets and gdb

---
 src/Makefile                 |  31 --
 src/crc32.c                  | 150 ------
 src/gdb_hostio.c             | 133 -----
 src/gdb_hostio.h             |  53 --
 src/gdb_main.c               | 484 -----------------
 src/gdb_packet.c             | 173 ------
 src/main.c                   |  14 +-
 src/morse.c                  | 100 ----
 src/target/adiv5.c           | 585 ---------------------
 src/target/adiv5.h           | 172 ------
 src/target/adiv5_jtagdp.c    | 112 ----
 src/target/adiv5_swdp.c      | 173 ------
 src/target/cortexa.c         | 730 --------------------------
 src/target/cortexm.c         | 985 -----------------------------------
 src/target/cortexm.h         | 180 -------
 src/target/efm32.c           | 441 ----------------
 src/target/jtag_scan.c       | 252 ---------
 src/target/jtag_scan.h       |  52 --
 src/target/jtagtap_generic.c |  65 ---
 src/target/kinetis.c         | 364 -------------
 src/target/lmi.c             | 140 -----
 src/target/lpc11xx.c         | 125 -----
 src/target/lpc15xx.c         |  80 ---
 src/target/lpc43xx.c         | 267 ----------
 src/target/lpc_common.c      | 151 ------
 src/target/lpc_common.h      |  70 ---
 src/target/nrf51.c           | 335 ------------
 src/target/sam3x.c           | 358 -------------
 src/target/sam4l.c           | 398 --------------
 src/target/samd.c            | 701 -------------------------
 src/target/stm32f1.c         | 362 -------------
 src/target/stm32f4.c         | 648 -----------------------
 src/target/stm32l0.c         | 769 ---------------------------
 src/target/stm32l4.c         | 377 --------------
 src/target/swdptap_generic.c |  79 ---
 35 files changed, 1 insertion(+), 10108 deletions(-)
 delete mode 100644 src/crc32.c
 delete mode 100644 src/gdb_hostio.c
 delete mode 100644 src/gdb_hostio.h
 delete mode 100644 src/gdb_main.c
 delete mode 100644 src/gdb_packet.c
 delete mode 100644 src/morse.c
 delete mode 100644 src/target/adiv5.c
 delete mode 100644 src/target/adiv5.h
 delete mode 100644 src/target/adiv5_jtagdp.c
 delete mode 100644 src/target/adiv5_swdp.c
 delete mode 100644 src/target/cortexa.c
 delete mode 100644 src/target/cortexm.c
 delete mode 100644 src/target/cortexm.h
 delete mode 100644 src/target/efm32.c
 delete mode 100644 src/target/jtag_scan.c
 delete mode 100644 src/target/jtag_scan.h
 delete mode 100644 src/target/jtagtap_generic.c
 delete mode 100644 src/target/kinetis.c
 delete mode 100644 src/target/lmi.c
 delete mode 100644 src/target/lpc11xx.c
 delete mode 100644 src/target/lpc15xx.c
 delete mode 100644 src/target/lpc43xx.c
 delete mode 100644 src/target/lpc_common.c
 delete mode 100644 src/target/lpc_common.h
 delete mode 100644 src/target/nrf51.c
 delete mode 100644 src/target/sam3x.c
 delete mode 100644 src/target/sam4l.c
 delete mode 100644 src/target/samd.c
 delete mode 100644 src/target/stm32f1.c
 delete mode 100644 src/target/stm32f4.c
 delete mode 100644 src/target/stm32l0.c
 delete mode 100644 src/target/stm32l4.c
 delete mode 100644 src/target/swdptap_generic.c

diff --git a/src/Makefile b/src/Makefile
index edc7f8a..41243fc 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -20,42 +20,11 @@ CFLAGS += -DENABLE_DEBUG
 endif
 
 SRC =			\
-	adiv5.c		\
-	adiv5_jtagdp.c	\
-	adiv5_swdp.c	\
 	command.c	\
-	cortexa.c	\
-	cortexm.c	\
-	crc32.c		\
-	efm32.c		\
 	exception.c	\
-	gdb_if.c	\
-	gdb_main.c	\
-	gdb_hostio.c	\
-	gdb_packet.c	\
 	hex_utils.c	\
-	jtag_scan.c	\
-	jtagtap.c	\
-	jtagtap_generic.c	\
-	lmi.c		\
-	lpc_common.c	\
-	lpc11xx.c	\
-	lpc15xx.c	\
-	lpc43xx.c	\
-	kinetis.c	\
 	main.c		\
-	morse.c		\
-	nrf51.c		\
 	platform.c	\
-	sam3x.c		\
-	sam4l.c	\
-	samd.c		\
-	stm32f1.c	\
-	stm32f4.c	\
-	stm32l0.c	\
-	stm32l4.c	\
-	swdptap.c	\
-	swdptap_generic.c	\
 	target.c	\
 
 include $(PLATFORM_DIR)/Makefile.inc
diff --git a/src/crc32.c b/src/crc32.c
deleted file mode 100644
index 881f12d..0000000
--- a/src/crc32.c
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2011  Black Sphere Technologies Ltd.
- * Written by Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "general.h"
-#include "target.h"
-
-#if !defined(STM32F1) && !defined(STM32F4)
-static const uint32_t crc32_table[] = {
-	0x00000000, 0x04C11DB7, 0x09823B6E, 0x0D4326D9,
-	0x130476DC, 0x17C56B6B, 0x1A864DB2, 0x1E475005,
-	0x2608EDB8, 0x22C9F00F, 0x2F8AD6D6, 0x2B4BCB61,
-	0x350C9B64, 0x31CD86D3, 0x3C8EA00A, 0x384FBDBD,
-	0x4C11DB70, 0x48D0C6C7, 0x4593E01E, 0x4152FDA9,
-	0x5F15ADAC, 0x5BD4B01B, 0x569796C2, 0x52568B75,
-	0x6A1936C8, 0x6ED82B7F, 0x639B0DA6, 0x675A1011,
-	0x791D4014, 0x7DDC5DA3, 0x709F7B7A, 0x745E66CD,
-	0x9823B6E0, 0x9CE2AB57, 0x91A18D8E, 0x95609039,
-	0x8B27C03C, 0x8FE6DD8B, 0x82A5FB52, 0x8664E6E5,
-	0xBE2B5B58, 0xBAEA46EF, 0xB7A96036, 0xB3687D81,
-	0xAD2F2D84, 0xA9EE3033, 0xA4AD16EA, 0xA06C0B5D,
-	0xD4326D90, 0xD0F37027, 0xDDB056FE, 0xD9714B49,
-	0xC7361B4C, 0xC3F706FB, 0xCEB42022, 0xCA753D95,
-	0xF23A8028, 0xF6FB9D9F, 0xFBB8BB46, 0xFF79A6F1,
-	0xE13EF6F4, 0xE5FFEB43, 0xE8BCCD9A, 0xEC7DD02D,
-	0x34867077, 0x30476DC0, 0x3D044B19, 0x39C556AE,
-	0x278206AB, 0x23431B1C, 0x2E003DC5, 0x2AC12072,
-	0x128E9DCF, 0x164F8078, 0x1B0CA6A1, 0x1FCDBB16,
-	0x018AEB13, 0x054BF6A4, 0x0808D07D, 0x0CC9CDCA,
-	0x7897AB07, 0x7C56B6B0, 0x71159069, 0x75D48DDE,
-	0x6B93DDDB, 0x6F52C06C, 0x6211E6B5, 0x66D0FB02,
-	0x5E9F46BF, 0x5A5E5B08, 0x571D7DD1, 0x53DC6066,
-	0x4D9B3063, 0x495A2DD4, 0x44190B0D, 0x40D816BA,
-	0xACA5C697, 0xA864DB20, 0xA527FDF9, 0xA1E6E04E,
-	0xBFA1B04B, 0xBB60ADFC, 0xB6238B25, 0xB2E29692,
-	0x8AAD2B2F, 0x8E6C3698, 0x832F1041, 0x87EE0DF6,
-	0x99A95DF3, 0x9D684044, 0x902B669D, 0x94EA7B2A,
-	0xE0B41DE7, 0xE4750050, 0xE9362689, 0xEDF73B3E,
-	0xF3B06B3B, 0xF771768C, 0xFA325055, 0xFEF34DE2,
-	0xC6BCF05F, 0xC27DEDE8, 0xCF3ECB31, 0xCBFFD686,
-	0xD5B88683, 0xD1799B34, 0xDC3ABDED, 0xD8FBA05A,
-	0x690CE0EE, 0x6DCDFD59, 0x608EDB80, 0x644FC637,
-	0x7A089632, 0x7EC98B85, 0x738AAD5C, 0x774BB0EB,
-	0x4F040D56, 0x4BC510E1, 0x46863638, 0x42472B8F,
-	0x5C007B8A, 0x58C1663D, 0x558240E4, 0x51435D53,
-	0x251D3B9E, 0x21DC2629, 0x2C9F00F0, 0x285E1D47,
-	0x36194D42, 0x32D850F5, 0x3F9B762C, 0x3B5A6B9B,
-	0x0315D626, 0x07D4CB91, 0x0A97ED48, 0x0E56F0FF,
-	0x1011A0FA, 0x14D0BD4D, 0x19939B94, 0x1D528623,
-	0xF12F560E, 0xF5EE4BB9, 0xF8AD6D60, 0xFC6C70D7,
-	0xE22B20D2, 0xE6EA3D65, 0xEBA91BBC, 0xEF68060B,
-	0xD727BBB6, 0xD3E6A601, 0xDEA580D8, 0xDA649D6F,
-	0xC423CD6A, 0xC0E2D0DD, 0xCDA1F604, 0xC960EBB3,
-	0xBD3E8D7E, 0xB9FF90C9, 0xB4BCB610, 0xB07DABA7,
-	0xAE3AFBA2, 0xAAFBE615, 0xA7B8C0CC, 0xA379DD7B,
-	0x9B3660C6, 0x9FF77D71, 0x92B45BA8, 0x9675461F,
-	0x8832161A, 0x8CF30BAD, 0x81B02D74, 0x857130C3,
-	0x5D8A9099, 0x594B8D2E, 0x5408ABF7, 0x50C9B640,
-	0x4E8EE645, 0x4A4FFBF2, 0x470CDD2B, 0x43CDC09C,
-	0x7B827D21, 0x7F436096, 0x7200464F, 0x76C15BF8,
-	0x68860BFD, 0x6C47164A, 0x61043093, 0x65C52D24,
-	0x119B4BE9, 0x155A565E, 0x18197087, 0x1CD86D30,
-	0x029F3D35, 0x065E2082, 0x0B1D065B, 0x0FDC1BEC,
-	0x3793A651, 0x3352BBE6, 0x3E119D3F, 0x3AD08088,
-	0x2497D08D, 0x2056CD3A, 0x2D15EBE3, 0x29D4F654,
-	0xC5A92679, 0xC1683BCE, 0xCC2B1D17, 0xC8EA00A0,
-	0xD6AD50A5, 0xD26C4D12, 0xDF2F6BCB, 0xDBEE767C,
-	0xE3A1CBC1, 0xE760D676, 0xEA23F0AF, 0xEEE2ED18,
-	0xF0A5BD1D, 0xF464A0AA, 0xF9278673, 0xFDE69BC4,
-	0x89B8FD09, 0x8D79E0BE, 0x803AC667, 0x84FBDBD0,
-	0x9ABC8BD5, 0x9E7D9662, 0x933EB0BB, 0x97FFAD0C,
-	0xAFB010B1, 0xAB710D06, 0xA6322BDF, 0xA2F33668,
-	0xBCB4666D, 0xB8757BDA, 0xB5365D03, 0xB1F740B4,
-};
-
-static uint32_t crc32_calc(uint32_t crc, uint8_t data)
-{
-	return (crc << 8) ^ crc32_table[((crc >> 24) ^ data) & 255];
-}
-
-uint32_t generic_crc32(target *t, uint32_t base, size_t len)
-{
-	uint32_t crc = -1;
-	uint8_t bytes[128];
-
-	while (len) {
-		size_t read_len = MIN(sizeof(bytes), len);
-		target_mem_read(t, bytes, base, read_len);
-
-		for (unsigned i = 0; i < read_len; i++)
-			crc = crc32_calc(crc, bytes[i]);
-
-		base += read_len;
-		len -= read_len;
-	}
-	return crc;
-}
-#else
-#include <libopencm3/stm32/crc.h>
-uint32_t generic_crc32(target *t, uint32_t base, size_t len)
-{
-	uint8_t bytes[128];
-	uint32_t crc;
-
-	CRC_CR |= CRC_CR_RESET;
-
-	while (len > 3) {
-		size_t read_len = MIN(sizeof(bytes), len) & ~3;
-		target_mem_read(t, bytes, base, read_len);
-
-		for (unsigned i = 0; i < read_len; i += 4)
-			CRC_DR = __builtin_bswap32(*(uint32_t*)(bytes+i));
-
-		base += read_len;
-		len -= read_len;
-	}
-
-	crc = CRC_DR;
-
-	target_mem_read(t, bytes, base, len);
-	uint8_t *data = bytes;
-	while (len--) {
-		crc ^= *data++ << 24;
-		for (int i = 0; i < 8; i++) {
-			if (crc & 0x80000000)
-				crc = (crc << 1) ^ 0x4C11DB7;
-			else
-				crc <<= 1;
-		}
-	}
-	return crc;
-}
-#endif
-
diff --git a/src/gdb_hostio.c b/src/gdb_hostio.c
deleted file mode 100644
index 82ff0a6..0000000
--- a/src/gdb_hostio.c
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2016  Black Sphere Technologies Ltd.
- * Written by Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "general.h"
-#include "target.h"
-#include "gdb_main.h"
-#include "gdb_hostio.h"
-#include "gdb_packet.h"
-
-int gdb_main_loop(struct target_controller *, bool in_syscall);
-
-int hostio_reply(struct target_controller *tc, char *pbuf, int len)
-{
-	(void)len;
-	int retcode, items, errno_;
-	char c, *p;
-	if (pbuf[1] == '-')
-		p = &pbuf[2];
-	else
-		p = &pbuf[1];
-	items = sscanf(p, "%x,%x,%c", &retcode, &errno_, &c);
-	if (pbuf[1] == '-')
-		retcode = -retcode;
-
-	/* if break is requested */
-	tc->interrupted = items == 3 && c == 'C';
-	tc->errno_ = errno_;
-
-	return retcode;
-}
-
-/* Interface to host system calls */
-int hostio_open(struct target_controller *tc,
-	        target_addr path, size_t path_len,
-                enum target_open_flags flags, mode_t mode)
-{
-	gdb_putpacket_f("Fopen,%08X/%X,%08X,%08X", path, path_len, flags, mode);;;;
-	return gdb_main_loop(tc, true);
-}
-
-int hostio_close(struct target_controller *tc, int fd)
-{
-	gdb_putpacket_f("Fclose,%08X", fd);
-	return gdb_main_loop(tc, true);
-}
-
-int hostio_read(struct target_controller *tc,
-	         int fd, target_addr buf, unsigned int count)
-{
-	gdb_putpacket_f("Fread,%08X,%08X,%08X", fd, buf, count);
-	return gdb_main_loop(tc, true);
-}
-
-int hostio_write(struct target_controller *tc,
-	          int fd, target_addr buf, unsigned int count)
-{
-	gdb_putpacket_f("Fwrite,%08X,%08X,%08X", fd, buf, count);
-	return gdb_main_loop(tc, true);
-}
-
-long hostio_lseek(struct target_controller *tc,
-	           int fd, long offset, enum target_seek_flag flag)
-{
-	gdb_putpacket_f("Flseek,%08X,%08X,%08X", fd, offset, flag);
-	return gdb_main_loop(tc, true);
-}
-
-int hostio_rename(struct target_controller *tc,
-	           target_addr oldpath, size_t old_len,
-	           target_addr newpath, size_t new_len)
-{
-	gdb_putpacket_f("Frename,%08X/%X,%08X/%X",
-	                oldpath, old_len, newpath, new_len);
-	return gdb_main_loop(tc, true);
-}
-
-int hostio_unlink(struct target_controller *tc,
-	           target_addr path, size_t path_len)
-{
-	gdb_putpacket_f("Funlink,%08X/%X", path, path_len);
-	return gdb_main_loop(tc, true);
-}
-
-int hostio_stat(struct target_controller *tc,
-	         target_addr path, size_t path_len, target_addr buf)
-{
-	gdb_putpacket_f("Fstat,%08X/%X,%08X", path, path_len, buf);
-	return gdb_main_loop(tc, true);
-}
-
-int hostio_fstat(struct target_controller *tc, int fd, target_addr buf)
-{
-	gdb_putpacket_f("Ffstat,%X,%08X", fd, buf);
-	return gdb_main_loop(tc, true);
-}
-
-int hostio_gettimeofday(struct target_controller *tc,
-		         target_addr tv, target_addr tz)
-{
-	gdb_putpacket_f("Fgettimeofday,%08X,%08X", tv, tz);
-	return gdb_main_loop(tc, true);
-}
-
-int hostio_isatty(struct target_controller *tc, int fd)
-{
-	gdb_putpacket_f("Fisatty,%08X", fd);
-	return gdb_main_loop(tc, true);
-}
-
-int hostio_system(struct target_controller *tc,
-	          target_addr cmd, size_t cmd_len)
-{
-	gdb_putpacket_f("Fsystem,%08X/%X", cmd, cmd_len);
-	return gdb_main_loop(tc, true);
-}
-
diff --git a/src/gdb_hostio.h b/src/gdb_hostio.h
deleted file mode 100644
index f95f707..0000000
--- a/src/gdb_hostio.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2016  Black Sphere Technologies Ltd.
- * Written by Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-#ifndef __GDB_SYSCALLS_H
-#define __GDB_SYSCALLS_H
-
-#include "target.h"
-
-int hostio_reply(struct target_controller *tc, char *packet, int len);
-
-/* Interface to host system calls */
-int hostio_open(struct target_controller *,
-	        target_addr path, size_t path_len,
-                enum target_open_flags flags, mode_t mode);
-int hostio_close(struct target_controller *, int fd);
-int hostio_read(struct target_controller *,
-	         int fd, target_addr buf, unsigned int count);
-int hostio_write(struct target_controller *,
-	          int fd, target_addr buf, unsigned int count);
-long hostio_lseek(struct target_controller *,
-	           int fd, long offset, enum target_seek_flag flag);
-int hostio_rename(struct target_controller *,
-	           target_addr oldpath, size_t old_len,
-	           target_addr newpath, size_t new_len);
-int hostio_unlink(struct target_controller *,
-	           target_addr path, size_t path_len);
-int hostio_stat(struct target_controller *,
-	         target_addr path, size_t path_len, target_addr buf);
-int hostio_fstat(struct target_controller *, int fd, target_addr buf);
-int hostio_gettimeofday(struct target_controller *,
-		         target_addr tv, target_addr tz);
-int hostio_isatty(struct target_controller *, int fd);
-int hostio_system(struct target_controller *,
-	           target_addr cmd, size_t cmd_len);
-
-#endif
-
diff --git a/src/gdb_main.c b/src/gdb_main.c
deleted file mode 100644
index ed1f2fe..0000000
--- a/src/gdb_main.c
+++ /dev/null
@@ -1,484 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2011  Black Sphere Technologies Ltd.
- * Written by Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/* This file implements the GDB Remote Serial Debugging protocol as
- * described in "Debugging with GDB" build from GDB source.
- *
- * Originally written for GDB 6.8, updated and tested with GDB 7.2.
- */
-
-#include "general.h"
-#include "hex_utils.h"
-#include "gdb_if.h"
-#include "gdb_packet.h"
-#include "gdb_main.h"
-#include "gdb_hostio.h"
-#include "target.h"
-#include "command.h"
-#include "crc32.h"
-#include "morse.h"
-
-enum gdb_signal {
-	GDB_SIGINT = 2,
-	GDB_SIGTRAP = 5,
-	GDB_SIGSEGV = 11,
-	GDB_SIGLOST = 29,
-};
-
-#define BUF_SIZE	1024
-
-#define ERROR_IF_NO_TARGET()	\
-	if(!cur_target) { gdb_putpacketz("EFF"); break; }
-
-static char pbuf[BUF_SIZE+1];
-
-static target *cur_target;
-static target *last_target;
-
-static void handle_q_packet(char *packet, int len);
-static void handle_v_packet(char *packet, int len);
-static void handle_z_packet(char *packet, int len);
-
-static void gdb_target_destroy_callback(struct target_controller *tc, target *t)
-{
-	(void)tc;
-	if (cur_target == t)
-		cur_target = NULL;
-
-	if (last_target == t)
-		last_target = NULL;
-}
-
-static void gdb_target_printf(struct target_controller *tc,
-                              const char *fmt, va_list ap)
-{
-	(void)tc;
-	gdb_voutf(fmt, ap);
-}
-
-static struct target_controller gdb_controller = {
-	.destroy_callback = gdb_target_destroy_callback,
-	.printf = gdb_target_printf,
-
-	.open = hostio_open,
-	.close = hostio_close,
-	.read = hostio_read,
-	.write = hostio_write,
-	.lseek = hostio_lseek,
-	.rename = hostio_rename,
-	.unlink = hostio_unlink,
-	.stat = hostio_stat,
-	.fstat = hostio_fstat,
-	.gettimeofday = hostio_gettimeofday,
-	.isatty = hostio_isatty,
-	.system = hostio_system,
-};
-
-int gdb_main_loop(struct target_controller *tc, bool in_syscall)
-{
-	int size;
-	bool single_step = false;
-
-	/* GDB protocol main loop */
-	while(1) {
-		SET_IDLE_STATE(1);
-		size = gdb_getpacket(pbuf, BUF_SIZE);
-		SET_IDLE_STATE(0);
-		switch(pbuf[0]) {
-		/* Implementation of these is mandatory! */
-		case 'g': { /* 'g': Read general registers */
-			ERROR_IF_NO_TARGET();
-			uint8_t arm_regs[target_regs_size(cur_target)];
-			target_regs_read(cur_target, arm_regs);
-			gdb_putpacket(hexify(pbuf, arm_regs, sizeof(arm_regs)),
-			              sizeof(arm_regs) * 2);
-			break;
-			}
-		case 'm': {	/* 'm addr,len': Read len bytes from addr */
-			uint32_t addr, len;
-			ERROR_IF_NO_TARGET();
-			sscanf(pbuf, "m%" SCNx32 ",%" SCNx32, &addr, &len);
-			if (len > sizeof(pbuf) / 2) {
-				gdb_putpacketz("E02");
-				break;
-			}
-			DEBUG("m packet: addr = %" PRIx32 ", len = %" PRIx32 "\n", addr, len);
-			uint8_t mem[len];
-			if (target_mem_read(cur_target, mem, addr, len))
-				gdb_putpacketz("E01");
-			else
-				gdb_putpacket(hexify(pbuf, mem, len), len*2);
-			break;
-			}
-		case 'G': {	/* 'G XX': Write general registers */
-			ERROR_IF_NO_TARGET();
-			uint8_t arm_regs[target_regs_size(cur_target)];
-			unhexify(arm_regs, &pbuf[1], sizeof(arm_regs));
-			target_regs_write(cur_target, arm_regs);
-			gdb_putpacketz("OK");
-			break;
-			}
-		case 'M': { /* 'M addr,len:XX': Write len bytes to addr */
-			uint32_t addr, len;
-			int hex;
-			ERROR_IF_NO_TARGET();
-			sscanf(pbuf, "M%" SCNx32 ",%" SCNx32 ":%n", &addr, &len, &hex);
-			if (len > (unsigned)(size - hex) / 2) {
-				gdb_putpacketz("E02");
-				break;
-			}
-			DEBUG("M packet: addr = %" PRIx32 ", len = %" PRIx32 "\n", addr, len);
-			uint8_t mem[len];
-			unhexify(mem, pbuf + hex, len);
-			if (target_mem_write(cur_target, addr, mem, len))
-				gdb_putpacketz("E01");
-			else
-				gdb_putpacketz("OK");
-			break;
-			}
-		case 's':	/* 's [addr]': Single step [start at addr] */
-			single_step = true;
-			/* fall through */
-		case 'c':	/* 'c [addr]': Continue [at addr] */
-			if(!cur_target) {
-				gdb_putpacketz("X1D");
-				break;
-			}
-
-			target_halt_resume(cur_target, single_step);
-			SET_RUN_STATE(1);
-			single_step = false;
-			/* fall through */
-		case '?': {	/* '?': Request reason for target halt */
-			/* This packet isn't documented as being mandatory,
-			 * but GDB doesn't work without it. */
-			target_addr watch;
-			enum target_halt_reason reason;
-
-			if(!cur_target) {
-				/* Report "target exited" if no target */
-				gdb_putpacketz("W00");
-				break;
-			}
-
-			/* Wait for target halt */
-			while(!(reason = target_halt_poll(cur_target, &watch))) {
-				unsigned char c = gdb_if_getchar_to(0);
-				if((c == '\x03') || (c == '\x04')) {
-					target_halt_request(cur_target);
-				}
-			}
-			SET_RUN_STATE(0);
-
-			/* Translate reason to GDB signal */
-			switch (reason) {
-			case TARGET_HALT_ERROR:
-				gdb_putpacket_f("X%02X", GDB_SIGLOST);
-				morse("TARGET LOST.", true);
-				break;
-			case TARGET_HALT_REQUEST:
-				gdb_putpacket_f("T%02X", GDB_SIGINT);
-				break;
-			case TARGET_HALT_WATCHPOINT:
-				gdb_putpacket_f("T%02Xwatch:%08X;", GDB_SIGTRAP, watch);
-				break;
-			case TARGET_HALT_FAULT:
-				gdb_putpacket_f("T%02X", GDB_SIGSEGV);
-				break;
-			default:
-				gdb_putpacket_f("T%02X", GDB_SIGTRAP);
-			}
-			break;
-			}
-		case 'F':	/* Semihosting call finished */
-			if (in_syscall) {
-				return hostio_reply(tc, pbuf, size);
-			} else {
-				DEBUG("*** F packet when not in syscall! '%s'\n", pbuf);
-				gdb_putpacketz("");
-			}
-			break;
-
-		/* Optional GDB packet support */
-		case '!':	/* Enable Extended GDB Protocol. */
-			/* This doesn't do anything, we support the extended
-			 * protocol anyway, but GDB will never send us a 'R'
-			 * packet unless we answer 'OK' here.
-			 */
-			gdb_putpacketz("OK");
-			break;
-
-		case 0x04:
-		case 'D':	/* GDB 'detach' command. */
-			if(cur_target)
-				target_detach(cur_target);
-			last_target = cur_target;
-			cur_target = NULL;
-			gdb_putpacketz("OK");
-			break;
-
-		case 'k':	/* Kill the target */
-			if(cur_target) {
-				target_reset(cur_target);
-				target_detach(cur_target);
-				last_target = cur_target;
-				cur_target = NULL;
-			}
-			break;
-
-		case 'r':	/* Reset the target system */
-		case 'R':	/* Restart the target program */
-			if(cur_target)
-				target_reset(cur_target);
-			else if(last_target) {
-				cur_target = target_attach(last_target,
-						           &gdb_controller);
-				target_reset(cur_target);
-			}
-			break;
-
-		case 'X': { /* 'X addr,len:XX': Write binary data to addr */
-			uint32_t addr, len;
-			int bin;
-			ERROR_IF_NO_TARGET();
-			sscanf(pbuf, "X%" SCNx32 ",%" SCNx32 ":%n", &addr, &len, &bin);
-			if (len > (unsigned)(size - bin)) {
-				gdb_putpacketz("E02");
-				break;
-			}
-			DEBUG("X packet: addr = %" PRIx32 ", len = %" PRIx32 "\n", addr, len);
-			if (target_mem_write(cur_target, addr, pbuf+bin, len))
-				gdb_putpacketz("E01");
-			else
-				gdb_putpacketz("OK");
-			break;
-			}
-
-		case 'q':	/* General query packet */
-			handle_q_packet(pbuf, size);
-			break;
-
-		case 'v':	/* General query packet */
-			handle_v_packet(pbuf, size);
-			break;
-
-		/* These packet implement hardware break-/watchpoints */
-		case 'Z':	/* Z type,addr,len: Set breakpoint packet */
-		case 'z':	/* z type,addr,len: Clear breakpoint packet */
-			ERROR_IF_NO_TARGET();
-			handle_z_packet(pbuf, size);
-			break;
-
-		default: 	/* Packet not implemented */
-			DEBUG("*** Unsupported packet: %s\n", pbuf);
-			gdb_putpacketz("");
-		}
-	}
-}
-
-static void
-handle_q_string_reply(const char *str, const char *param)
-{
-	unsigned long addr, len;
-
-	if (sscanf(param, "%08lx,%08lx", &addr, &len) != 2) {
-		gdb_putpacketz("E01");
-		return;
-	}
-	if (addr < strlen (str)) {
-		char reply[len+2];
-		reply[0] = 'm';
-		strncpy (reply + 1, &str[addr], len);
-		if(len > strlen(&str[addr]))
-			len = strlen(&str[addr]);
-		gdb_putpacket(reply, len + 1);
-	} else if (addr == strlen (str)) {
-		gdb_putpacketz("l");
-	} else
-		gdb_putpacketz("E01");
-}
-
-static void
-handle_q_packet(char *packet, int len)
-{
-	uint32_t addr, alen;
-
-	if(!strncmp(packet, "qRcmd,", 6)) {
-		char *data;
-		int datalen;
-
-		/* calculate size and allocate buffer for command */
-		datalen = (len - 6) / 2;
-		data = alloca(datalen+1);
-		/* dehexify command */
-		unhexify(data, packet+6, datalen);
-		data[datalen] = 0;	/* add terminating null */
-
-		int c = command_process(cur_target, data);
-		if(c < 0)
-			gdb_putpacketz("");
-		else if(c == 0)
-			gdb_putpacketz("OK");
-		else
-			gdb_putpacketz("E");
-
-	} else if (!strncmp (packet, "qSupported", 10)) {
-		/* Query supported protocol features */
-		gdb_putpacket_f("PacketSize=%X;qXfer:memory-map:read+;qXfer:features:read+", BUF_SIZE);
-
-	} else if (strncmp (packet, "qXfer:memory-map:read::", 23) == 0) {
-		/* Read target XML memory map */
-		if((!cur_target) && last_target) {
-			/* Attach to last target if detached. */
-			cur_target = target_attach(last_target,
-						   &gdb_controller);
-		}
-		if (!cur_target) {
-			gdb_putpacketz("E01");
-			return;
-		}
-		handle_q_string_reply(target_mem_map(cur_target), packet + 23);
-
-	} else if (strncmp (packet, "qXfer:features:read:target.xml:", 31) == 0) {
-		/* Read target description */
-		if((!cur_target) && last_target) {
-			/* Attach to last target if detached. */
-			cur_target = target_attach(last_target,
-						   &gdb_controller);
-		}
-		if (!cur_target) {
-			gdb_putpacketz("E01");
-			return;
-		}
-		handle_q_string_reply(target_tdesc(cur_target), packet + 31);
-	} else if (sscanf(packet, "qCRC:%" PRIx32 ",%" PRIx32, &addr, &alen) == 2) {
-		if(!cur_target) {
-			gdb_putpacketz("E01");
-			return;
-		}
-		gdb_putpacket_f("C%lx", generic_crc32(cur_target, addr, alen));
-
-	} else {
-		DEBUG("*** Unsupported packet: %s\n", packet);
-		gdb_putpacket("", 0);
-	}
-}
-
-static void
-handle_v_packet(char *packet, int plen)
-{
-	unsigned long addr, len;
-	int bin;
-	static uint8_t flash_mode = 0;
-
-	if (sscanf(packet, "vAttach;%08lx", &addr) == 1) {
-		/* Attach to remote target processor */
-		cur_target = target_attach_n(addr, &gdb_controller);
-		if(cur_target)
-			gdb_putpacketz("T05");
-		else
-			gdb_putpacketz("E01");
-
-	} else if (!strcmp(packet, "vRun;")) {
-		/* Run target program. For us (embedded) this means reset. */
-		if(cur_target) {
-			target_reset(cur_target);
-			gdb_putpacketz("T05");
-		} else if(last_target) {
-			cur_target = target_attach(last_target,
-						   &gdb_controller);
-
-                        /* If we were able to attach to the target again */
-                        if (cur_target) {
-                        	target_reset(cur_target);
-                        	gdb_putpacketz("T05");
-                        } else	gdb_putpacketz("E01");
-
-		} else	gdb_putpacketz("E01");
-
-	} else if (sscanf(packet, "vFlashErase:%08lx,%08lx", &addr, &len) == 2) {
-		/* Erase Flash Memory */
-		DEBUG("Flash Erase %08lX %08lX\n", addr, len);
-		if(!cur_target) { gdb_putpacketz("EFF"); return; }
-
-		if(!flash_mode) {
-			/* Reset target if first flash command! */
-			/* This saves us if we're interrupted in IRQ context */
-			target_reset(cur_target);
-			flash_mode = 1;
-		}
-		if(target_flash_erase(cur_target, addr, len) == 0)
-			gdb_putpacketz("OK");
-		else
-			gdb_putpacketz("EFF");
-
-	} else if (sscanf(packet, "vFlashWrite:%08lx:%n", &addr, &bin) == 1) {
-		/* Write Flash Memory */
-		len = plen - bin;
-		DEBUG("Flash Write %08lX %08lX\n", addr, len);
-		if(cur_target && target_flash_write(cur_target, addr, (void*)packet + bin, len) == 0)
-			gdb_putpacketz("OK");
-		else
-			gdb_putpacketz("EFF");
-
-	} else if (!strcmp(packet, "vFlashDone")) {
-		/* Commit flash operations. */
-		gdb_putpacketz(target_flash_done(cur_target) ? "EFF" : "OK");
-		flash_mode = 0;
-
-	} else {
-		DEBUG("*** Unsupported packet: %s\n", packet);
-		gdb_putpacket("", 0);
-	}
-}
-
-static void
-handle_z_packet(char *packet, int plen)
-{
-	(void)plen;
-
-	uint8_t set = (packet[0] == 'Z') ? 1 : 0;
-	int type, len;
-	uint32_t addr;
-	int ret;
-
-	/* I have no idea why this doesn't work. Seems to work
-	 * with real sscanf() though... */
-	//sscanf(packet, "%*[zZ]%hhd,%08lX,%hhd", &type, &addr, &len);
-	type = packet[1] - '0';
-	sscanf(packet + 2, ",%" PRIx32 ",%d", &addr, &len);
-	if(set)
-		ret = target_breakwatch_set(cur_target, type, addr, len);
-	else
-		ret = target_breakwatch_clear(cur_target, type, addr, len);
-
-	if (ret < 0) {
-		gdb_putpacketz("E01");
-	} else if (ret > 0) {
-		gdb_putpacketz("");
-	} else {
-		gdb_putpacketz("OK");
-	}
-}
-
-void gdb_main(void)
-{
-	gdb_main_loop(&gdb_controller, false);
-}
diff --git a/src/gdb_packet.c b/src/gdb_packet.c
deleted file mode 100644
index f738996..0000000
--- a/src/gdb_packet.c
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2011  Black Sphere Technologies Ltd.
- * Written by Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/* This file implements the GDB Remote Serial Debugging protocol packet
- * reception and transmission as well as some convenience functions.
- */
-
-#include "general.h"
-#include "gdb_if.h"
-#include "gdb_packet.h"
-#include "hex_utils.h"
-
-#include <stdarg.h>
-
-int gdb_getpacket(char *packet, int size)
-{
-	unsigned char c;
-	unsigned char csum;
-	char recv_csum[3];
-	int i;
-
-	while(1) {
-		/* Wait for packet start */
-		while((packet[0] = gdb_if_getchar()) != '$')
-			if(packet[0] == 0x04) return 1;
-
-		i = 0; csum = 0;
-		/* Capture packet data into buffer */
-		while((c = gdb_if_getchar()) != '#') {
-
-			if(i == size) break; /* Oh shit */
-
-			if(c == '$') { /* Restart capture */
-				i = 0;
-				csum = 0;
-				continue;
-			}
-			if(c == '}') { /* escaped char */
-				c = gdb_if_getchar();
-				csum += c + '}';
-				packet[i++] = c ^ 0x20;
-				continue;
-			}
-			csum += c;
-			packet[i++] = c;
-		}
-		recv_csum[0] = gdb_if_getchar();
-		recv_csum[1] = gdb_if_getchar();
-		recv_csum[2] = 0;
-
-		/* return packet if checksum matches */
-		if(csum == strtol(recv_csum, NULL, 16)) break;
-
-		/* get here if checksum fails */
-		gdb_if_putchar('-', 1); /* send nack */
-	}
-	gdb_if_putchar('+', 1); /* send ack */
-	packet[i] = 0;
-
-#ifdef DEBUG_GDBPACKET
-	DEBUG("%s : ", __func__);
-	for(int j = 0; j < i; j++) {
-		c = packet[j];
-		if ((c >= 32) && (c < 127))
-			DEBUG("%c", c);
-		else
-			DEBUG("\\x%02X", c);
-	}
-	DEBUG("\n");
-#endif
-	return i;
-}
-
-void gdb_putpacket(const char *packet, int size)
-{
-	int i;
-	unsigned char csum;
-	unsigned char c;
-	char xmit_csum[3];
-	int tries = 0;
-
-	do {
-#ifdef DEBUG_GDBPACKET
-		DEBUG("%s : ", __func__);
-#endif
-		csum = 0;
-		gdb_if_putchar('$', 0);
-		for(i = 0; i < size; i++) {
-			c = packet[i];
-#ifdef DEBUG_GDBPACKET
-			if ((c >= 32) && (c < 127))
-				DEBUG("%c", c);
-			else
-				DEBUG("\\x%02X", c);
-#endif
-			if((c == '$') || (c == '#') || (c == '}')) {
-				gdb_if_putchar('}', 0);
-				gdb_if_putchar(c ^ 0x20, 0);
-				csum += '}' + (c ^ 0x20);
-			} else {
-				gdb_if_putchar(c, 0);
-				csum += c;
-			}
-		}
-		gdb_if_putchar('#', 0);
-		sprintf(xmit_csum, "%02X", csum);
-		gdb_if_putchar(xmit_csum[0], 0);
-		gdb_if_putchar(xmit_csum[1], 1);
-#ifdef DEBUG_GDBPACKET
-		DEBUG("\n");
-#endif
-	} while((gdb_if_getchar_to(2000) != '+') && (tries++ < 3));
-}
-
-void gdb_putpacket_f(const char *fmt, ...)
-{
-	va_list ap;
-	char *buf;
-	int size;
-
-	va_start(ap, fmt);
-	size = vasprintf(&buf, fmt, ap);
-	gdb_putpacket(buf, size);
-	free(buf);
-	va_end(ap);
-}
-
-void gdb_out(const char *buf)
-{
-	char *hexdata;
-	int i;
-
-	hexdata = alloca((i = strlen(buf)*2 + 1) + 1);
-	hexdata[0] = 'O';
-	hexify(hexdata+1, buf, strlen(buf));
-	gdb_putpacket(hexdata, i);
-}
-
-void gdb_voutf(const char *fmt, va_list ap)
-{
-	char *buf;
-
-	if (vasprintf(&buf, fmt, ap) < 0)
-		return;
-	gdb_out(buf);
-	free(buf);
-}
-
-void gdb_outf(const char *fmt, ...)
-{
-	va_list ap;
-
-	va_start(ap, fmt);
-	gdb_voutf(fmt, ap);
-	va_end(ap);
-}
diff --git a/src/main.c b/src/main.c
index de11953..1170dea 100644
--- a/src/main.c
+++ b/src/main.c
@@ -23,12 +23,8 @@
  */
 
 #include "general.h"
-#include "gdb_if.h"
-#include "gdb_main.h"
 #include "target.h"
 #include "exception.h"
-#include "gdb_packet.h"
-#include "morse.h"
 
 int
 main(int argc, char **argv)
@@ -42,15 +38,7 @@ main(int argc, char **argv)
 #endif
 
 	while (true) {
-		volatile struct exception e;
-		TRY_CATCH(e, EXCEPTION_ALL) {
-			gdb_main();
-		}
-		if (e.type) {
-			gdb_putpacketz("EFF");
-			target_list_free();
-			morse("TARGET LOST.", 1);
-		}
+        asm("nop");
 	}
 
 	/* Should never get here */
diff --git a/src/morse.c b/src/morse.c
deleted file mode 100644
index 6b17c16..0000000
--- a/src/morse.c
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2015  Black Sphere Technologies Ltd.
- * Written by Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-#include "general.h"
-#include "morse.h"
-
-/* Morse code patterns and lengths */
-static const struct {
-	uint16_t code;
-	uint8_t bits;
-} morse_letter[] = {
-	{        0b00011101,  8}, // 'A' .-
-	{    0b000101010111, 12}, // 'B' -...
-	{  0b00010111010111, 14}, // 'C' -.-.
-	{      0b0001010111, 10}, // 'D' -..
-	{            0b0001,  4}, // 'E' .
-	{    0b000101110101, 12}, // 'F' ..-.
-	{    0b000101110111, 12}, // 'G' --.
-	{      0b0001010101, 10}, // 'H' ....
-	{          0b000101,  6}, // 'I' ..
-	{0b0001110111011101, 16}, // 'J' .---
-	{    0b000111010111, 12}, // 'K' -.-
-	{    0b000101011101, 12}, // 'L' .-..
-	{      0b0001110111, 10}, // 'M' --
-	{        0b00010111,  8}, // 'N' -.
-	{  0b00011101110111, 14}, // 'O' ---
-	{  0b00010111011101, 14}, // 'P' .--.
-	{0b0001110101110111, 16}, // 'Q' --.-
-	{      0b0001011101, 10}, // 'R' .-.
-	{        0b00010101,  8}, // 'S' ...
-	{          0b000111,  6}, // 'T' -
-	{      0b0001110101, 10}, // 'U' ..-
-	{    0b000111010101, 12}, // 'V' ...-
-	{    0b000111011101, 12}, // 'W' .--
-	{  0b00011101010111, 14}, // 'X' -..-
-	{0b0001110111010111, 16}, // 'Y' -.--
-	{  0b00010101110111, 14}, // 'Z' --..
-};
-
-const char *morse_msg;
-static const char * volatile morse_ptr;
-static char morse_repeat;
-
-void morse(const char *msg, char repeat)
-{
-	morse_msg = morse_ptr = msg;
-	morse_repeat = repeat;
-}
-
-bool morse_update(void)
-{
-	static uint16_t code;
-	static uint8_t bits;
-
-	if (!morse_ptr)
-		return false;
-
-	if (!bits) {
-		char c = *morse_ptr++;
-		if (!c) {
-			if(morse_repeat) {
-				morse_ptr = morse_msg;
-				c = *morse_ptr++;
-			} else {
-				morse_ptr = 0;
-				return false;
-			}
-		}
-		if ((c >= 'A') && (c <= 'Z')) {
-			c -= 'A';
-			code = morse_letter[c].code;
-			bits = morse_letter[c].bits;
-		} else {
-			code = 0; bits = 4;
-		}
-	}
-
-	bool ret = code & 1;
-	code >>= 1;
-	bits--;
-
-	return ret;
-}
-
diff --git a/src/target/adiv5.c b/src/target/adiv5.c
deleted file mode 100644
index 8d86936..0000000
--- a/src/target/adiv5.c
+++ /dev/null
@@ -1,585 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2015  Black Sphere Technologies Ltd.
- * Written by Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/* This file implements the transport generic functions of the
- * ARM Debug Interface v5 Architecure Specification, ARM doc IHI0031A.
- */
-#include "general.h"
-#include "target.h"
-#include "target_internal.h"
-#include "adiv5.h"
-#include "cortexm.h"
-#include "exception.h"
-
-#ifndef DO_RESET_SEQ
-#define DO_RESET_SEQ 0
-#endif
-
-/* All this should probably be defined in a dedicated ADIV5 header, so that they
- * are consistently named and accessible when needed in the codebase.
- */
-
-/* ROM table CIDR values */
-#define CIDR0_OFFSET    0xFF0 /* DBGCID0 */
-#define CIDR1_OFFSET    0xFF4 /* DBGCID1 */
-#define CIDR2_OFFSET    0xFF8 /* DBGCID2 */
-#define CIDR3_OFFSET    0xFFC /* DBGCID3 */
-
-/* Component class ID register can be broken down into the following logical
- * interpretation of the 32bit value consisting of the least significant bytes
- * of the 4 CID registers:
- * |7   ID3 reg   0|7   ID2 reg   0|7   ID1 reg   0|7   ID0 reg   0|
- * |1|0|1|1|0|0|0|1|0|0|0|0|0|1|0|1| | | | |0|0|0|0|0|0|0|0|1|1|0|1|
- * |31           24|23           16|15   12|11     |              0|
- * \_______________ ______________/\___ __/\___________ ___________/
- *                 V                   V               V
- *             Preamble            Component       Preamble
- *                                   Class
- * \_______________________________ _______________________________/
- *                                 V
- *                           Component ID
- */
-#define CID_PREAMBLE    0xB105000D
-#define CID_CLASS_MASK  0x0000F000
-#define CID_CLASS_SHIFT 12
-/* The following enum is based on the Component Class value table 13-3 of the
- * ADIv5 standard.
- */
-enum cid_class {
-	cidc_gvc = 0x0,    /* Generic verification component*/
-	cidc_romtab = 0x1, /* ROM Table, std. layout (ADIv5 Chapter 14) */
-	/* 0x2 - 0x8 */    /* Reserved */
-	cidc_dc = 0x9,     /* Debug component, std. layout (CoreSight Arch. Spec.) */
-	/* 0xA */          /* Reserved */
-	cidc_ptb = 0xB,    /* Peripheral Test Block (PTB) */
-	/* 0xC */          /* Reserved */
-	cidc_dess = 0xD,   /* OptimoDE Data Engine SubSystem (DESS) component */
-	cidc_gipc = 0xE,   /* Generic IP Component */
-	cidc_pcp = 0xF,    /* PrimeCell peripheral */
-	cidc_unknown = 0x10
-};
-
-#ifdef PLATFORM_HAS_DEBUG
-/* The reserved ones only have an R in them, to save a bit of space. */
-static const char * const cidc_debug_strings[] =
-{
-	[cidc_gvc] =     "Generic verification component",           /* 0x0 */
-	[cidc_romtab] =  "ROM Table",                                /* 0x1 */
-	[0x2 ... 0x8] =  "R",                                        /* 0x2 - 0x8 */
-	[cidc_dc] =      "Debug component",                          /* 0x9 */
-	[0xA] =          "R",                                        /* 0xA */
-	[cidc_ptb] =     "Peripheral Test Block",                    /* 0xB */
-	[0xC] =          "R",                                        /* 0xC */
-	[cidc_dess] =    "OptimoDE Data Engine SubSystem component", /* 0xD */
-	[cidc_gipc] =    "Generic IP component",                     /* 0xE */
-	[cidc_pcp] =     "PrimeCell peripheral",                     /* 0xF */
-	[cidc_unknown] = "Unknown component class"                   /* 0x10 */
-};
-#endif
-
-#define PIDR0_OFFSET  0xFE0 /* DBGPID0 */
-#define PIDR1_OFFSET  0xFE4 /* DBGPID1 */
-#define PIDR2_OFFSET  0xFE8 /* DBGPID2 */
-#define PIDR3_OFFSET  0xFEC /* DBGPID3 */
-#define PIDR4_OFFSET  0xFD0 /* DBGPID4 */
-#define PIDR5_OFFSET  0xFD4 /* DBGPID5 (Reserved) */
-#define PIDR6_OFFSET  0xFD8 /* DBGPID6 (Reserved) */
-#define PIDR7_OFFSET  0xFDC /* DBGPID7 (Reserved) */
-#define PIDR_REV_MASK 0x0FFF00000ULL /* Revision bits. */
-#define PIDR_PN_MASK  0x000000FFFULL /* Part number bits. */
-#define PIDR_ARM_BITS 0x4000BB000ULL /* These make up the ARM JEP-106 code. */
-
-enum arm_arch {
-	aa_nosupport,
-	aa_cortexm,
-	aa_cortexa,
-	aa_end
-};
-
-#ifdef PLATFORM_HAS_DEBUG
-#define PIDR_PN_BIT_STRINGS(...) __VA_ARGS__
-#else
-#define PIDR_PN_BIT_STRINGS(...)
-#endif
-
-/* The part number list was adopted from OpenOCD:
- * https://sourceforge.net/p/openocd/code/ci/406f4/tree/src/target/arm_adi_v5.c#l932
- *
- * The product ID register consists of several parts. For a full description
- * refer to ARM Debug Interface v5 Architecture Specification. Based on the
- * document the pidr is 64 bit long and has the following interpratiation:
- * |7   ID7 reg   0|7   ID6 reg   0|7   ID5 reg   0|7   ID4 reg   0|
- * |0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0| | | | |1|0|0|0|
- * |63           56|55           48|47           40|39   36|35   32|
- * \_______________________ ______________________/\___ __/\___ ___/
- *                         V                           V       V
- *                    Reserved, RAZ                   4KB      |
- *                                                   count     |
- *                                                          JEP-106
- *                                                     Continuation Code
- *
- * |7   ID3 reg   0|7   ID2 reg   0|7   ID1 reg   0|7   ID0 reg   0|
- * | | | | | | | | | | | | |1|0|1|1|1|0|1|1| | | | | | | | | | | | |
- * |31   28|27   24|23   20|||18   |     12|11     |              0|
- * \___ __/\__ ___/\___ __/ |\______ _____/\___________ ___________/
- *     V      V        V    |       V                  V
- *  RevAnd    |    Revision |    JEP-106          Part number
- *            |             |    ID code
- *        Customer          19
- *        modified          `- JEP-106 code is used
- *
- * JEP-106 is a JEDEC standard assigning manufacturer IDs to different
- * manufacturers in case of ARM the full code consisting of the JEP-106
- * Continuation code followed by the code used bit and the JEP-106 code itself
- * results in the code 0x4BB. These are the bits filled in the above bit table.
- *
- * We left out some of the Part numbers included in OpenOCD, we only include
- * the ones that have ARM as the designer.
- */
-static const struct {
-	uint16_t part_number;
-	enum arm_arch arch;
-	enum cid_class cidc;
-#ifdef PLATFORM_HAS_DEBUG
-	const char *type;
-	const char *full;
-#endif
-} pidr_pn_bits[] = {
-	{0x000, aa_cortexm,   cidc_gipc,    PIDR_PN_BIT_STRINGS("Cortex-M3 SCS",  "(System Control Space)")},
-	{0x001, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("Cortex-M3 ITM",  "(Instrumentation Trace Module)")},
-	{0x002, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("Cortex-M3 DWT",  "(Data Watchpoint and Trace)")},
-	{0x003, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("Cortex-M3 FBP",  "(Flash Patch and Breakpoint)")},
-	{0x008, aa_cortexm,   cidc_gipc,    PIDR_PN_BIT_STRINGS("Cortex-M0 SCS",  "(System Control Space)")},
-	{0x00a, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("Cortex-M0 DWT",  "(Data Watchpoint and Trace)")},
-	{0x00b, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("Cortex-M0 BPU",  "(Breakpoint Unit)")},
-	{0x00c, aa_cortexm,   cidc_gipc,    PIDR_PN_BIT_STRINGS("Cortex-M4 SCS",  "(System Control Space)")},
-	{0x00d, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("CoreSight ETM11", "(Embedded Trace)")},
-	{0x490, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("Cortex-A15 GIC", "(Generic Interrupt Controller)")},
-	{0x4c7, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("Cortex-M7 PPB",  "(Private Peripheral Bus ROM Table)")},
-	{0x906, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("CoreSight CTI",  "(Cross Trigger)")},
-	{0x907, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("CoreSight ETB",  "(Trace Buffer)")},
-	{0x908, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("CoreSight CSTF", "(Trace Funnel)")},
-	{0x910, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("CoreSight ETM9", "(Embedded Trace)")},
-	{0x912, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("CoreSight TPIU", "(Trace Port Interface Unit)")},
-	{0x913, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("CoreSight ITM",  "(Instrumentation Trace Macrocell)")},
-	{0x914, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("CoreSight SWO",  "(Single Wire Output)")},
-	{0x917, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("CoreSight HTM",  "(AHB Trace Macrocell)")},
-	{0x920, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("CoreSight ETM11", "(Embedded Trace)")},
-	{0x921, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("Cortex-A8 ETM",  "(Embedded Trace)")},
-	{0x922, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("Cortex-A8 CTI",  "(Cross Trigger)")},
-	{0x923, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("Cortex-M3 TPIU", "(Trace Port Interface Unit)")},
-	{0x924, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("Cortex-M3 ETM",  "(Embedded Trace)")},
-	{0x925, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("Cortex-M4 ETM",  "(Embedded Trace)")},
-	{0x930, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("Cortex-R4 ETM",  "(Embedded Trace)")},
-	{0x941, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("CoreSight TPIU-Lite", "(Trace Port Interface Unit)")},
-	{0x950, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("CoreSight Component", "(unidentified Cortex-A9 component)")},
-	{0x955, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("CoreSight Component", "(unidentified Cortex-A5 component)")},
-	{0x95f, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("Cortex-A15 PTM", "(Program Trace Macrocell)")},
-	{0x961, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("CoreSight TMC",  "(Trace Memory Controller)")},
-	{0x962, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("CoreSight STM",  "(System Trace Macrocell)")},
-	{0x9a0, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("CoreSight PMU",  "(Performance Monitoring Unit)")},
-	{0x9a1, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("Cortex-M4 TPIU", "(Trace Port Interface Unit)")},
-	{0x9a5, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("Cortex-A5 ETM",  "(Embedded Trace)")},
-	{0x9a7, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("Cortex-A7 PMU",  "(Performance Monitor Unit)")},
-	{0x9af, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("Cortex-A15 PMU", "(Performance Monitor Unit)")},
-	{0xc05, aa_cortexa,   cidc_dc,      PIDR_PN_BIT_STRINGS("Cortex-A5 Debug", "(Debug Unit)")},
-	{0xc07, aa_cortexa,   cidc_dc,      PIDR_PN_BIT_STRINGS("Cortex-A7 Debug", "(Debug Unit)")},
-	{0xc08, aa_cortexa,   cidc_dc,      PIDR_PN_BIT_STRINGS("Cortex-A8 Debug", "(Debug Unit)")},
-	{0xc09, aa_cortexa,   cidc_dc,      PIDR_PN_BIT_STRINGS("Cortex-A9 Debug", "(Debug Unit)")},
-	{0xc0f, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("Cortex-A15 Debug", "(Debug Unit)")}, /* support? */
-	{0xc14, aa_nosupport, cidc_unknown, PIDR_PN_BIT_STRINGS("Cortex-R4 Debug", "(Debug Unit)")}, /* support? */
-	{0xfff, aa_end,       cidc_unknown, PIDR_PN_BIT_STRINGS("end", "end")}
-};
-
-extern bool cortexa_probe(ADIv5_AP_t *apb, uint32_t debug_base);
-
-void adiv5_dp_ref(ADIv5_DP_t *dp)
-{
-	dp->refcnt++;
-}
-
-void adiv5_ap_ref(ADIv5_AP_t *ap)
-{
-	ap->refcnt++;
-}
-
-void adiv5_dp_unref(ADIv5_DP_t *dp)
-{
-	if (--(dp->refcnt) == 0)
-		free(dp);
-}
-
-void adiv5_ap_unref(ADIv5_AP_t *ap)
-{
-	if (--(ap->refcnt) == 0) {
-		adiv5_dp_unref(ap->dp);
-		free(ap);
-	}
-}
-
-void adiv5_dp_write(ADIv5_DP_t *dp, uint16_t addr, uint32_t value)
-{
-	dp->low_access(dp, ADIV5_LOW_WRITE, addr, value);
-}
-
-static uint32_t adiv5_mem_read32(ADIv5_AP_t *ap, uint32_t addr)
-{
-	uint32_t ret;
-	adiv5_mem_read(ap, &ret, addr, sizeof(ret));
-	return ret;
-}
-
-static void adiv5_component_probe(ADIv5_AP_t *ap, uint32_t addr)
-{
-	addr &= ~3;
-	uint64_t pidr = 0;
-	uint32_t cidr = 0;
-
-	/* Assemble logical Product ID register value. */
-	for (int i = 0; i < 4; i++) {
-		uint32_t x = adiv5_mem_read32(ap, addr + PIDR0_OFFSET + 4*i);
-		pidr |= (x & 0xff) << (i * 8);
-	}
-	{
-		uint32_t x = adiv5_mem_read32(ap, addr + PIDR4_OFFSET);
-		pidr |= (uint64_t)x << 32;
-	}
-
-	/* Assemble logical Component ID register value. */
-	for (int i = 0; i < 4; i++) {
-		uint32_t x = adiv5_mem_read32(ap, addr + CIDR0_OFFSET + 4*i);
-		cidr |= ((uint64_t)(x & 0xff)) << (i * 8);
-	}
-
-	if (adiv5_dp_error(ap->dp)) {
-		DEBUG("Fault reading ID registers\n");
-		return;
-	}
-
-	/* CIDR preamble sanity check */
-	if ((cidr & ~CID_CLASS_MASK) != CID_PREAMBLE) {
-		DEBUG("0x%"PRIx32": 0x%"PRIx32" <- does not match preamble (0x%X)\n",
-                      addr, cidr, CID_PREAMBLE);
-		return;
-	}
-
-	/* Extract Component ID class nibble */
-	uint32_t cid_class = (cidr & CID_CLASS_MASK) >> CID_CLASS_SHIFT;
-
-	if (cid_class == cidc_romtab) { /* ROM table, probe recursively */
-		for (int i = 0; i < 256; i++) {
-			uint32_t entry = adiv5_mem_read32(ap, addr + i*4);
-			if (adiv5_dp_error(ap->dp)) {
-				DEBUG("Fault reading ROM table entry\n");
-			}
-
-			if (entry == 0)
-				break;
-
-			if ((entry & 1) == 0)
-				continue;
-
-			adiv5_component_probe(ap, addr + (entry & ~0xfff));
-		}
-	} else {
-		/* Check if the component was designed by ARM, we currently do not support,
-		 * any components by other designers.
-		 */
-		if ((pidr & ~(PIDR_REV_MASK | PIDR_PN_MASK)) != PIDR_ARM_BITS) {
-			DEBUG("0x%"PRIx32": 0x%"PRIx64" <- does not match ARM JEP-106\n",
-                              addr, pidr);
-			return;
-		}
-
-		/* Extract part number from the part id register. */
-		uint16_t part_number = pidr & PIDR_PN_MASK;
-		/* Find the part number in our part list and run the appropriate probe
-		 * routine if applicable.
-		 */
-		int i;
-		for (i = 0; pidr_pn_bits[i].arch != aa_end; i++) {
-			if (pidr_pn_bits[i].part_number == part_number) {
-				DEBUG("0x%"PRIx32": %s - %s %s\n", addr,
-				      cidc_debug_strings[cid_class],
-				      pidr_pn_bits[i].type,
-				      pidr_pn_bits[i].full);
-				/* Perform sanity check, if we know what to expect as component ID
-				 * class.
-				 */
-				if ((pidr_pn_bits[i].cidc != cidc_unknown) &&
-				    (cid_class != pidr_pn_bits[i].cidc)) {
-					DEBUG("WARNING: \"%s\" !match expected \"%s\"\n",
-					      cidc_debug_strings[cid_class],
-					      cidc_debug_strings[pidr_pn_bits[i].cidc]);
-				}
-				switch (pidr_pn_bits[i].arch) {
-				case aa_cortexm:
-					DEBUG("-> cortexm_probe\n");
-					cortexm_probe(ap);
-					break;
-				case aa_cortexa:
-					DEBUG("-> cortexa_probe\n");
-					cortexa_probe(ap, addr);
-					break;
-				default:
-					break;
-				}
-				break;
-			}
-		}
-		if (pidr_pn_bits[i].arch == aa_end) {
-			DEBUG("0x%"PRIx32": %s - Unknown (PIDR = 0x%"PRIx64")\n", addr,
-			      cidc_debug_strings[cid_class], pidr);
-		}
-	}
-}
-
-ADIv5_AP_t *adiv5_new_ap(ADIv5_DP_t *dp, uint8_t apsel)
-{
-	ADIv5_AP_t *ap, tmpap;
-
-	/* Assume valid and try to read IDR */
-	memset(&tmpap, 0, sizeof(tmpap));
-	tmpap.dp = dp;
-	tmpap.apsel = apsel;
-	tmpap.idr = adiv5_ap_read(&tmpap, ADIV5_AP_IDR);
-
-	if(!tmpap.idr) /* IDR Invalid - Should we not continue here? */
-		return NULL;
-
-	/* It's valid to so create a heap copy */
-	ap = malloc(sizeof(*ap));
-	memcpy(ap, &tmpap, sizeof(*ap));
-	adiv5_dp_ref(dp);
-
-	ap->cfg = adiv5_ap_read(ap, ADIV5_AP_CFG);
-	ap->base = adiv5_ap_read(ap, ADIV5_AP_BASE);
-	ap->csw = adiv5_ap_read(ap, ADIV5_AP_CSW) &
-		~(ADIV5_AP_CSW_SIZE_MASK | ADIV5_AP_CSW_ADDRINC_MASK);
-
-	if (ap->csw & ADIV5_AP_CSW_TRINPROG) {
-		DEBUG("AP transaction in progress.  Target may not be usable.\n");
-		ap->csw &= ~ADIV5_AP_CSW_TRINPROG;
-	}
-
-	DEBUG(" AP %3d: IDR=%08"PRIx32" CFG=%08"PRIx32" BASE=%08"PRIx32" CSW=%08"PRIx32"\n",
-	      apsel, ap->idr, ap->cfg, ap->base, ap->csw);
-
-	return ap;
-}
-
-
-void adiv5_dp_init(ADIv5_DP_t *dp)
-{
-	volatile uint32_t ctrlstat = 0;
-
-	adiv5_dp_ref(dp);
-
-	volatile struct exception e;
-	TRY_CATCH (e, EXCEPTION_TIMEOUT) {
-		ctrlstat = adiv5_dp_read(dp, ADIV5_DP_CTRLSTAT);
-	}
-	if (e.type) {
-		DEBUG("DP not responding!  Trying abort sequence...\n");
-		adiv5_dp_abort(dp, ADIV5_DP_ABORT_DAPABORT);
-		ctrlstat = adiv5_dp_read(dp, ADIV5_DP_CTRLSTAT);
-	}
-
-	/* Write request for system and debug power up */
-	adiv5_dp_write(dp, ADIV5_DP_CTRLSTAT,
-			ctrlstat |= ADIV5_DP_CTRLSTAT_CSYSPWRUPREQ |
-				ADIV5_DP_CTRLSTAT_CDBGPWRUPREQ);
-	/* Wait for acknowledge */
-	while(((ctrlstat = adiv5_dp_read(dp, ADIV5_DP_CTRLSTAT)) &
-		(ADIV5_DP_CTRLSTAT_CSYSPWRUPACK | ADIV5_DP_CTRLSTAT_CDBGPWRUPACK)) !=
-		(ADIV5_DP_CTRLSTAT_CSYSPWRUPACK | ADIV5_DP_CTRLSTAT_CDBGPWRUPACK));
-
-	if(DO_RESET_SEQ) {
-		/* This AP reset logic is described in ADIv5, but fails to work
-		 * correctly on STM32.  CDBGRSTACK is never asserted, and we
-		 * just wait forever.
-		 */
-
-		/* Write request for debug reset */
-		adiv5_dp_write(dp, ADIV5_DP_CTRLSTAT,
-				ctrlstat |= ADIV5_DP_CTRLSTAT_CDBGRSTREQ);
-		/* Wait for acknowledge */
-		while(!((ctrlstat = adiv5_dp_read(dp, ADIV5_DP_CTRLSTAT)) &
-				ADIV5_DP_CTRLSTAT_CDBGRSTACK));
-
-		/* Write request for debug reset release */
-		adiv5_dp_write(dp, ADIV5_DP_CTRLSTAT,
-				ctrlstat &= ~ADIV5_DP_CTRLSTAT_CDBGRSTREQ);
-		/* Wait for acknowledge */
-		while(adiv5_dp_read(dp, ADIV5_DP_CTRLSTAT) &
-				ADIV5_DP_CTRLSTAT_CDBGRSTACK);
-	}
-
-	/* Probe for APs on this DP */
-	for(int i = 0; i < 256; i++) {
-		ADIv5_AP_t *ap = adiv5_new_ap(dp, i);
-		if (ap == NULL)
-			continue;
-
-		extern void kinetis_mdm_probe(ADIv5_AP_t *);
-		kinetis_mdm_probe(ap);
-
-		if (ap->base == 0xffffffff) {
-			/* No debug entries... useless AP */
-			adiv5_ap_unref(ap);
-			continue;
-		}
-
-		/* Should probe further here to make sure it's a valid target.
-		 * AP should be unref'd if not valid.
-		 */
-
-		/* The rest sould only be added after checking ROM table */
-		adiv5_component_probe(ap, ap->base);
-	}
-	adiv5_dp_unref(dp);
-}
-
-enum align {
-	ALIGN_BYTE =  0,
-	ALIGN_HALFWORD = 1,
-	ALIGN_WORD = 2
-};
-#define ALIGNOF(x) (((x) & 3) == 0 ? ALIGN_WORD : \
-                    (((x) & 1) == 0 ? ALIGN_HALFWORD : ALIGN_BYTE))
-
-/* Program the CSW and TAR for sequencial access at a given width */
-static void ap_mem_access_setup(ADIv5_AP_t *ap, uint32_t addr, enum align align)
-{
-	uint32_t csw = ap->csw | ADIV5_AP_CSW_ADDRINC_SINGLE;
-
-	switch (align) {
-	case ALIGN_BYTE:
-		csw |= ADIV5_AP_CSW_SIZE_BYTE;
-		break;
-	case ALIGN_HALFWORD:
-		csw |= ADIV5_AP_CSW_SIZE_HALFWORD;
-		break;
-	case ALIGN_WORD:
-		csw |= ADIV5_AP_CSW_SIZE_WORD;
-		break;
-	}
-	adiv5_ap_write(ap, ADIV5_AP_CSW, csw);
-	adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_TAR, addr);
-}
-
-/* Extract read data from data lane based on align and src address */
-static void * extract(void *dest, uint32_t src, uint32_t val, enum align align)
-{
-	switch (align) {
-	case ALIGN_BYTE:
-		*(uint8_t *)dest = (val >> ((src & 0x3) << 3) & 0xFF);
-		break;
-	case ALIGN_HALFWORD:
-		*(uint16_t *)dest = (val >> ((src & 0x2) << 3) & 0xFFFF);
-		break;
-	case ALIGN_WORD:
-		*(uint32_t *)dest = val;
-		break;
-	}
-	return (uint8_t *)dest + (1 << align);
-}
-
-void
-adiv5_mem_read(ADIv5_AP_t *ap, void *dest, uint32_t src, size_t len)
-{
-	uint32_t tmp;
-	uint32_t osrc = src;
-	enum align align = MIN(ALIGNOF(src), ALIGNOF(len));
-
-	if (len == 0)
-		return;
-
-	len >>= align;
-	ap_mem_access_setup(ap, src, align);
-	adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
-	while (--len) {
-		tmp = adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
-		dest = extract(dest, src, tmp, align);
-
-		src += (1 << align);
-		/* Check for 10 bit address overflow */
-		if ((src ^ osrc) & 0xfffffc00) {
-			osrc = src;
-			adiv5_dp_low_access(ap->dp,
-					ADIV5_LOW_WRITE, ADIV5_AP_TAR, src);
-			adiv5_dp_low_access(ap->dp,
-					ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
-		}
-	}
-	tmp = adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_DP_RDBUFF, 0);
-	extract(dest, src, tmp, align);
-}
-
-void
-adiv5_mem_write(ADIv5_AP_t *ap, uint32_t dest, const void *src, size_t len)
-{
-	uint32_t odest = dest;
-	enum align align = MIN(ALIGNOF(dest), ALIGNOF(len));
-
-	len >>= align;
-	ap_mem_access_setup(ap, dest, align);
-	while (len--) {
-		uint32_t tmp = 0;
-		/* Pack data into correct data lane */
-		switch (align) {
-		case ALIGN_BYTE:
-			tmp = ((uint32_t)*(uint8_t *)src) << ((dest & 3) << 3);
-			break;
-		case ALIGN_HALFWORD:
-			tmp = ((uint32_t)*(uint16_t *)src) << ((dest & 2) << 3);
-			break;
-		case ALIGN_WORD:
-			tmp = *(uint32_t *)src;
-			break;
-		}
-		src = (uint8_t *)src + (1 << align);
-		dest += (1 << align);
-		adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_DRW, tmp);
-
-		/* Check for 10 bit address overflow */
-		if ((dest ^ odest) & 0xfffffc00) {
-			odest = dest;
-			adiv5_dp_low_access(ap->dp,
-					ADIV5_LOW_WRITE, ADIV5_AP_TAR, dest);
-		}
-	}
-}
-
-void adiv5_ap_write(ADIv5_AP_t *ap, uint16_t addr, uint32_t value)
-{
-	adiv5_dp_write(ap->dp, ADIV5_DP_SELECT,
-			((uint32_t)ap->apsel << 24)|(addr & 0xF0));
-	adiv5_dp_write(ap->dp, addr, value);
-}
-
-uint32_t adiv5_ap_read(ADIv5_AP_t *ap, uint16_t addr)
-{
-	uint32_t ret;
-	adiv5_dp_write(ap->dp, ADIV5_DP_SELECT,
-			((uint32_t)ap->apsel << 24)|(addr & 0xF0));
-	ret = adiv5_dp_read(ap->dp, addr);
-	return ret;
-}
diff --git a/src/target/adiv5.h b/src/target/adiv5.h
deleted file mode 100644
index ca81471..0000000
--- a/src/target/adiv5.h
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2011  Black Sphere Technologies Ltd.
- * Written by Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef __ADIV5_H
-#define __ADIV5_H
-
-#include "jtag_scan.h"
-
-#define ADIV5_APnDP       0x100
-#define ADIV5_DP_REG(x)   (x)
-#define ADIV5_AP_REG(x)   (ADIV5_APnDP | (x))
-
-/* ADIv5 DP Register addresses */
-#define ADIV5_DP_IDCODE   ADIV5_DP_REG(0x0)
-#define ADIV5_DP_ABORT    ADIV5_DP_REG(0x0)
-#define ADIV5_DP_CTRLSTAT ADIV5_DP_REG(0x4)
-#define ADIV5_DP_SELECT   ADIV5_DP_REG(0x8)
-#define ADIV5_DP_RDBUFF   ADIV5_DP_REG(0xC)
-
-/* AP Abort Register (ABORT) */
-/* Bits 31:5 - Reserved */
-#define ADIV5_DP_ABORT_ORUNERRCLR	(1 << 4)
-#define ADIV5_DP_ABORT_WDERRCLR		(1 << 3)
-#define ADIV5_DP_ABORT_STKERRCLR	(1 << 2)
-#define ADIV5_DP_ABORT_STKCMPCLR	(1 << 1)
-/* Bits 5:1 - SW-DP only, reserved in JTAG-DP */
-#define ADIV5_DP_ABORT_DAPABORT		(1 << 0)
-
-/* Control/Status Register (CTRLSTAT) */
-#define ADIV5_DP_CTRLSTAT_CSYSPWRUPACK	(1u << 31)
-#define ADIV5_DP_CTRLSTAT_CSYSPWRUPREQ	(1u << 30)
-#define ADIV5_DP_CTRLSTAT_CDBGPWRUPACK	(1u << 29)
-#define ADIV5_DP_CTRLSTAT_CDBGPWRUPREQ	(1u << 28)
-#define ADIV5_DP_CTRLSTAT_CDBGRSTACK	(1u << 27)
-#define ADIV5_DP_CTRLSTAT_CDBGRSTREQ	(1u << 26)
-/* Bits 25:24 - Reserved */
-/* Bits 23:12 - TRNCNT */
-#define ADIV5_DP_CTRLSTAT_TRNCNT
-/* Bits 11:8 - MASKLANE */
-#define ADIV5_DP_CTRLSTAT_MASKLANE
-/* Bits 7:6 - Reserved in JTAG-DP */
-#define ADIV5_DP_CTRLSTAT_WDATAERR	(1u << 7)
-#define ADIV5_DP_CTRLSTAT_READOK	(1u << 6)
-#define ADIV5_DP_CTRLSTAT_STICKYERR	(1u << 5)
-#define ADIV5_DP_CTRLSTAT_STICKYCMP	(1u << 4)
-#define ADIV5_DP_CTRLSTAT_TRNMODE_MASK	(3u << 2)
-#define ADIV5_DP_CTRLSTAT_STICKYORUN	(1u << 1)
-#define ADIV5_DP_CTRLSTAT_ORUNDETECT	(1u << 0)
-
-
-/* ADIv5 MEM-AP Registers */
-#define ADIV5_AP_CSW		ADIV5_AP_REG(0x00)
-#define ADIV5_AP_TAR		ADIV5_AP_REG(0x04)
-/* 0x08 - Reserved */
-#define ADIV5_AP_DRW		ADIV5_AP_REG(0x0C)
-#define ADIV5_AP_DB(x)		ADIV5_AP_REG(0x10 + (4*(x)))
-/* 0x20:0xF0 - Reserved */
-#define ADIV5_AP_CFG		ADIV5_AP_REG(0xF4)
-#define ADIV5_AP_BASE		ADIV5_AP_REG(0xF8)
-#define ADIV5_AP_IDR		ADIV5_AP_REG(0xFC)
-
-/* AP Control and Status Word (CSW) */
-#define ADIV5_AP_CSW_DBGSWENABLE	(1u << 31)
-/* Bits 30:24 - Prot, Implementation defined, for Cortex-M3: */
-#define ADIV5_AP_CSW_MASTERTYPE_DEBUG	(1u << 29)
-#define ADIV5_AP_CSW_HPROT1		(1u << 25)
-#define ADIV5_AP_CSW_SPIDEN		(1u << 23)
-/* Bits 22:12 - Reserved */
-/* Bits 11:8 - Mode, must be zero */
-#define ADIV5_AP_CSW_TRINPROG		(1u << 7)
-#define ADIV5_AP_CSW_DEVICEEN		(1u << 6)
-#define ADIV5_AP_CSW_ADDRINC_NONE	(0u << 4)
-#define ADIV5_AP_CSW_ADDRINC_SINGLE	(1u << 4)
-#define ADIV5_AP_CSW_ADDRINC_PACKED	(2u << 4)
-#define ADIV5_AP_CSW_ADDRINC_MASK	(3u << 4)
-/* Bit 3 - Reserved */
-#define ADIV5_AP_CSW_SIZE_BYTE		(0u << 0)
-#define ADIV5_AP_CSW_SIZE_HALFWORD	(1u << 0)
-#define ADIV5_AP_CSW_SIZE_WORD		(2u << 0)
-#define ADIV5_AP_CSW_SIZE_MASK		(7u << 0)
-
-/* Constants to make RnW parameters more clear in code */
-#define ADIV5_LOW_WRITE		0
-#define ADIV5_LOW_READ		1
-
-/* Try to keep this somewhat absract for later adding SW-DP */
-typedef struct ADIv5_DP_s {
-	int refcnt;
-
-	uint32_t idcode;
-
-	uint32_t (*dp_read)(struct ADIv5_DP_s *dp, uint16_t addr);
-	uint32_t (*error)(struct ADIv5_DP_s *dp);
-	uint32_t (*low_access)(struct ADIv5_DP_s *dp, uint8_t RnW,
-                               uint16_t addr, uint32_t value);
-	void (*abort)(struct ADIv5_DP_s *dp, uint32_t abort);
-
-	union {
-		jtag_dev_t *dev;
-		uint8_t fault;
-	};
-} ADIv5_DP_t;
-
-static inline uint32_t adiv5_dp_read(ADIv5_DP_t *dp, uint16_t addr)
-{
-	return dp->dp_read(dp, addr);
-}
-
-static inline uint32_t adiv5_dp_error(ADIv5_DP_t *dp)
-{
-	return dp->error(dp);
-}
-
-static inline uint32_t adiv5_dp_low_access(struct ADIv5_DP_s *dp, uint8_t RnW,
-                                           uint16_t addr, uint32_t value)
-{
-	return dp->low_access(dp, RnW, addr, value);
-}
-
-static inline void adiv5_dp_abort(struct ADIv5_DP_s *dp, uint32_t abort)
-{
-	return dp->abort(dp, abort);
-}
-
-typedef struct ADIv5_AP_s {
-	int refcnt;
-
-	ADIv5_DP_t *dp;
-	uint8_t apsel;
-
-	uint32_t idr;
-	uint32_t cfg;
-	uint32_t base;
-	uint32_t csw;
-} ADIv5_AP_t;
-
-void adiv5_dp_init(ADIv5_DP_t *dp);
-void adiv5_dp_write(ADIv5_DP_t *dp, uint16_t addr, uint32_t value);
-
-ADIv5_AP_t *adiv5_new_ap(ADIv5_DP_t *dp, uint8_t apsel);
-void adiv5_dp_ref(ADIv5_DP_t *dp);
-void adiv5_ap_ref(ADIv5_AP_t *ap);
-void adiv5_dp_unref(ADIv5_DP_t *dp);
-void adiv5_ap_unref(ADIv5_AP_t *ap);
-
-void adiv5_ap_write(ADIv5_AP_t *ap, uint16_t addr, uint32_t value);
-uint32_t adiv5_ap_read(ADIv5_AP_t *ap, uint16_t addr);
-
-void adiv5_jtag_dp_handler(jtag_dev_t *dev);
-
-void adiv5_mem_read(ADIv5_AP_t *ap, void *dest, uint32_t src, size_t len);
-void adiv5_mem_write(ADIv5_AP_t *ap, uint32_t dest, const void *src, size_t len);
-
-#endif
-
diff --git a/src/target/adiv5_jtagdp.c b/src/target/adiv5_jtagdp.c
deleted file mode 100644
index c8b5847..0000000
--- a/src/target/adiv5_jtagdp.c
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2011  Black Sphere Technologies Ltd.
- * Written by Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/* This file implements the JTAG-DP specific functions of the
- * ARM Debug Interface v5 Architecure Specification, ARM doc IHI0031A.
- */
-
-#include "general.h"
-#include "exception.h"
-#include "adiv5.h"
-#include "jtag_scan.h"
-#include "jtagtap.h"
-#include "morse.h"
-
-#define JTAGDP_ACK_OK	0x02
-#define JTAGDP_ACK_WAIT	0x01
-
-/* 35-bit registers that control the ADIv5 DP */
-#define IR_ABORT	0x8
-#define IR_DPACC	0xA
-#define IR_APACC	0xB
-
-static uint32_t adiv5_jtagdp_read(ADIv5_DP_t *dp, uint16_t addr);
-
-static uint32_t adiv5_jtagdp_error(ADIv5_DP_t *dp);
-
-static uint32_t adiv5_jtagdp_low_access(ADIv5_DP_t *dp, uint8_t RnW,
-					uint16_t addr, uint32_t value);
-
-static void adiv5_jtagdp_abort(ADIv5_DP_t *dp, uint32_t abort);
-
-void adiv5_jtag_dp_handler(jtag_dev_t *dev)
-{
-	ADIv5_DP_t *dp = (void*)calloc(1, sizeof(*dp));
-
-	dp->dev = dev;
-	dp->idcode = dev->idcode;
-
-	dp->dp_read = adiv5_jtagdp_read;
-	dp->error = adiv5_jtagdp_error;
-	dp->low_access = adiv5_jtagdp_low_access;
-	dp->abort = adiv5_jtagdp_abort;
-
-	adiv5_dp_init(dp);
-}
-
-static uint32_t adiv5_jtagdp_read(ADIv5_DP_t *dp, uint16_t addr)
-{
-	adiv5_jtagdp_low_access(dp, ADIV5_LOW_READ, addr, 0);
-	return adiv5_jtagdp_low_access(dp, ADIV5_LOW_READ,
-					ADIV5_DP_RDBUFF, 0);
-}
-
-static uint32_t adiv5_jtagdp_error(ADIv5_DP_t *dp)
-{
-	adiv5_jtagdp_low_access(dp, ADIV5_LOW_READ, ADIV5_DP_CTRLSTAT, 0);
-	return adiv5_jtagdp_low_access(dp, ADIV5_LOW_WRITE,
-				ADIV5_DP_CTRLSTAT, 0xF0000032) & 0x32;
-}
-
-static uint32_t adiv5_jtagdp_low_access(ADIv5_DP_t *dp, uint8_t RnW,
-					uint16_t addr, uint32_t value)
-{
-	bool APnDP = addr & ADIV5_APnDP;
-	addr &= 0xff;
-	uint64_t request, response;
-	uint8_t ack;
-	platform_timeout timeout;
-
-	request = ((uint64_t)value << 3) | ((addr >> 1) & 0x06) | (RnW?1:0);
-
-	jtag_dev_write_ir(dp->dev, APnDP ? IR_APACC : IR_DPACC);
-
-	platform_timeout_set(&timeout, 2000);
-	do {
-		jtag_dev_shift_dr(dp->dev, (uint8_t*)&response, (uint8_t*)&request, 35);
-		ack = response & 0x07;
-	} while(!platform_timeout_is_expired(&timeout) && (ack == JTAGDP_ACK_WAIT));
-
-	if (ack == JTAGDP_ACK_WAIT)
-		raise_exception(EXCEPTION_TIMEOUT, "JTAG-DP ACK timeout");
-
-	if((ack != JTAGDP_ACK_OK))
-		raise_exception(EXCEPTION_ERROR, "JTAG-DP invalid ACK");
-
-	return (uint32_t)(response >> 3);
-}
-
-static void adiv5_jtagdp_abort(ADIv5_DP_t *dp, uint32_t abort)
-{
-	uint64_t request = (uint64_t)abort << 3;
-	jtag_dev_write_ir(dp->dev, IR_ABORT);
-	jtag_dev_shift_dr(dp->dev, NULL, (const uint8_t*)&request, 35);
-}
-
diff --git a/src/target/adiv5_swdp.c b/src/target/adiv5_swdp.c
deleted file mode 100644
index d62a18e..0000000
--- a/src/target/adiv5_swdp.c
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2011  Black Sphere Technologies Ltd.
- * Written by Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/* This file implements the SW-DP specific functions of the
- * ARM Debug Interface v5 Architecure Specification, ARM doc IHI0031A.
- */
-
-#include "general.h"
-#include "exception.h"
-#include "adiv5.h"
-#include "swdptap.h"
-#include "target.h"
-#include "target_internal.h"
-
-#define SWDP_ACK_OK    0x01
-#define SWDP_ACK_WAIT  0x02
-#define SWDP_ACK_FAULT 0x04
-
-static uint32_t adiv5_swdp_read(ADIv5_DP_t *dp, uint16_t addr);
-
-static uint32_t adiv5_swdp_error(ADIv5_DP_t *dp);
-
-static uint32_t adiv5_swdp_low_access(ADIv5_DP_t *dp, uint8_t RnW,
-				      uint16_t addr, uint32_t value);
-
-static void adiv5_swdp_abort(ADIv5_DP_t *dp, uint32_t abort);
-
-int adiv5_swdp_scan(void)
-{
-	uint8_t ack;
-
-	target_list_free();
-	ADIv5_DP_t *dp = (void*)calloc(1, sizeof(*dp));
-
-	swdptap_init();
-
-	/* Switch from JTAG to SWD mode */
-	swdptap_seq_out(0xFFFF, 16);
-	for(int i = 0; i < 50; i++)
-		swdptap_bit_out(1);
-	swdptap_seq_out(0xE79E, 16); /* 0b0111100111100111 */
-	for(int i = 0; i < 50; i++)
-		swdptap_bit_out(1);
-	swdptap_seq_out(0, 16);
-
-	/* Read the SW-DP IDCODE register to syncronise */
-	/* This could be done with adiv_swdp_low_access(), but this doesn't
-	 * allow the ack to be checked here. */
-	swdptap_seq_out(0xA5, 8);
-	ack = swdptap_seq_in(3);
-	if((ack != SWDP_ACK_OK) || swdptap_seq_in_parity(&dp->idcode, 32)) {
-		DEBUG("\n");
-		free(dp);
-		return -1;
-	}
-
-	dp->dp_read = adiv5_swdp_read;
-	dp->error = adiv5_swdp_error;
-	dp->low_access = adiv5_swdp_low_access;
-	dp->abort = adiv5_swdp_abort;
-
-	adiv5_swdp_error(dp);
-	adiv5_dp_init(dp);
-
-	return target_list?1:0;
-}
-
-static uint32_t adiv5_swdp_read(ADIv5_DP_t *dp, uint16_t addr)
-{
-	if (addr & ADIV5_APnDP) {
-		adiv5_dp_low_access(dp, ADIV5_LOW_READ, addr, 0);
-		return adiv5_dp_low_access(dp, ADIV5_LOW_READ,
-		                           ADIV5_DP_RDBUFF, 0);
-	} else {
-		return adiv5_swdp_low_access(dp, ADIV5_LOW_READ, addr, 0);
-	}
-}
-
-static uint32_t adiv5_swdp_error(ADIv5_DP_t *dp)
-{
-	uint32_t err, clr = 0;
-
-	err = adiv5_swdp_read(dp, ADIV5_DP_CTRLSTAT) &
-		(ADIV5_DP_CTRLSTAT_STICKYORUN | ADIV5_DP_CTRLSTAT_STICKYCMP |
-		ADIV5_DP_CTRLSTAT_STICKYERR | ADIV5_DP_CTRLSTAT_WDATAERR);
-
-	if(err & ADIV5_DP_CTRLSTAT_STICKYORUN)
-		clr |= ADIV5_DP_ABORT_ORUNERRCLR;
-	if(err & ADIV5_DP_CTRLSTAT_STICKYCMP)
-		clr |= ADIV5_DP_ABORT_STKCMPCLR;
-	if(err & ADIV5_DP_CTRLSTAT_STICKYERR)
-		clr |= ADIV5_DP_ABORT_STKERRCLR;
-	if(err & ADIV5_DP_CTRLSTAT_WDATAERR)
-		clr |= ADIV5_DP_ABORT_WDERRCLR;
-
-	adiv5_dp_write(dp, ADIV5_DP_ABORT, clr);
-	dp->fault = 0;
-
-	return err;
-}
-
-static uint32_t adiv5_swdp_low_access(ADIv5_DP_t *dp, uint8_t RnW,
-				      uint16_t addr, uint32_t value)
-{
-	bool APnDP = addr & ADIV5_APnDP;
-	addr &= 0xff;
-	uint8_t request = 0x81;
-	uint32_t response = 0;
-	uint8_t ack;
-	platform_timeout timeout;
-
-	if(APnDP && dp->fault) return 0;
-
-	if(APnDP) request ^= 0x22;
-	if(RnW)   request ^= 0x24;
-
-	addr &= 0xC;
-	request |= (addr << 1) & 0x18;
-	if((addr == 4) || (addr == 8))
-		request ^= 0x20;
-
-	platform_timeout_set(&timeout, 2000);
-	do {
-		swdptap_seq_out(request, 8);
-		ack = swdptap_seq_in(3);
-	} while (!platform_timeout_is_expired(&timeout) && ack == SWDP_ACK_WAIT);
-
-	if (ack == SWDP_ACK_WAIT)
-		raise_exception(EXCEPTION_TIMEOUT, "SWDP ACK timeout");
-
-	if(ack == SWDP_ACK_FAULT) {
-		dp->fault = 1;
-		return 0;
-	}
-
-	if(ack != SWDP_ACK_OK)
-		raise_exception(EXCEPTION_ERROR, "SWDP invalid ACK");
-
-	if(RnW) {
-		if(swdptap_seq_in_parity(&response, 32))  /* Give up on parity error */
-			raise_exception(EXCEPTION_ERROR, "SWDP Parity error");
-	} else {
-		swdptap_seq_out_parity(value, 32);
-	}
-
-	/* REMOVE THIS */
-	swdptap_seq_out(0, 8);
-
-	return response;
-}
-
-static void adiv5_swdp_abort(ADIv5_DP_t *dp, uint32_t abort)
-{
-	adiv5_dp_write(dp, ADIV5_DP_ABORT, abort);
-}
-
diff --git a/src/target/cortexa.c b/src/target/cortexa.c
deleted file mode 100644
index e562673..0000000
--- a/src/target/cortexa.c
+++ /dev/null
@@ -1,730 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2016  Black Sphere Technologies Ltd.
- * Written by Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/* This file implements debugging functionality specific to ARM
- * the Cortex-A9 core.  This should be generic to ARMv7-A as it is
- * implemented according to the "ARMv7-A Architecture Reference Manual",
- * ARM doc DDI0406C.
- *
- * Cache line length is from Cortex-A9 TRM, may differ for others.
- * Janky reset code is for Zynq-7000 which disconnects the DP from the JTAG
- * scan chain during reset.
- */
-#include "general.h"
-#include "exception.h"
-#include "adiv5.h"
-#include "target.h"
-#include "target_internal.h"
-
-static const char cortexa_driver_str[] = "ARM Cortex-A";
-
-static bool cortexa_attach(target *t);
-static void cortexa_detach(target *t);
-static void cortexa_halt_resume(target *t, bool step);
-
-static void cortexa_regs_read(target *t, void *data);
-static void cortexa_regs_write(target *t, const void *data);
-static void cortexa_regs_read_internal(target *t);
-static void cortexa_regs_write_internal(target *t);
-
-static void cortexa_reset(target *t);
-static enum target_halt_reason cortexa_halt_poll(target *t, target_addr *watch);
-static void cortexa_halt_request(target *t);
-
-static int cortexa_breakwatch_set(target *t, struct breakwatch *);
-static int cortexa_breakwatch_clear(target *t, struct breakwatch *);
-static uint32_t bp_bas(uint32_t addr, uint8_t len);
-
-static void apb_write(target *t, uint16_t reg, uint32_t val);
-static uint32_t apb_read(target *t, uint16_t reg);
-static void write_gpreg(target *t, uint8_t regno, uint32_t val);
-static uint32_t read_gpreg(target *t, uint8_t regno);
-
-struct cortexa_priv {
-	uint32_t base;
-	ADIv5_AP_t *apb;
-	struct {
-		uint32_t r[16];
-		uint32_t cpsr;
-		uint32_t fpscr;
-		uint64_t d[16];
-	} reg_cache;
-	unsigned hw_breakpoint_max;
-	uint16_t hw_breakpoint_mask;
-	uint32_t bcr0;
-	uint32_t bvr0;
-	bool mmu_fault;
-};
-
-/* This may be specific to Cortex-A9 */
-#define CACHE_LINE_LENGTH        (8*4)
-
-/* Debug APB registers */
-#define DBGDIDR                  0
-
-#define DBGDTRRX                 32 /* DCC: Host to target */
-#define DBGITR                   33
-
-#define DBGDSCR                  34
-#define DBGDSCR_TXFULL           (1 << 29)
-#define DBGDSCR_INSTRCOMPL       (1 << 24)
-#define DBGDSCR_EXTDCCMODE_STALL (1 << 20)
-#define DBGDSCR_EXTDCCMODE_FAST  (2 << 20)
-#define DBGDSCR_EXTDCCMODE_MASK  (3 << 20)
-#define DBGDSCR_HDBGEN           (1 << 14)
-#define DBGDSCR_ITREN            (1 << 13)
-#define DBGDSCR_INTDIS           (1 << 11)
-#define DBGDSCR_UND_I            (1 << 8)
-#define DBGDSCR_SDABORT_L        (1 << 6)
-#define DBGDSCR_MOE_MASK         (0xf << 2)
-#define DBGDSCR_MOE_HALT_REQ     (0x0 << 2)
-#define DBGDSCR_RESTARTED        (1 << 1)
-#define DBGDSCR_HALTED           (1 << 0)
-
-#define DBGDTRTX                 35 /* DCC: Target to host */
-
-#define DBGDRCR                  36
-#define DBGDRCR_CSE              (1 << 2)
-#define DBGDRCR_RRQ              (1 << 1)
-#define DBGDRCR_HRQ              (1 << 0)
-
-#define DBGBVR(i)                (64+(i))
-#define DBGBCR(i)                (80+(i))
-#define DBGBCR_INST_MISMATCH     (4 << 20)
-#define DBGBCR_BAS_ANY           (0xf << 5)
-#define DBGBCR_BAS_LOW_HW        (0x3 << 5)
-#define DBGBCR_BAS_HIGH_HW       (0xc << 5)
-#define DBGBCR_EN                (1 << 0)
-
-/* Instruction encodings for accessing the coprocessor interface */
-#define MCR 0xee000010
-#define MRC 0xee100010
-#define CPREG(coproc, opc1, rt, crn, crm, opc2) \
-	(((opc1) << 21) | ((crn) << 16) | ((rt) << 12) | \
-        ((coproc) << 8) | ((opc2) << 5) | (crm))
-
-/* Debug registers CP14 */
-#define DBGDTRRXint CPREG(14, 0, 0, 0, 5, 0)
-#define DBGDTRTXint CPREG(14, 0, 0, 0, 5, 0)
-
-/* Address translation registers CP15 */
-#define PAR         CPREG(15, 0, 0, 7, 4, 0)
-#define ATS1CPR     CPREG(15, 0, 0, 7, 8, 0)
-
-/* Cache management registers CP15 */
-#define ICIALLU     CPREG(15, 0, 0, 7, 5, 0)
-#define DCCIMVAC    CPREG(15, 0, 0, 7, 14, 1)
-#define DCCMVAC     CPREG(15, 0, 0, 7, 10, 1)
-
-/* Thumb mode bit in CPSR */
-#define CPSR_THUMB               (1 << 5)
-
-/* GDB register map / target description */
-static const char tdesc_cortex_a[] =
-	"<?xml version=\"1.0\"?>"
-	"<!DOCTYPE feature SYSTEM \"gdb-target.dtd\">"
-	"<target>"
-	"  <architecture>arm</architecture>"
-	"  <feature name=\"org.gnu.gdb.arm.core\">"
-	"    <reg name=\"r0\" bitsize=\"32\"/>"
-	"    <reg name=\"r1\" bitsize=\"32\"/>"
-	"    <reg name=\"r2\" bitsize=\"32\"/>"
-	"    <reg name=\"r3\" bitsize=\"32\"/>"
-	"    <reg name=\"r4\" bitsize=\"32\"/>"
-	"    <reg name=\"r5\" bitsize=\"32\"/>"
-	"    <reg name=\"r6\" bitsize=\"32\"/>"
-	"    <reg name=\"r7\" bitsize=\"32\"/>"
-	"    <reg name=\"r8\" bitsize=\"32\"/>"
-	"    <reg name=\"r9\" bitsize=\"32\"/>"
-	"    <reg name=\"r10\" bitsize=\"32\"/>"
-	"    <reg name=\"r11\" bitsize=\"32\"/>"
-	"    <reg name=\"r12\" bitsize=\"32\"/>"
-	"    <reg name=\"sp\" bitsize=\"32\" type=\"data_ptr\"/>"
-	"    <reg name=\"lr\" bitsize=\"32\" type=\"code_ptr\"/>"
-	"    <reg name=\"pc\" bitsize=\"32\" type=\"code_ptr\"/>"
-	"    <reg name=\"cpsr\" bitsize=\"32\"/>"
-	"  </feature>"
-	"  <feature name=\"org.gnu.gdb.arm.vfp\">"
-	"    <reg name=\"fpscr\" bitsize=\"32\"/>"
-	"    <reg name=\"d0\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d1\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d2\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d3\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d4\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d5\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d6\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d7\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d8\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d9\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d10\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d11\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d12\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d13\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d14\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d15\" bitsize=\"64\" type=\"float\"/>"
-	"  </feature>"
-	"</target>";
-
-static void apb_write(target *t, uint16_t reg, uint32_t val)
-{
-	struct cortexa_priv *priv = t->priv;
-	ADIv5_AP_t *ap = priv->apb;
-	uint32_t addr = priv->base + 4*reg;
-	adiv5_ap_write(ap, ADIV5_AP_TAR, addr);
-	adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_DRW, val);
-}
-
-static uint32_t apb_read(target *t, uint16_t reg)
-{
-	struct cortexa_priv *priv = t->priv;
-	ADIv5_AP_t *ap = priv->apb;
-	uint32_t addr = priv->base + 4*reg;
-	adiv5_ap_write(ap, ADIV5_AP_TAR, addr);
-	adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
-	return adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_DP_RDBUFF, 0);
-}
-
-static uint32_t va_to_pa(target *t, uint32_t va)
-{
-	struct cortexa_priv *priv = t->priv;
-	write_gpreg(t, 0, va);
-	apb_write(t, DBGITR, MCR | ATS1CPR);
-	apb_write(t, DBGITR, MRC | PAR);
-	uint32_t par = read_gpreg(t, 0);
-	if (par & 1)
-		priv->mmu_fault = true;
-	uint32_t pa = (par & ~0xfff) | (va & 0xfff);
-	DEBUG("%s: VA = 0x%08"PRIx32", PAR = 0x%08"PRIx32", PA = 0x%08"PRIX32"\n",
-              __func__, va, par, pa);
-	return pa;
-}
-
-static void cortexa_slow_mem_read(target *t, void *dest, target_addr src, size_t len)
-{
-	struct cortexa_priv *priv = t->priv;
-	unsigned words = (len + (src & 3) + 3) / 4;
-	uint32_t dest32[words];
-
-	/* Set r0 to aligned src address */
-	write_gpreg(t, 0, src & ~3);
-
-	/* Switch to fast DCC mode */
-	uint32_t dbgdscr = apb_read(t, DBGDSCR);
-	dbgdscr = (dbgdscr & ~DBGDSCR_EXTDCCMODE_MASK) | DBGDSCR_EXTDCCMODE_FAST;
-	apb_write(t, DBGDSCR, dbgdscr);
-
-	apb_write(t, DBGITR, 0xecb05e01); /* ldc 14, cr5, [r0], #4 */
-	/* According to the ARMv7-A ARM, in fast mode, the first read from
-	 * DBGDTRTX is  supposed to block until the instruction is complete,
-	 * but we see the first read returns junk, so it's read here and
-	 * ignored. */
-	apb_read(t, DBGDTRTX);
-
-	for (unsigned i = 0; i < words; i++)
-		dest32[i] = apb_read(t, DBGDTRTX);
-
-	memcpy(dest, (uint8_t*)dest32 + (src & 3), len);
-
-	/* Switch back to stalling DCC mode */
-	dbgdscr = (dbgdscr & ~DBGDSCR_EXTDCCMODE_MASK) | DBGDSCR_EXTDCCMODE_STALL;
-	apb_write(t, DBGDSCR, dbgdscr);
-
-	if (apb_read(t, DBGDSCR) & DBGDSCR_SDABORT_L) {
-		/* Memory access aborted, flag a fault */
-		apb_write(t, DBGDRCR, DBGDRCR_CSE);
-		priv->mmu_fault = true;
-	} else {
-		apb_read(t, DBGDTRTX);
-	}
-}
-
-static void cortexa_slow_mem_write_bytes(target *t, target_addr dest, const uint8_t *src, size_t len)
-{
-	struct cortexa_priv *priv = t->priv;
-
-	/* Set r13 to dest address */
-	write_gpreg(t, 13, dest);
-
-	while (len--) {
-		write_gpreg(t, 0, *src++);
-		apb_write(t, DBGITR, 0xe4cd0001); /* strb r0, [sp], #1 */
-		if (apb_read(t, DBGDSCR) & DBGDSCR_SDABORT_L) {
-			/* Memory access aborted, flag a fault */
-			apb_write(t, DBGDRCR, DBGDRCR_CSE);
-			priv->mmu_fault = true;
-			return;
-		}
-	}
-}
-
-static void cortexa_slow_mem_write(target *t, target_addr dest, const void *src, size_t len)
-{
-	struct cortexa_priv *priv = t->priv;
-	if (len == 0)
-		return;
-
-	if ((dest & 3) || (len & 3)) {
-		cortexa_slow_mem_write_bytes(t, dest, src, len);
-		return;
-	}
-
-	write_gpreg(t, 0, dest);
-	const uint32_t *src32 = src;
-
-	/* Switch to fast DCC mode */
-	uint32_t dbgdscr = apb_read(t, DBGDSCR);
-	dbgdscr = (dbgdscr & ~DBGDSCR_EXTDCCMODE_MASK) | DBGDSCR_EXTDCCMODE_FAST;
-	apb_write(t, DBGDSCR, dbgdscr);
-
-	apb_write(t, DBGITR, 0xeca05e01); /* stc 14, cr5, [r0], #4 */
-
-	for (; len; len -= 4)
-		apb_write(t, DBGDTRRX, *src32++);
-
-	/* Switch back to stalling DCC mode */
-	dbgdscr = (dbgdscr & ~DBGDSCR_EXTDCCMODE_MASK) | DBGDSCR_EXTDCCMODE_STALL;
-	apb_write(t, DBGDSCR, dbgdscr);
-
-	if (apb_read(t, DBGDSCR) & DBGDSCR_SDABORT_L) {
-		/* Memory access aborted, flag a fault */
-		apb_write(t, DBGDRCR, DBGDRCR_CSE);
-		priv->mmu_fault = true;
-	}
-}
-
-static bool cortexa_check_error(target *t)
-{
-	struct cortexa_priv *priv = t->priv;
-	bool err = priv->mmu_fault;
-	priv->mmu_fault = false;
-	return err;
-}
-
-
-bool cortexa_probe(ADIv5_AP_t *apb, uint32_t debug_base)
-{
-	target *t;
-
-	t = target_new();
-	adiv5_ap_ref(apb);
-	struct cortexa_priv *priv = calloc(1, sizeof(*priv));
-	t->priv = priv;
-	t->priv_free = free;
-	priv->apb = apb;
-	t->mem_read = cortexa_slow_mem_read;
-	t->mem_write = cortexa_slow_mem_write;
-
-	priv->base = debug_base;
-	/* Set up APB CSW, we won't touch this again */
-	uint32_t csw = apb->csw | ADIV5_AP_CSW_SIZE_WORD;
-	adiv5_ap_write(apb, ADIV5_AP_CSW, csw);
-	uint32_t dbgdidr = apb_read(t, DBGDIDR);
-	priv->hw_breakpoint_max = ((dbgdidr >> 24) & 15)+1;
-
-	t->check_error = cortexa_check_error;
-
-	t->driver = cortexa_driver_str;
-
-	t->attach = cortexa_attach;
-	t->detach = cortexa_detach;
-
-	t->tdesc = tdesc_cortex_a;
-	t->regs_read = cortexa_regs_read;
-	t->regs_write = cortexa_regs_write;
-
-	t->reset = cortexa_reset;
-	t->halt_request = cortexa_halt_request;
-	t->halt_poll = cortexa_halt_poll;
-	t->halt_resume = cortexa_halt_resume;
-	t->regs_size = sizeof(priv->reg_cache);
-
-	t->breakwatch_set = cortexa_breakwatch_set;
-	t->breakwatch_clear = cortexa_breakwatch_clear;
-
-	return true;
-}
-
-bool cortexa_attach(target *t)
-{
-	struct cortexa_priv *priv = t->priv;
-	int tries;
-
-	/* Clear any pending fault condition */
-	target_check_error(t);
-
-	/* Enable halting debug mode */
-	uint32_t dbgdscr = apb_read(t, DBGDSCR);
-	dbgdscr |= DBGDSCR_HDBGEN | DBGDSCR_ITREN;
-	dbgdscr = (dbgdscr & ~DBGDSCR_EXTDCCMODE_MASK) | DBGDSCR_EXTDCCMODE_STALL;
-	apb_write(t, DBGDSCR, dbgdscr);
-	DEBUG("DBGDSCR = 0x%08"PRIx32"\n", dbgdscr);
-
-	target_halt_request(t);
-	tries = 10;
-	while(!platform_srst_get_val() && !target_halt_poll(t, NULL) && --tries)
-		platform_delay(200);
-	if(!tries)
-		return false;
-
-	/* Clear any stale breakpoints */
-	for(unsigned i = 0; i < priv->hw_breakpoint_max; i++) {
-		apb_write(t, DBGBCR(i), 0);
-	}
-	priv->hw_breakpoint_mask = 0;
-	priv->bcr0 = 0;
-
-	platform_srst_set_val(false);
-
-	return true;
-}
-
-void cortexa_detach(target *t)
-{
-	struct cortexa_priv *priv = t->priv;
-
-	/* Clear any stale breakpoints */
-	for(unsigned i = 0; i < priv->hw_breakpoint_max; i++) {
-		apb_write(t, DBGBCR(i), 0);
-	}
-
-	/* Restore any clobbered registers */
-	cortexa_regs_write_internal(t);
-	/* Invalidate cache */
-	apb_write(t, DBGITR, MCR | ICIALLU);
-
-	platform_timeout to;
-	platform_timeout_set(&to, 200);
-
-	/* Wait for instruction to complete */
-	uint32_t dbgdscr;
-	do {
-		dbgdscr = apb_read(t, DBGDSCR);
-	} while (!(dbgdscr & DBGDSCR_INSTRCOMPL) &&
-	         !platform_timeout_is_expired(&to));
-
-	/* Disable halting debug mode */
-	dbgdscr &= ~(DBGDSCR_HDBGEN | DBGDSCR_ITREN);
-	apb_write(t, DBGDSCR, dbgdscr);
-	/* Clear sticky error and resume */
-	apb_write(t, DBGDRCR, DBGDRCR_CSE | DBGDRCR_RRQ);
-}
-
-
-static uint32_t read_gpreg(target *t, uint8_t regno)
-{
-	/* To read a register we use DBGITR to load an MCR instruction
-	 * that sends the value via DCC DBGDTRTX using the CP14 interface.
-	 */
-	uint32_t instr = MCR | DBGDTRTXint | ((regno & 0xf) << 12);
-	apb_write(t, DBGITR, instr);
-	/* Return value read from DCC channel */
-	return apb_read(t, DBGDTRTX);
-}
-
-static void write_gpreg(target *t, uint8_t regno, uint32_t val)
-{
-	/* Write value to DCC channel */
-	apb_write(t, DBGDTRRX, val);
-	/* Run instruction to load register */
-	uint32_t instr = MRC | DBGDTRRXint | ((regno & 0xf) << 12);
-	apb_write(t, DBGITR, instr);
-}
-
-static void cortexa_regs_read(target *t, void *data)
-{
-	struct cortexa_priv *priv = (struct cortexa_priv *)t->priv;
-	memcpy(data, &priv->reg_cache, t->regs_size);
-}
-
-static void cortexa_regs_write(target *t, const void *data)
-{
-	struct cortexa_priv *priv = (struct cortexa_priv *)t->priv;
-	memcpy(&priv->reg_cache, data, t->regs_size);
-}
-
-static void cortexa_regs_read_internal(target *t)
-{
-	struct cortexa_priv *priv = (struct cortexa_priv *)t->priv;
-	/* Read general purpose registers */
-	for (int i = 0; i < 15; i++) {
-		priv->reg_cache.r[i] = read_gpreg(t, i);
-	}
-	/* Read PC, via r0.  MCR is UNPREDICTABLE for Rt = r15. */
-	apb_write(t, DBGITR, 0xe1a0000f); /* mov r0, pc */
-	priv->reg_cache.r[15] = read_gpreg(t, 0);
-	/* Read CPSR */
-	apb_write(t, DBGITR, 0xE10F0000); /* mrs r0, CPSR */
-	priv->reg_cache.cpsr = read_gpreg(t, 0);
-	/* Read FPSCR */
-	apb_write(t, DBGITR, 0xeef10a10); /* vmrs r0, fpscr */
-	priv->reg_cache.fpscr = read_gpreg(t, 0);
-	/* Read out VFP registers */
-	for (int i = 0; i < 16; i++) {
-		/* Read D[i] to R0/R1 */
-		apb_write(t, DBGITR, 0xEC510B10 | i); /* vmov r0, r1, d0 */
-		priv->reg_cache.d[i] = ((uint64_t)read_gpreg(t, 1) << 32) | read_gpreg(t, 0);
-	}
-	priv->reg_cache.r[15] -= (priv->reg_cache.cpsr & CPSR_THUMB) ? 4 : 8;
-}
-
-static void cortexa_regs_write_internal(target *t)
-{
-	struct cortexa_priv *priv = (struct cortexa_priv *)t->priv;
-	/* First write back floats */
-	for (int i = 0; i < 16; i++) {
-		write_gpreg(t, 1, priv->reg_cache.d[i] >> 32);
-		write_gpreg(t, 0, priv->reg_cache.d[i]);
-		apb_write(t, DBGITR, 0xec410b10 | i); /* vmov d[i], r0, r1 */
-	}
-	/* Write back FPSCR */
-	write_gpreg(t, 0, priv->reg_cache.fpscr);
-	apb_write(t, DBGITR, 0xeee10a10); /* vmsr fpscr, r0 */
-	/* Write back the CPSR */
-	write_gpreg(t, 0, priv->reg_cache.cpsr);
-	apb_write(t, DBGITR, 0xe12ff000); /* msr CPSR_fsxc, r0 */
-	/* Write back PC, via r0.  MRC clobbers CPSR instead */
-	write_gpreg(t, 0, priv->reg_cache.r[15]);
-	apb_write(t, DBGITR, 0xe1a0f000); /* mov pc, r0 */
-	/* Finally the GP registers now that we're done using them */
-	for (int i = 0; i < 15; i++) {
-		write_gpreg(t, i, priv->reg_cache.r[i]);
-	}
-}
-
-static void cortexa_reset(target *t)
-{
-	/* This mess is Xilinx Zynq specific
-	 * See Zynq-7000 TRM, Xilinx doc UG585
-	 */
-#define ZYNQ_SLCR_UNLOCK       0xf8000008
-#define ZYNQ_SLCR_UNLOCK_KEY   0xdf0d
-#define ZYNQ_SLCR_PSS_RST_CTRL 0xf8000200
-	target_mem_write32(t, ZYNQ_SLCR_UNLOCK, ZYNQ_SLCR_UNLOCK_KEY);
-	target_mem_write32(t, ZYNQ_SLCR_PSS_RST_CTRL, 1);
-
-	/* Try hard reset too */
-	platform_srst_set_val(true);
-	platform_srst_set_val(false);
-
-	/* Spin until Xilinx reconnects us */
-	platform_timeout timeout;
-	platform_timeout_set(&timeout, 1000);
-	volatile struct exception e;
-	do {
-		TRY_CATCH (e, EXCEPTION_ALL) {
-			apb_read(t, DBGDIDR);
-		}
-	} while (!platform_timeout_is_expired(&timeout) && e.type == EXCEPTION_ERROR);
-	if (e.type == EXCEPTION_ERROR)
-		raise_exception(e.type, e.msg);
-
-	platform_delay(100);
-
-	cortexa_attach(t);
-}
-
-static void cortexa_halt_request(target *t)
-{
-	volatile struct exception e;
-	TRY_CATCH (e, EXCEPTION_TIMEOUT) {
-		apb_write(t, DBGDRCR, DBGDRCR_HRQ);
-	}
-	if (e.type) {
-		tc_printf(t, "Timeout sending interrupt, is target in WFI?\n");
-	}
-}
-
-static enum target_halt_reason cortexa_halt_poll(target *t, target_addr *watch)
-{
-	(void)watch; /* No watchpoint support yet */
-
-	volatile uint32_t dbgdscr = 0;
-	volatile struct exception e;
-	TRY_CATCH (e, EXCEPTION_ALL) {
-		/* If this times out because the target is in WFI then
-		 * the target is still running. */
-		dbgdscr = apb_read(t, DBGDSCR);
-	}
-	switch (e.type) {
-	case EXCEPTION_ERROR:
-		/* Oh crap, there's no recovery from this... */
-		target_list_free();
-		return TARGET_HALT_ERROR;
-	case EXCEPTION_TIMEOUT:
-		/* Timeout isn't a problem, target could be in WFI */
-		return TARGET_HALT_RUNNING;
-	}
-
-	if (!(dbgdscr & DBGDSCR_HALTED)) /* Not halted */
-		return TARGET_HALT_RUNNING;
-
-	DEBUG("%s: DBGDSCR = 0x%08"PRIx32"\n", __func__, dbgdscr);
-	/* Reenable DBGITR */
-	dbgdscr |= DBGDSCR_ITREN;
-	apb_write(t, DBGDSCR, dbgdscr);
-
-	/* Find out why we halted */
-	enum target_halt_reason reason;
-	switch (dbgdscr & DBGDSCR_MOE_MASK) {
-	case DBGDSCR_MOE_HALT_REQ:
-		reason = TARGET_HALT_REQUEST;
-		break;
-	default:
-		reason = TARGET_HALT_BREAKPOINT;
-	}
-
-	cortexa_regs_read_internal(t);
-
-	return reason;
-}
-
-void cortexa_halt_resume(target *t, bool step)
-{
-	struct cortexa_priv *priv = t->priv;
-	/* Set breakpoint comarator for single stepping if needed */
-	if (step) {
-		uint32_t addr = priv->reg_cache.r[15];
-		uint32_t bas = bp_bas(addr, (priv->reg_cache.cpsr & CPSR_THUMB) ? 2 : 4);
-		DEBUG("step 0x%08"PRIx32"  %"PRIx32"\n", addr, bas);
-		/* Set match any breakpoint */
-		apb_write(t, DBGBVR(0), priv->reg_cache.r[15] & ~3);
-		apb_write(t, DBGBCR(0), DBGBCR_INST_MISMATCH | bas |
-		                             DBGBCR_EN);
-	} else {
-		apb_write(t, DBGBVR(0), priv->bvr0);
-		apb_write(t, DBGBCR(0), priv->bcr0);
-	}
-
-	/* Write back register cache */
-	cortexa_regs_write_internal(t);
-
-	apb_write(t, DBGITR, MCR | ICIALLU); /* invalidate cache */
-
-	platform_timeout to;
-	platform_timeout_set(&to, 200);
-
-	/* Wait for instruction to complete */
-	uint32_t dbgdscr;
-	do {
-		dbgdscr = apb_read(t, DBGDSCR);
-	} while (!(dbgdscr & DBGDSCR_INSTRCOMPL) &&
-	         !platform_timeout_is_expired(&to));
-
-	 /* Disable DBGITR.  Not sure why, but RRQ is ignored otherwise. */
-	if (step)
-		dbgdscr |= DBGDSCR_INTDIS;
-	else
-		dbgdscr &= ~DBGDSCR_INTDIS;
-	dbgdscr &= ~DBGDSCR_ITREN;
-	apb_write(t, DBGDSCR, dbgdscr);
-
-	do {
-		apb_write(t, DBGDRCR, DBGDRCR_CSE | DBGDRCR_RRQ);
-		dbgdscr = apb_read(t, DBGDSCR);
-		DEBUG("%s: DBGDSCR = 0x%08"PRIx32"\n", __func__, dbgdscr);
-	} while (!(dbgdscr & DBGDSCR_RESTARTED) &&
-	         !platform_timeout_is_expired(&to));
-}
-
-/* Breakpoints */
-static uint32_t bp_bas(uint32_t addr, uint8_t len)
-{
-	if (len == 4)
-		return DBGBCR_BAS_ANY;
-	else if (addr & 2)
-		return DBGBCR_BAS_HIGH_HW;
-	else
-		return DBGBCR_BAS_LOW_HW;
-}
-
-static int cortexa_breakwatch_set(target *t, struct breakwatch *bw)
-{
-	struct cortexa_priv *priv = t->priv;
-	unsigned i;
-
-	switch (bw->type) {
-	case TARGET_BREAK_SOFT:
-		switch (bw->size) {
-		case 2:
-			bw->reserved[0] = target_mem_read16(t, bw->addr);
-			target_mem_write16(t, bw->addr, 0xBE00);
-			return target_check_error(t);
-		case 4:
-			bw->reserved[0] = target_mem_read32(t, bw->addr);
-			target_mem_write32(t, bw->addr, 0xE1200070);
-			return target_check_error(t);
-		default:
-			return -1;
-		}
-	case TARGET_BREAK_HARD:
-		if ((bw->size != 4) && (bw->size != 2))
-			return -1;
-
-		for (i = 0; i < priv->hw_breakpoint_max; i++)
-			if ((priv->hw_breakpoint_mask & (1 << i)) == 0)
-				break;
-
-		if (i == priv->hw_breakpoint_max)
-			return -1;
-
-		bw->reserved[0] = i;
-		priv->hw_breakpoint_mask |= (1 << i);
-
-		uint32_t addr = va_to_pa(t, bw->addr);
-		uint32_t bcr =  bp_bas(addr, bw->size) | DBGBCR_EN;
-		apb_write(t, DBGBVR(i), addr & ~3);
-		apb_write(t, DBGBCR(i), bcr);
-		if (i == 0) {
-			priv->bcr0 = bcr;
-			priv->bvr0 = addr & ~3;
-		}
-
-		return 0;
-	default:
-		return 1;
-	}
-}
-
-static int cortexa_breakwatch_clear(target *t, struct breakwatch *bw)
-{
-	struct cortexa_priv *priv = t->priv;
-	unsigned i = bw->reserved[0];
-	switch (bw->type) {
-	case TARGET_BREAK_SOFT:
-		switch (bw->size) {
-		case 2:
-			target_mem_write16(t, bw->addr, i);
-			return target_check_error(t);
-		case 4:
-			target_mem_write32(t, bw->addr, i);
-			return target_check_error(t);
-		default:
-			return -1;
-		}
-	case TARGET_BREAK_HARD:
-		priv->hw_breakpoint_mask &= ~(1 << i);
-		apb_write(t, DBGBCR(i), 0);
-		if (i == 0)
-			priv->bcr0 = 0;
-		return 0;
-	default:
-		return 1;
-	}
-}
diff --git a/src/target/cortexm.c b/src/target/cortexm.c
deleted file mode 100644
index abd64f4..0000000
--- a/src/target/cortexm.c
+++ /dev/null
@@ -1,985 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2012  Black Sphere Technologies Ltd.
- * Written by Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/* This file implements debugging functionality specific to ARM
- * the Cortex-M3 core.  This should be generic to ARMv7-M as it is
- * implemented according to the "ARMv7-M Architectue Reference Manual",
- * ARM doc DDI0403C.
- *
- * Also supports Cortex-M0 / ARMv6-M
- */
-#include "general.h"
-#include "exception.h"
-#include "adiv5.h"
-#include "target.h"
-#include "target_internal.h"
-#include "cortexm.h"
-
-#include <unistd.h>
-
-static const char cortexm_driver_str[] = "ARM Cortex-M";
-
-static bool cortexm_vector_catch(target *t, int argc, char *argv[]);
-
-const struct command_s cortexm_cmd_list[] = {
-	{"vector_catch", (cmd_handler)cortexm_vector_catch, "Catch exception vectors"},
-	{NULL, NULL, NULL}
-};
-
-/* target options recognised by the Cortex-M target */
-#define	TOPT_FLAVOUR_V6M	(1<<0)	/* if not set, target is assumed to be v7m */
-#define	TOPT_FLAVOUR_V7MF	(1<<1)	/* if set, floating-point enabled. */
-
-static void cortexm_regs_read(target *t, void *data);
-static void cortexm_regs_write(target *t, const void *data);
-static uint32_t cortexm_pc_read(target *t);
-
-static void cortexm_reset(target *t);
-static enum target_halt_reason cortexm_halt_poll(target *t, target_addr *watch);
-static void cortexm_halt_request(target *t);
-static int cortexm_fault_unwind(target *t);
-
-static int cortexm_breakwatch_set(target *t, struct breakwatch *);
-static int cortexm_breakwatch_clear(target *t, struct breakwatch *);
-static target_addr cortexm_check_watch(target *t);
-
-#define CORTEXM_MAX_WATCHPOINTS	4	/* architecture says up to 15, no implementation has > 4 */
-#define CORTEXM_MAX_BREAKPOINTS	6	/* architecture says up to 127, no implementation has > 6 */
-
-static int cortexm_hostio_request(target *t);
-
-struct cortexm_priv {
-	ADIv5_AP_t *ap;
-	bool stepping;
-	bool on_bkpt;
-	/* Watchpoint unit status */
-	bool hw_watchpoint[CORTEXM_MAX_WATCHPOINTS];
-	unsigned flash_patch_revision;
-	unsigned hw_watchpoint_max;
-	/* Breakpoint unit status */
-	bool hw_breakpoint[CORTEXM_MAX_BREAKPOINTS];
-	unsigned hw_breakpoint_max;
-	/* Copy of DEMCR for vector-catch */
-	uint32_t demcr;
-	/* Cache parameters */
-	bool has_cache;
-	uint32_t dcache_minline;
-};
-
-/* Register number tables */
-static const uint32_t regnum_cortex_m[] = {
-	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,	/* standard r0-r15 */
-	0x10,	/* xpsr */
-	0x11,	/* msp */
-	0x12,	/* psp */
-	0x14	/* special */
-};
-
-static const uint32_t regnum_cortex_mf[] = {
-	0x21,	/* fpscr */
-	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,	/* s0-s7 */
-	0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,	/* s8-s15 */
-	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,	/* s16-s23 */
-	0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,	/* s24-s31 */
-};
-
-static const char tdesc_cortex_m[] =
-	"<?xml version=\"1.0\"?>"
-	"<!DOCTYPE target SYSTEM \"gdb-target.dtd\">"
-	"<target>"
-	"  <architecture>arm</architecture>"
-	"  <feature name=\"org.gnu.gdb.arm.m-profile\">"
-	"    <reg name=\"r0\" bitsize=\"32\"/>"
-	"    <reg name=\"r1\" bitsize=\"32\"/>"
-	"    <reg name=\"r2\" bitsize=\"32\"/>"
-	"    <reg name=\"r3\" bitsize=\"32\"/>"
-	"    <reg name=\"r4\" bitsize=\"32\"/>"
-	"    <reg name=\"r5\" bitsize=\"32\"/>"
-	"    <reg name=\"r6\" bitsize=\"32\"/>"
-	"    <reg name=\"r7\" bitsize=\"32\"/>"
-	"    <reg name=\"r8\" bitsize=\"32\"/>"
-	"    <reg name=\"r9\" bitsize=\"32\"/>"
-	"    <reg name=\"r10\" bitsize=\"32\"/>"
-	"    <reg name=\"r11\" bitsize=\"32\"/>"
-	"    <reg name=\"r12\" bitsize=\"32\"/>"
-	"    <reg name=\"sp\" bitsize=\"32\" type=\"data_ptr\"/>"
-	"    <reg name=\"lr\" bitsize=\"32\" type=\"code_ptr\"/>"
-	"    <reg name=\"pc\" bitsize=\"32\" type=\"code_ptr\"/>"
-	"    <reg name=\"xpsr\" bitsize=\"32\"/>"
-	"    <reg name=\"msp\" bitsize=\"32\" save-restore=\"no\" type=\"data_ptr\"/>"
-	"    <reg name=\"psp\" bitsize=\"32\" save-restore=\"no\" type=\"data_ptr\"/>"
-	"    <reg name=\"special\" bitsize=\"32\" save-restore=\"no\"/>"
-	"  </feature>"
-	"</target>";
-
-static const char tdesc_cortex_mf[] =
-	"<?xml version=\"1.0\"?>"
-	"<!DOCTYPE target SYSTEM \"gdb-target.dtd\">"
-	"<target>"
-	"  <architecture>arm</architecture>"
-	"  <feature name=\"org.gnu.gdb.arm.m-profile\">"
-	"    <reg name=\"r0\" bitsize=\"32\"/>"
-	"    <reg name=\"r1\" bitsize=\"32\"/>"
-	"    <reg name=\"r2\" bitsize=\"32\"/>"
-	"    <reg name=\"r3\" bitsize=\"32\"/>"
-	"    <reg name=\"r4\" bitsize=\"32\"/>"
-	"    <reg name=\"r5\" bitsize=\"32\"/>"
-	"    <reg name=\"r6\" bitsize=\"32\"/>"
-	"    <reg name=\"r7\" bitsize=\"32\"/>"
-	"    <reg name=\"r8\" bitsize=\"32\"/>"
-	"    <reg name=\"r9\" bitsize=\"32\"/>"
-	"    <reg name=\"r10\" bitsize=\"32\"/>"
-	"    <reg name=\"r11\" bitsize=\"32\"/>"
-	"    <reg name=\"r12\" bitsize=\"32\"/>"
-	"    <reg name=\"sp\" bitsize=\"32\" type=\"data_ptr\"/>"
-	"    <reg name=\"lr\" bitsize=\"32\" type=\"code_ptr\"/>"
-	"    <reg name=\"pc\" bitsize=\"32\" type=\"code_ptr\"/>"
-	"    <reg name=\"xpsr\" bitsize=\"32\"/>"
-	"    <reg name=\"msp\" bitsize=\"32\" save-restore=\"no\" type=\"data_ptr\"/>"
-	"    <reg name=\"psp\" bitsize=\"32\" save-restore=\"no\" type=\"data_ptr\"/>"
-	"    <reg name=\"special\" bitsize=\"32\" save-restore=\"no\"/>"
-	"  </feature>"
-	"  <feature name=\"org.gnu.gdb.arm.vfp\">"
-	"    <reg name=\"fpscr\" bitsize=\"32\"/>"
-	"    <reg name=\"d0\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d1\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d2\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d3\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d4\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d5\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d6\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d7\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d8\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d9\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d10\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d11\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d12\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d13\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d14\" bitsize=\"64\" type=\"float\"/>"
-	"    <reg name=\"d15\" bitsize=\"64\" type=\"float\"/>"
-	"  </feature>"
-	"</target>";
-
-ADIv5_AP_t *cortexm_ap(target *t)
-{
-	return ((struct cortexm_priv *)t->priv)->ap;
-}
-
-static void cortexm_cache_clean(target *t, target_addr addr, size_t len, bool invalidate)
-{
-	struct cortexm_priv *priv = t->priv;
-	if (!priv->has_cache || (priv->dcache_minline == 0))
-		return;
-	uint32_t cache_reg = invalidate ? CORTEXM_DCCIMVAC : CORTEXM_DCCMVAC;
-	size_t minline = priv->dcache_minline;
-
-	/* flush data cache for RAM regions that intersect requested region */
-	target_addr mem_end = addr + len; /* following code is NOP if wraparound */
-	/* requested region is [src, src_end) */
-	for (struct target_ram *r = t->ram; r; r = r->next) {
-		target_addr ram = r->start;
-		target_addr ram_end = r->start + r->length;
-		/* RAM region is [ram, ram_end) */
-		if (addr > ram)
-			ram = addr;
-		if (mem_end < ram_end)
-			ram_end = mem_end;
-		/* intersection is [ram, ram_end) */
-		for (ram &= ~(minline-1); ram < ram_end; ram += minline)
-			adiv5_mem_write(cortexm_ap(t), cache_reg, &ram, 4);
-	}
-}
-
-static void cortexm_mem_read(target *t, void *dest, target_addr src, size_t len)
-{
-	cortexm_cache_clean(t, src, len, false);
-	adiv5_mem_read(cortexm_ap(t), dest, src, len);
-}
-
-static void cortexm_mem_write(target *t, target_addr dest, const void *src, size_t len)
-{
-	cortexm_cache_clean(t, dest, len, true);
-	adiv5_mem_write(cortexm_ap(t), dest, src, len);
-}
-
-static bool cortexm_check_error(target *t)
-{
-	ADIv5_AP_t *ap = cortexm_ap(t);
-	return adiv5_dp_error(ap->dp) != 0;
-}
-
-static void cortexm_priv_free(void *priv)
-{
-	adiv5_ap_unref(((struct cortexm_priv *)priv)->ap);
-	free(priv);
-}
-
-bool cortexm_probe(ADIv5_AP_t *ap)
-{
-	target *t;
-
-	t = target_new();
-	adiv5_ap_ref(ap);
-	struct cortexm_priv *priv = calloc(1, sizeof(*priv));
-	t->priv = priv;
-	t->priv_free = cortexm_priv_free;
-	priv->ap = ap;
-
-	t->check_error = cortexm_check_error;
-	t->mem_read = cortexm_mem_read;
-	t->mem_write = cortexm_mem_write;
-
-	t->driver = cortexm_driver_str;
-
-	t->attach = cortexm_attach;
-	t->detach = cortexm_detach;
-
-	/* Should probe here to make sure it's Cortex-M3 */
-	t->tdesc = tdesc_cortex_m;
-	t->regs_read = cortexm_regs_read;
-	t->regs_write = cortexm_regs_write;
-
-	t->reset = cortexm_reset;
-	t->halt_request = cortexm_halt_request;
-	t->halt_poll = cortexm_halt_poll;
-	t->halt_resume = cortexm_halt_resume;
-	t->regs_size = sizeof(regnum_cortex_m);
-
-	t->breakwatch_set = cortexm_breakwatch_set;
-	t->breakwatch_clear = cortexm_breakwatch_clear;
-
-	target_add_commands(t, cortexm_cmd_list, cortexm_driver_str);
-
-	/* Probe for FP extension */
-	uint32_t cpacr = target_mem_read32(t, CORTEXM_CPACR);
-	cpacr |= 0x00F00000; /* CP10 = 0b11, CP11 = 0b11 */
-	target_mem_write32(t, CORTEXM_CPACR, cpacr);
-	if (target_mem_read32(t, CORTEXM_CPACR) == cpacr) {
-		t->target_options |= TOPT_FLAVOUR_V7MF;
-		t->regs_size += sizeof(regnum_cortex_mf);
-		t->tdesc = tdesc_cortex_mf;
-	}
-
-	/* Default vectors to catch */
-	priv->demcr = CORTEXM_DEMCR_TRCENA | CORTEXM_DEMCR_VC_HARDERR |
-			CORTEXM_DEMCR_VC_CORERESET;
-
-	/* Check cache type */
-	uint32_t ctr = target_mem_read32(t, CORTEXM_CTR);
-	if ((ctr >> 29) == 4) {
-		priv->has_cache = true;
-		priv->dcache_minline = 4 << (ctr & 0xf);
-	} else {
-		target_check_error(t);
-	}
-
-#define PROBE(x) \
-	do { if ((x)(t)) return true; else target_check_error(t); } while (0)
-
-	PROBE(stm32f1_probe);
-	PROBE(stm32f4_probe);
-	PROBE(stm32l0_probe);   /* STM32L0xx & STM32L1xx */
-	PROBE(stm32l4_probe);
-	PROBE(lpc11xx_probe);
-	PROBE(lpc15xx_probe);
-	PROBE(lpc43xx_probe);
-	PROBE(sam3x_probe);
-	PROBE(sam4l_probe);
-	PROBE(nrf51_probe);
-	PROBE(samd_probe);
-	PROBE(lmi_probe);
-	PROBE(kinetis_probe);
-	PROBE(efm32_probe);
-#undef PROBE
-
-	return true;
-}
-
-bool cortexm_attach(target *t)
-{
-	struct cortexm_priv *priv = t->priv;
-	unsigned i;
-	uint32_t r;
-	int tries;
-
-	/* Clear any pending fault condition */
-	target_check_error(t);
-
-	target_halt_request(t);
-	tries = 10;
-	while(!platform_srst_get_val() && !target_halt_poll(t, NULL) && --tries)
-		platform_delay(200);
-	if(!tries)
-		return false;
-
-	/* Request halt on reset */
-	target_mem_write32(t, CORTEXM_DEMCR, priv->demcr);
-
-	/* Reset DFSR flags */
-	target_mem_write32(t, CORTEXM_DFSR, CORTEXM_DFSR_RESETALL);
-
-	/* size the break/watchpoint units */
-	priv->hw_breakpoint_max = CORTEXM_MAX_BREAKPOINTS;
-	r = target_mem_read32(t, CORTEXM_FPB_CTRL);
-	if (((r >> 4) & 0xf) < priv->hw_breakpoint_max)	/* only look at NUM_COMP1 */
-		priv->hw_breakpoint_max = (r >> 4) & 0xf;
-	priv->flash_patch_revision = (r >> 28);
-	priv->hw_watchpoint_max = CORTEXM_MAX_WATCHPOINTS;
-	r = target_mem_read32(t, CORTEXM_DWT_CTRL);
-	if ((r >> 28) > priv->hw_watchpoint_max)
-		priv->hw_watchpoint_max = r >> 28;
-
-	/* Clear any stale breakpoints */
-	for(i = 0; i < priv->hw_breakpoint_max; i++) {
-		target_mem_write32(t, CORTEXM_FPB_COMP(i), 0);
-		priv->hw_breakpoint[i] = 0;
-	}
-
-	/* Clear any stale watchpoints */
-	for(i = 0; i < priv->hw_watchpoint_max; i++) {
-		target_mem_write32(t, CORTEXM_DWT_FUNC(i), 0);
-		priv->hw_watchpoint[i] = 0;
-	}
-
-	/* Flash Patch Control Register: set ENABLE */
-	target_mem_write32(t, CORTEXM_FPB_CTRL,
-			CORTEXM_FPB_CTRL_KEY | CORTEXM_FPB_CTRL_ENABLE);
-
-	platform_srst_set_val(false);
-
-	return true;
-}
-
-void cortexm_detach(target *t)
-{
-	struct cortexm_priv *priv = t->priv;
-	unsigned i;
-
-	/* Clear any stale breakpoints */
-	for(i = 0; i < priv->hw_breakpoint_max; i++)
-		target_mem_write32(t, CORTEXM_FPB_COMP(i), 0);
-
-	/* Clear any stale watchpoints */
-	for(i = 0; i < priv->hw_watchpoint_max; i++)
-		target_mem_write32(t, CORTEXM_DWT_FUNC(i), 0);
-
-	/* Disable debug */
-	target_mem_write32(t, CORTEXM_DHCSR, CORTEXM_DHCSR_DBGKEY);
-}
-
-enum { DB_DHCSR, DB_DCRSR, DB_DCRDR, DB_DEMCR };
-
-static void cortexm_regs_read(target *t, void *data)
-{
-	ADIv5_AP_t *ap = cortexm_ap(t);
-	uint32_t *regs = data;
-	unsigned i;
-
-	/* FIXME: Describe what's really going on here */
-	adiv5_ap_write(ap, ADIV5_AP_CSW, ap->csw | ADIV5_AP_CSW_SIZE_WORD);
-
-	/* Map the banked data registers (0x10-0x1c) to the
-	 * debug registers DHCSR, DCRSR, DCRDR and DEMCR respectively */
-	adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_TAR, CORTEXM_DHCSR);
-
-	/* Walk the regnum_cortex_m array, reading the registers it
-	 * calls out. */
-	adiv5_ap_write(ap, ADIV5_AP_DB(DB_DCRSR), regnum_cortex_m[0]); /* Required to switch banks */
-	*regs++ = adiv5_dp_read(ap->dp, ADIV5_AP_DB(DB_DCRDR));
-	for(i = 1; i < sizeof(regnum_cortex_m) / 4; i++) {
-		adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_DB(DB_DCRSR),
-		                    regnum_cortex_m[i]);
-		*regs++ = adiv5_dp_read(ap->dp, ADIV5_AP_DB(DB_DCRDR));
-	}
-	if (t->target_options & TOPT_FLAVOUR_V7MF)
-		for(i = 0; i < sizeof(regnum_cortex_mf) / 4; i++) {
-			adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE,
-			                    ADIV5_AP_DB(DB_DCRSR),
-			                    regnum_cortex_mf[i]);
-			*regs++ = adiv5_dp_read(ap->dp, ADIV5_AP_DB(DB_DCRDR));
-		}
-}
-
-static void cortexm_regs_write(target *t, const void *data)
-{
-	ADIv5_AP_t *ap = cortexm_ap(t);
-	const uint32_t *regs = data;
-	unsigned i;
-
-	/* FIXME: Describe what's really going on here */
-	adiv5_ap_write(ap, ADIV5_AP_CSW, ap->csw | ADIV5_AP_CSW_SIZE_WORD);
-
-	/* Map the banked data registers (0x10-0x1c) to the
-	 * debug registers DHCSR, DCRSR, DCRDR and DEMCR respectively */
-	adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_TAR, CORTEXM_DHCSR);
-
-	/* Walk the regnum_cortex_m array, writing the registers it
-	 * calls out. */
-	adiv5_ap_write(ap, ADIV5_AP_DB(DB_DCRDR), *regs++); /* Required to switch banks */
-	adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_DB(DB_DCRSR),
-	                    0x10000 | regnum_cortex_m[0]);
-	for(i = 1; i < sizeof(regnum_cortex_m) / 4; i++) {
-		adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE,
-		                    ADIV5_AP_DB(DB_DCRDR), *regs++);
-		adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_DB(DB_DCRSR),
-		                    0x10000 | regnum_cortex_m[i]);
-	}
-	if (t->target_options & TOPT_FLAVOUR_V7MF)
-		for(i = 0; i < sizeof(regnum_cortex_mf) / 4; i++) {
-			adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE,
-			                    ADIV5_AP_DB(DB_DCRDR), *regs++);
-			adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE,
-			                    ADIV5_AP_DB(DB_DCRSR),
-			                    0x10000 | regnum_cortex_mf[i]);
-		}
-}
-
-static uint32_t cortexm_pc_read(target *t)
-{
-	target_mem_write32(t, CORTEXM_DCRSR, 0x0F);
-	return target_mem_read32(t, CORTEXM_DCRDR);
-}
-
-static void cortexm_pc_write(target *t, const uint32_t val)
-{
-	target_mem_write32(t, CORTEXM_DCRDR, val);
-	target_mem_write32(t, CORTEXM_DCRSR, CORTEXM_DCRSR_REGWnR | 0x0F);
-}
-
-/* The following three routines implement target halt/resume
- * using the core debug registers in the NVIC. */
-static void cortexm_reset(target *t)
-{
-	if ((t->target_options & CORTEXM_TOPT_INHIBIT_SRST) == 0) {
-		platform_srst_set_val(true);
-		platform_srst_set_val(false);
-	}
-
-	/* Read DHCSR here to clear S_RESET_ST bit before reset */
-	target_mem_read32(t, CORTEXM_DHCSR);
-
-	/* Request system reset from NVIC: SRST doesn't work correctly */
-	/* This could be VECTRESET: 0x05FA0001 (reset only core)
-	 *          or SYSRESETREQ: 0x05FA0004 (system reset)
-	 */
-	target_mem_write32(t, CORTEXM_AIRCR,
-	                   CORTEXM_AIRCR_VECTKEY | CORTEXM_AIRCR_SYSRESETREQ);
-
-	/* If target needs to do something extra (see Atmel SAM4L for example) */
-	if (t->extended_reset != NULL) {
-		t->extended_reset(t);
-	}
-
-	/* Poll for release from reset */
-	while (target_mem_read32(t, CORTEXM_DHCSR) & CORTEXM_DHCSR_S_RESET_ST);
-
-	/* Reset DFSR flags */
-	target_mem_write32(t, CORTEXM_DFSR, CORTEXM_DFSR_RESETALL);
-}
-
-static void cortexm_halt_request(target *t)
-{
-	volatile struct exception e;
-	TRY_CATCH (e, EXCEPTION_TIMEOUT) {
-		target_mem_write32(t, CORTEXM_DHCSR, CORTEXM_DHCSR_DBGKEY |
-		                                          CORTEXM_DHCSR_C_HALT |
-		                                          CORTEXM_DHCSR_C_DEBUGEN);
-	}
-	if (e.type) {
-		tc_printf(t, "Timeout sending interrupt, is target in WFI?\n");
-	}
-}
-
-static enum target_halt_reason cortexm_halt_poll(target *t, target_addr *watch)
-{
-	struct cortexm_priv *priv = t->priv;
-
-	volatile uint32_t dhcsr = 0;
-	volatile struct exception e;
-	TRY_CATCH (e, EXCEPTION_ALL) {
-		/* If this times out because the target is in WFI then
-		 * the target is still running. */
-		dhcsr = target_mem_read32(t, CORTEXM_DHCSR);
-	}
-	switch (e.type) {
-	case EXCEPTION_ERROR:
-		/* Oh crap, there's no recovery from this... */
-		target_list_free();
-		return TARGET_HALT_ERROR;
-	case EXCEPTION_TIMEOUT:
-		/* Timeout isn't a problem, target could be in WFI */
-		return TARGET_HALT_RUNNING;
-	}
-
-	if (!(dhcsr & CORTEXM_DHCSR_S_HALT))
-		return TARGET_HALT_RUNNING;
-
-	/* We've halted.  Let's find out why. */
-	uint32_t dfsr = target_mem_read32(t, CORTEXM_DFSR);
-	target_mem_write32(t, CORTEXM_DFSR, dfsr); /* write back to reset */
-
-	if ((dfsr & CORTEXM_DFSR_VCATCH) && cortexm_fault_unwind(t))
-		return TARGET_HALT_FAULT;
-
-	/* Remember if we stopped on a breakpoint */
-	priv->on_bkpt = dfsr & (CORTEXM_DFSR_BKPT);
-	if (priv->on_bkpt) {
-		/* If we've hit a programmed breakpoint, check for semihosting
-		 * call. */
-		uint32_t pc = cortexm_pc_read(t);
-		uint16_t bkpt_instr;
-		bkpt_instr = target_mem_read16(t, pc);
-		if (bkpt_instr == 0xBEAB) {
-			if (cortexm_hostio_request(t)) {
-				return TARGET_HALT_REQUEST;
-			} else {
-				target_halt_resume(t, priv->stepping);
-				return 0;
-			}
-		}
-	}
-
-	if (dfsr & CORTEXM_DFSR_DWTTRAP) {
-		if (watch != NULL)
-			*watch = cortexm_check_watch(t);
-		return TARGET_HALT_WATCHPOINT;
-	}
-	if (dfsr & CORTEXM_DFSR_BKPT)
-		return TARGET_HALT_BREAKPOINT;
-
-	if (dfsr & CORTEXM_DFSR_HALTED)
-		return priv->stepping ? TARGET_HALT_STEPPING : TARGET_HALT_REQUEST;
-
-	return TARGET_HALT_BREAKPOINT;
-}
-
-void cortexm_halt_resume(target *t, bool step)
-{
-	struct cortexm_priv *priv = t->priv;
-	uint32_t dhcsr = CORTEXM_DHCSR_DBGKEY | CORTEXM_DHCSR_C_DEBUGEN;
-
-	if (step)
-		dhcsr |= CORTEXM_DHCSR_C_STEP | CORTEXM_DHCSR_C_MASKINTS;
-
-	/* Disable interrupts while single stepping... */
-	if(step != priv->stepping) {
-		target_mem_write32(t, CORTEXM_DHCSR, dhcsr | CORTEXM_DHCSR_C_HALT);
-		priv->stepping = step;
-	}
-
-	if (priv->on_bkpt) {
-		uint32_t pc = cortexm_pc_read(t);
-		if ((target_mem_read16(t, pc) & 0xFF00) == 0xBE00)
-			cortexm_pc_write(t, pc + 2);
-	}
-
-	if (priv->has_cache)
-		target_mem_write32(t, CORTEXM_ICIALLU, 0);
-
-	target_mem_write32(t, CORTEXM_DHCSR, dhcsr);
-}
-
-static int cortexm_fault_unwind(target *t)
-{
-	uint32_t hfsr = target_mem_read32(t, CORTEXM_HFSR);
-	uint32_t cfsr = target_mem_read32(t, CORTEXM_CFSR);
-	target_mem_write32(t, CORTEXM_HFSR, hfsr);/* write back to reset */
-	target_mem_write32(t, CORTEXM_CFSR, cfsr);/* write back to reset */
-	/* We check for FORCED in the HardFault Status Register or
-	 * for a configurable fault to avoid catching core resets */
-	if((hfsr & CORTEXM_HFSR_FORCED) || cfsr) {
-		/* Unwind exception */
-		uint32_t regs[t->regs_size / 4];
-		uint32_t stack[8];
-		uint32_t retcode, framesize;
-		/* Read registers for post-exception stack pointer */
-		target_regs_read(t, regs);
-		/* save retcode currently in lr */
-		retcode = regs[REG_LR];
-		bool spsel = retcode & (1<<2);
-		bool fpca = !(retcode & (1<<4));
-		/* Read stack for pre-exception registers */
-		uint32_t sp = spsel ? regs[REG_PSP] : regs[REG_MSP];
-		target_mem_read(t, stack, sp, sizeof(stack));
-		if (target_check_error(t))
-			return 0;
-		regs[REG_LR] = stack[5];	/* restore LR to pre-exception state */
-		regs[REG_PC] = stack[6];	/* restore PC to pre-exception state */
-
-		/* adjust stack to pop exception state */
-		framesize = fpca ? 0x68 : 0x20;	/* check for basic vs. extended frame */
-		if (stack[7] & (1<<9))				/* check for stack alignment fixup */
-			framesize += 4;
-
-		if (spsel) {
-			regs[REG_SPECIAL] |= 0x4000000;
-			regs[REG_SP] = regs[REG_PSP] += framesize;
-		} else {
-			regs[REG_SP] = regs[REG_MSP] += framesize;
-		}
-
-		if (fpca)
-			regs[REG_SPECIAL] |= 0x2000000;
-
-		/* FIXME: stack[7] contains xPSR when this is supported */
-		/* although, if we caught the exception it will be unchanged */
-
-		/* Reset exception state to allow resuming from restored
-		 * state.
-		 */
-		target_mem_write32(t, CORTEXM_AIRCR,
-				CORTEXM_AIRCR_VECTKEY | CORTEXM_AIRCR_VECTCLRACTIVE);
-
-		/* Write pre-exception registers back to core */
-		target_regs_write(t, regs);
-
-		return 1;
-	}
-	return 0;
-}
-
-int cortexm_run_stub(target *t, uint32_t loadaddr,
-                     uint32_t r0, uint32_t r1, uint32_t r2, uint32_t r3)
-{
-	uint32_t regs[t->regs_size / 4];
-
-	memset(regs, 0, sizeof(regs));
-	regs[0] = r0;
-	regs[1] = r1;
-	regs[2] = r2;
-	regs[3] = r3;
-	regs[15] = loadaddr;
-	regs[16] = 0x1000000;
-	regs[19] = 0;
-
-	cortexm_regs_write(t, regs);
-
-	if (target_check_error(t))
-		return -1;
-
-	/* Execute the stub */
-	enum target_halt_reason reason;
-	cortexm_halt_resume(t, 0);
-	while ((reason = cortexm_halt_poll(t, NULL)) == TARGET_HALT_RUNNING)
-		;
-
-	if (reason == TARGET_HALT_ERROR)
-		raise_exception(EXCEPTION_ERROR, "Target lost in stub");
-
-	if (reason != TARGET_HALT_BREAKPOINT)
-		return -2;
-
-	uint32_t pc = cortexm_pc_read(t);
-	uint16_t bkpt_instr = target_mem_read16(t, pc);
-	if (bkpt_instr >> 8 != 0xbe)
-		return -2;
-
-	return bkpt_instr & 0xff;
-}
-
-/* The following routines implement hardware breakpoints and watchpoints.
- * The Flash Patch and Breakpoint (FPB) and Data Watch and Trace (DWT)
- * systems are used. */
-
-static uint32_t dwt_mask(size_t len)
-{
-	switch (len) {
-	case 1:
-		return CORTEXM_DWT_MASK_BYTE;
-	case 2:
-		return CORTEXM_DWT_MASK_HALFWORD;
-	case 4:
-		return CORTEXM_DWT_MASK_WORD;
-	default:
-		return -1;
-	}
-}
-
-static uint32_t dwt_func(target *t, enum target_breakwatch type)
-{
-	uint32_t x = 0;
-
-	if ((t->target_options & TOPT_FLAVOUR_V6M) == 0)
-		x = CORTEXM_DWT_FUNC_DATAVSIZE_WORD;
-
-	switch (type) {
-	case TARGET_WATCH_WRITE:
-		return CORTEXM_DWT_FUNC_FUNC_WRITE | x;
-	case TARGET_WATCH_READ:
-		return CORTEXM_DWT_FUNC_FUNC_READ | x;
-	case TARGET_WATCH_ACCESS:
-		return CORTEXM_DWT_FUNC_FUNC_ACCESS | x;
-	default:
-		return -1;
-	}
-}
-
-static int cortexm_breakwatch_set(target *t, struct breakwatch *bw)
-{
-	struct cortexm_priv *priv = t->priv;
-	unsigned i;
-	uint32_t val = bw->addr;
-
-	switch (bw->type) {
-	case TARGET_BREAK_HARD:
-		if (priv->flash_patch_revision == 0) {
-			val &= 0x1FFFFFFC;
-			val |= (bw->addr & 2)?0x80000000:0x40000000;
-		}
-		val |= 1;
-
-		for(i = 0; i < priv->hw_breakpoint_max; i++)
-			if (!priv->hw_breakpoint[i])
-				break;
-
-		if (i == priv->hw_breakpoint_max)
-			return -1;
-
-		priv->hw_breakpoint[i] = true;
-		target_mem_write32(t, CORTEXM_FPB_COMP(i), val);
-		bw->reserved[0] = i;
-		return 0;
-
-	case TARGET_WATCH_WRITE:
-	case TARGET_WATCH_READ:
-	case TARGET_WATCH_ACCESS:
-		for(i = 0; i < priv->hw_watchpoint_max; i++)
-			if (!priv->hw_watchpoint[i])
-				break;
-
-		if (i == priv->hw_watchpoint_max)
-			return -1;
-
-		priv->hw_watchpoint[i] = true;
-
-		target_mem_write32(t, CORTEXM_DWT_COMP(i), val);
-		target_mem_write32(t, CORTEXM_DWT_MASK(i), dwt_mask(bw->size));
-		target_mem_write32(t, CORTEXM_DWT_FUNC(i), dwt_func(t, bw->type));
-
-		bw->reserved[0] = i;
-		return 0;
-	default:
-		return 1;
-	}
-}
-
-static int cortexm_breakwatch_clear(target *t, struct breakwatch *bw)
-{
-	struct cortexm_priv *priv = t->priv;
-	unsigned i = bw->reserved[0];
-	switch (bw->type) {
-	case TARGET_BREAK_HARD:
-		priv->hw_breakpoint[i] = false;
-		target_mem_write32(t, CORTEXM_FPB_COMP(i), 0);
-		return 0;
-	case TARGET_WATCH_WRITE:
-	case TARGET_WATCH_READ:
-	case TARGET_WATCH_ACCESS:
-		priv->hw_watchpoint[i] = false;
-		target_mem_write32(t, CORTEXM_DWT_FUNC(i), 0);
-		return 0;
-	default:
-		return 1;
-	}
-}
-
-static target_addr cortexm_check_watch(target *t)
-{
-	struct cortexm_priv *priv = t->priv;
-	unsigned i;
-
-	for(i = 0; i < priv->hw_watchpoint_max; i++)
-		/* if SET and MATCHED then break */
-		if(priv->hw_watchpoint[i] &&
-		   (target_mem_read32(t, CORTEXM_DWT_FUNC(i)) &
-					CORTEXM_DWT_FUNC_MATCHED))
-			break;
-
-	if (i == priv->hw_watchpoint_max)
-		return 0;
-
-	return target_mem_read32(t, CORTEXM_DWT_COMP(i));
-}
-
-static bool cortexm_vector_catch(target *t, int argc, char *argv[])
-{
-	struct cortexm_priv *priv = t->priv;
-	const char *vectors[] = {"reset", NULL, NULL, NULL, "mm", "nocp",
-				"chk", "stat", "bus", "int", "hard"};
-	uint32_t tmp = 0;
-	unsigned i;
-
-	if ((argc < 3) || ((argv[1][0] != 'e') && (argv[1][0] != 'd'))) {
-		tc_printf(t, "usage: monitor vector_catch (enable|disable) "
-			     "(hard|int|bus|stat|chk|nocp|mm|reset)\n");
-	} else {
-		for (int j = 0; j < argc; j++)
-			for (i = 0; i < sizeof(vectors) / sizeof(char*); i++) {
-				if (vectors[i] && !strcmp(vectors[i], argv[j]))
-					tmp |= 1 << i;
-			}
-
-		if (argv[1][0] == 'e')
-			priv->demcr |= tmp;
-		else
-			priv->demcr &= ~tmp;
-
-		target_mem_write32(t, CORTEXM_DEMCR, priv->demcr);
-	}
-
-	tc_printf(t, "Catching vectors: ");
-	for (i = 0; i < sizeof(vectors) / sizeof(char*); i++) {
-		if (!vectors[i])
-			continue;
-		if (priv->demcr & (1 << i))
-			tc_printf(t, "%s ", vectors[i]);
-	}
-	tc_printf(t, "\n");
-	return true;
-}
-
-/* Windows defines this with some other meaning... */
-#ifdef SYS_OPEN
-#	undef SYS_OPEN
-#endif
-
-/* Semihosting support */
-/* ARM Semihosting syscall numbers, from ARM doc DUI0471C, Chapter 8 */
-#define SYS_CLOSE	0x02
-#define SYS_CLOCK	0x10
-#define SYS_ELAPSED	0x30
-#define SYS_ERRNO	0x13
-#define SYS_FLEN	0x0C
-#define SYS_GET_CMDLINE	0x15
-#define SYS_HEAPINFO	0x16
-#define SYS_ISERROR	0x08
-#define SYS_ISTTY	0x09
-#define SYS_OPEN	0x01
-#define SYS_READ	0x06
-#define SYS_READC	0x07
-#define SYS_REMOVE	0x0E
-#define SYS_RENAME	0x0F
-#define SYS_SEEK	0x0A
-#define SYS_SYSTEM	0x12
-#define SYS_TICKFREQ	0x31
-#define SYS_TIME	0x11
-#define SYS_TMPNAM	0x0D
-#define SYS_WRITE	0x05
-#define SYS_WRITEC	0x03
-#define SYS_WRITE0	0x04
-
-static int cortexm_hostio_request(target *t)
-{
-	uint32_t arm_regs[t->regs_size];
-	uint32_t params[4];
-
-	t->tc->interrupted = false;
-	target_regs_read(t, arm_regs);
-	target_mem_read(t, params, arm_regs[1], sizeof(params));
-	uint32_t syscall = arm_regs[0];
-	int32_t ret = 0;
-
-	DEBUG("syscall 0"PRIx32"%"PRIx32" (%"PRIx32" %"PRIx32" %"PRIx32" %"PRIx32")\n",
-              syscall, params[0], params[1], params[2], params[3]);
-	switch (syscall) {
-	case SYS_OPEN:{	/* open */
-		/* Translate stupid fopen modes to open flags.
-		 * See DUI0471C, Table 8-3 */
-		const uint32_t flags[] = {
-			TARGET_O_RDONLY,	/* r, rb */
-			TARGET_O_RDWR,		/* r+, r+b */
-			TARGET_O_WRONLY | TARGET_O_CREAT | TARGET_O_TRUNC,/*w*/
-			TARGET_O_RDWR | TARGET_O_CREAT | TARGET_O_TRUNC,/*w+*/
-			TARGET_O_WRONLY | TARGET_O_CREAT | TARGET_O_APPEND,/*a*/
-			TARGET_O_RDWR | TARGET_O_CREAT | TARGET_O_APPEND,/*a+*/
-		};
-		uint32_t pflag = flags[params[1] >> 1];
-		char filename[4];
-
-		target_mem_read(t, filename, params[0], sizeof(filename));
-		/* handle requests for console i/o */
-		if (!strcmp(filename, ":tt")) {
-			if (pflag == TARGET_O_RDONLY)
-				ret = STDIN_FILENO;
-			else if (pflag & TARGET_O_TRUNC)
-				ret = STDOUT_FILENO;
-			else
-				ret = STDERR_FILENO;
-			ret++;
-			break;
-		}
-
-		ret = tc_open(t, params[0], params[2] + 1, pflag, 0644);
-		if (ret != -1)
-			ret++;
-		break;
-		}
-	case SYS_CLOSE:	/* close */
-		ret = tc_close(t, params[0] - 1);
-		break;
-	case SYS_READ:	/* read */
-		ret = tc_read(t, params[0] - 1, params[1], params[2]);
-		if (ret > 0)
-			ret = params[2] - ret;
-		break;
-	case SYS_WRITE:	/* write */
-		ret = tc_write(t, params[0] - 1, params[1], params[2]);
-		if (ret > 0)
-			ret = params[2] - ret;
-		break;
-	case SYS_WRITEC: /* writec */
-		ret = tc_write(t, 2, arm_regs[1], 1);
-		break;
-	case SYS_ISTTY:	/* isatty */
-		ret = tc_isatty(t, params[0] - 1);
-		break;
-	case SYS_SEEK:	/* lseek */
-		ret = tc_lseek(t, params[0] - 1, params[1], TARGET_SEEK_SET);
-		break;
-	case SYS_RENAME:/* rename */
-		ret = tc_rename(t, params[0] - 1, params[1] + 1,
-				params[2], params[3] + 1);
-		break;
-	case SYS_REMOVE:/* unlink */
-		ret = tc_unlink(t, params[0] - 1, params[1] + 1);
-		break;
-	case SYS_SYSTEM:/* system */
-		ret = tc_system(t, params[0] - 1, params[1] + 1);
-		break;
-
-	case SYS_FLEN:	/* Not supported, fake success */
-		t->tc->errno_ = 0;
-		break;
-
-	case SYS_ERRNO: /* Return last errno from GDB */
-		ret = t->tc->errno_;
-		break;
-
-	case SYS_TIME:	/* gettimeofday */
-		/* FIXME How do we use gdb's gettimeofday? */
-		break;
-	}
-
-	arm_regs[0] = ret;
-	target_regs_write(t, arm_regs);
-
-	return t->tc->interrupted;
-}
-
diff --git a/src/target/cortexm.h b/src/target/cortexm.h
deleted file mode 100644
index e9bf547..0000000
--- a/src/target/cortexm.h
+++ /dev/null
@@ -1,180 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2015 Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-#ifndef __CORTEXM_H
-#define __CORTEXM_H
-
-#include "target.h"
-#include "adiv5.h"
-
-/* Private peripheral bus base address */
-#define CORTEXM_PPB_BASE	0xE0000000
-
-#define CORTEXM_SCS_BASE	(CORTEXM_PPB_BASE + 0xE000)
-
-#define CORTEXM_AIRCR		(CORTEXM_SCS_BASE + 0xD0C)
-#define CORTEXM_CFSR		(CORTEXM_SCS_BASE + 0xD28)
-#define CORTEXM_HFSR		(CORTEXM_SCS_BASE + 0xD2C)
-#define CORTEXM_DFSR		(CORTEXM_SCS_BASE + 0xD30)
-#define CORTEXM_CPACR		(CORTEXM_SCS_BASE + 0xD88)
-#define CORTEXM_DHCSR		(CORTEXM_SCS_BASE + 0xDF0)
-#define CORTEXM_DCRSR		(CORTEXM_SCS_BASE + 0xDF4)
-#define CORTEXM_DCRDR		(CORTEXM_SCS_BASE + 0xDF8)
-#define CORTEXM_DEMCR		(CORTEXM_SCS_BASE + 0xDFC)
-
-/* Cache identification */
-#define CORTEXM_CLIDR		(CORTEXM_SCS_BASE + 0xD78)
-#define CORTEXM_CTR		(CORTEXM_SCS_BASE + 0xD7C)
-#define CORTEXM_CCSIDR		(CORTEXM_SCS_BASE + 0xD80)
-#define CORTEXM_CSSELR		(CORTEXM_SCS_BASE + 0xD84)
-
-/* Cache maintenance operations */
-#define CORTEXM_ICIALLU		(CORTEXM_SCS_BASE + 0xF50)
-#define CORTEXM_DCCMVAC		(CORTEXM_SCS_BASE + 0xF68)
-#define CORTEXM_DCCIMVAC	(CORTEXM_SCS_BASE + 0xF70)
-
-#define CORTEXM_FPB_BASE	(CORTEXM_PPB_BASE + 0x2000)
-
-/* ARM Literature uses FP_*, we use CORTEXM_FPB_* consistently */
-#define CORTEXM_FPB_CTRL	(CORTEXM_FPB_BASE + 0x000)
-#define CORTEXM_FPB_REMAP	(CORTEXM_FPB_BASE + 0x004)
-#define CORTEXM_FPB_COMP(i)	(CORTEXM_FPB_BASE + 0x008 + (4*(i)))
-
-#define CORTEXM_DWT_BASE	(CORTEXM_PPB_BASE + 0x1000)
-
-#define CORTEXM_DWT_CTRL	(CORTEXM_DWT_BASE + 0x000)
-#define CORTEXM_DWT_COMP(i)	(CORTEXM_DWT_BASE + 0x020 + (0x10*(i)))
-#define CORTEXM_DWT_MASK(i)	(CORTEXM_DWT_BASE + 0x024 + (0x10*(i)))
-#define CORTEXM_DWT_FUNC(i)	(CORTEXM_DWT_BASE + 0x028 + (0x10*(i)))
-
-/* Application Interrupt and Reset Control Register (AIRCR) */
-#define CORTEXM_AIRCR_VECTKEY		(0x05FA << 16)
-/* Bits 31:16 - Read as VECTKETSTAT, 0xFA05 */
-#define CORTEXM_AIRCR_ENDIANESS		(1 << 15)
-/* Bits 15:11 - Unused, reserved */
-#define CORTEXM_AIRCR_PRIGROUP		(7 << 8)
-/* Bits 7:3 - Unused, reserved */
-#define CORTEXM_AIRCR_SYSRESETREQ	(1 << 2)
-#define CORTEXM_AIRCR_VECTCLRACTIVE	(1 << 1)
-#define CORTEXM_AIRCR_VECTRESET		(1 << 0)
-
-/* HardFault Status Register (HFSR) */
-#define CORTEXM_HFSR_DEBUGEVT		(1 << 31)
-#define CORTEXM_HFSR_FORCED		(1 << 30)
-/* Bits 29:2 - Not specified */
-#define CORTEXM_HFSR_VECTTBL		(1 << 1)
-/* Bits 0 - Reserved */
-
-/* Debug Fault Status Register (DFSR) */
-/* Bits 31:5 - Reserved */
-#define CORTEXM_DFSR_RESETALL		0x1F
-#define CORTEXM_DFSR_EXTERNAL		(1 << 4)
-#define CORTEXM_DFSR_VCATCH		(1 << 3)
-#define CORTEXM_DFSR_DWTTRAP		(1 << 2)
-#define CORTEXM_DFSR_BKPT		(1 << 1)
-#define CORTEXM_DFSR_HALTED		(1 << 0)
-
-/* Debug Halting Control and Status Register (DHCSR) */
-/* This key must be written to bits 31:16 for write to take effect */
-#define CORTEXM_DHCSR_DBGKEY		0xA05F0000
-/* Bits 31:26 - Reserved */
-#define CORTEXM_DHCSR_S_RESET_ST	(1 << 25)
-#define CORTEXM_DHCSR_S_RETIRE_ST	(1 << 24)
-/* Bits 23:20 - Reserved */
-#define CORTEXM_DHCSR_S_LOCKUP		(1 << 19)
-#define CORTEXM_DHCSR_S_SLEEP		(1 << 18)
-#define CORTEXM_DHCSR_S_HALT		(1 << 17)
-#define CORTEXM_DHCSR_S_REGRDY		(1 << 16)
-/* Bits 15:6 - Reserved */
-#define CORTEXM_DHCSR_C_SNAPSTALL	(1 << 5)	/* v7m only */
-/* Bit 4 - Reserved */
-#define CORTEXM_DHCSR_C_MASKINTS	(1 << 3)
-#define CORTEXM_DHCSR_C_STEP		(1 << 2)
-#define CORTEXM_DHCSR_C_HALT		(1 << 1)
-#define CORTEXM_DHCSR_C_DEBUGEN		(1 << 0)
-
-/* Debug Core Register Selector Register (DCRSR) */
-#define CORTEXM_DCRSR_REGWnR		0x00010000
-#define CORTEXM_DCRSR_REGSEL_MASK	0x0000001F
-#define CORTEXM_DCRSR_REGSEL_XPSR	0x00000010
-#define CORTEXM_DCRSR_REGSEL_MSP	0x00000011
-#define CORTEXM_DCRSR_REGSEL_PSP	0x00000012
-
-/* Debug Exception and Monitor Control Register (DEMCR) */
-/* Bits 31:25 - Reserved */
-#define CORTEXM_DEMCR_TRCENA		(1 << 24)
-/* Bits 23:20 - Reserved */
-#define CORTEXM_DEMCR_MON_REQ		(1 << 19)	/* v7m only */
-#define CORTEXM_DEMCR_MON_STEP		(1 << 18)	/* v7m only */
-#define CORTEXM_DEMCR_VC_MON_PEND	(1 << 17)	/* v7m only */
-#define CORTEXM_DEMCR_VC_MON_EN		(1 << 16)	/* v7m only */
-/* Bits 15:11 - Reserved */
-#define CORTEXM_DEMCR_VC_HARDERR	(1 << 10)
-#define CORTEXM_DEMCR_VC_INTERR		(1 << 9)	/* v7m only */
-#define CORTEXM_DEMCR_VC_BUSERR		(1 << 8)	/* v7m only */
-#define CORTEXM_DEMCR_VC_STATERR	(1 << 7)	/* v7m only */
-#define CORTEXM_DEMCR_VC_CHKERR		(1 << 6)	/* v7m only */
-#define CORTEXM_DEMCR_VC_NOCPERR	(1 << 5)	/* v7m only */
-#define CORTEXM_DEMCR_VC_MMERR		(1 << 4)	/* v7m only */
-/* Bits 3:1 - Reserved */
-#define CORTEXM_DEMCR_VC_CORERESET	(1 << 0)
-
-/* Flash Patch and Breakpoint Control Register (FP_CTRL) */
-/* Bits 32:15 - Reserved */
-/* Bits 14:12 - NUM_CODE2 */	/* v7m only */
-/* Bits 11:8 - NUM_LIT */	/* v7m only */
-/* Bits 7:4 - NUM_CODE1 */
-/* Bits 3:2 - Unspecified */
-#define CORTEXM_FPB_CTRL_KEY		(1 << 1)
-#define CORTEXM_FPB_CTRL_ENABLE		(1 << 0)
-
-/* Data Watchpoint and Trace Mask Register (DWT_MASKx) */
-#define CORTEXM_DWT_MASK_BYTE		(0 << 0)
-#define CORTEXM_DWT_MASK_HALFWORD	(1 << 0)
-#define CORTEXM_DWT_MASK_WORD		(3 << 0)
-
-/* Data Watchpoint and Trace Function Register (DWT_FUNCTIONx) */
-#define CORTEXM_DWT_FUNC_MATCHED	(1 << 24)
-#define CORTEXM_DWT_FUNC_DATAVSIZE_WORD	(2 << 10)	/* v7m only */
-#define CORTEXM_DWT_FUNC_FUNC_READ	(5 << 0)
-#define CORTEXM_DWT_FUNC_FUNC_WRITE	(6 << 0)
-#define CORTEXM_DWT_FUNC_FUNC_ACCESS	(7 << 0)
-
-#define REG_SP		13
-#define REG_LR		14
-#define REG_PC		15
-#define REG_XPSR	16
-#define REG_MSP		17
-#define REG_PSP		18
-#define REG_SPECIAL	19
-
-#define ARM_THUMB_BREAKPOINT 0xBE00
-
-#define	CORTEXM_TOPT_INHIBIT_SRST (1 << 2)
-
-bool cortexm_probe(ADIv5_AP_t *ap);
-ADIv5_AP_t *cortexm_ap(target *t);
-
-bool cortexm_attach(target *t);
-void cortexm_detach(target *t);
-void cortexm_halt_resume(target *t, bool step);
-int cortexm_run_stub(target *t, uint32_t loadaddr,
-                     uint32_t r0, uint32_t r1, uint32_t r2, uint32_t r3);
-
-#endif
-
diff --git a/src/target/efm32.c b/src/target/efm32.c
deleted file mode 100644
index 97dc2eb..0000000
--- a/src/target/efm32.c
+++ /dev/null
@@ -1,441 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2015  Richard Meadows <richardeoin>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/* This file implements EFM32 target specific functions for
- * detecting the device, providing the XML memory map and Flash memory
- * programming.
- *
- * Both EFM32 (microcontroller only) and EZR32 (microcontroller+radio)
- * devices should be supported through this driver.
- *
- * Tested with:
- * * EZR32LG230 (EZR Leopard Gecko M3)
- * *
- */
-
-/* Refer to the family reference manuals:
- *
- *
- * Also refer to AN0062 "Programming Internal Flash Over the Serial Wire Debug Interface"
- * http://www.silabs.com/Support%20Documents/TechnicalDocs/an0062.pdf
- */
-
-#include "general.h"
-#include "target.h"
-#include "target_internal.h"
-#include "cortexm.h"
-
-#define SRAM_BASE		0x20000000
-#define STUB_BUFFER_BASE	ALIGN(SRAM_BASE + sizeof(efm32_flash_write_stub), 4)
-
-static int efm32_flash_erase(struct target_flash *t, target_addr addr, size_t len);
-static int efm32_flash_write(struct target_flash *f,
-			     target_addr dest, const void *src, size_t len);
-
-static const uint16_t efm32_flash_write_stub[] = {
-#include "flashstub/efm32.stub"
-};
-
-static bool efm32_cmd_erase_all(target *t);
-static bool efm32_cmd_serial(target *t);
-
-const struct command_s efm32_cmd_list[] = {
-	{"erase_mass", (cmd_handler)efm32_cmd_erase_all, "Erase entire flash memory"},
-	{"serial", (cmd_handler)efm32_cmd_serial, "Prints unique number"},
-	{NULL, NULL, NULL}
-};
-
-
-
-/* -------------------------------------------------------------------------- */
-/* Memory System Controller (MSC) Registers */
-/* -------------------------------------------------------------------------- */
-
-#define EFM32_MSC	       		0x400c0000
-#define EFM32_MSC_WRITECTRL	     	(EFM32_MSC+0x008)
-#define EFM32_MSC_WRITECMD	      	(EFM32_MSC+0x00c)
-#define EFM32_MSC_ADDRB		 	(EFM32_MSC+0x010)
-#define EFM32_MSC_WDATA		 	(EFM32_MSC+0x018)
-#define EFM32_MSC_STATUS		(EFM32_MSC+0x01c)
-#define EFM32_MSC_LOCK		  	(EFM32_MSC+0x03c)
-#define EFM32_MSC_CMD		   	(EFM32_MSC+0x040)
-#define EFM32_MSC_TIMEBASE	      	(EFM32_MSC+0x050)
-#define EFM32_MSC_MASSLOCK	      	(EFM32_MSC+0x054)
-
-#define EFM32_MSC_LOCK_LOCKKEY	  	0x1b71
-#define EFM32_MSC_MASSLOCK_LOCKKEY	0x631a
-
-#define EFM32_MSC_WRITECMD_LADDRIM	(1<<0)
-#define EFM32_MSC_WRITECMD_ERASEPAGE	(1<<1)
-#define EFM32_MSC_WRITECMD_WRITEEND	(1<<2)
-#define EFM32_MSC_WRITECMD_WRITEONCE	(1<<3)
-#define EFM32_MSC_WRITECMD_WRITETRIG	(1<<4)
-#define EFM32_MSC_WRITECMD_ERASEABORT	(1<<5)
-#define EFM32_MSC_WRITECMD_ERASEMAIN0	(1<<8)
-
-#define EFM32_MSC_STATUS_BUSY		(1<<0)
-#define EFM32_MSC_STATUS_LOCKED		(1<<1)
-#define EFM32_MSC_STATUS_INVADDR	(1<<2)
-#define EFM32_MSC_STATUS_WDATAREADY	(1<<3)
-
-
-/* -------------------------------------------------------------------------- */
-/* Flash Infomation Area */
-/* -------------------------------------------------------------------------- */
-
-#define EFM32_INFO			0x0fe00000
-#define EFM32_USER_DATA			(EFM32_INFO+0x0000)
-#define EFM32_LOCK_BITS			(EFM32_INFO+0x4000)
-#define EFM32_DI			(EFM32_INFO+0x8000)
-
-
-/* -------------------------------------------------------------------------- */
-/* Device Information (DI) Area */
-/* -------------------------------------------------------------------------- */
-
-#define EFM32_DI_CMU_LFRCOCTRL 		(EFM32_DI+0x020)
-#define EFM32_DI_CMU_HFRCOCTRL 		(EFM32_DI+0x028)
-#define EFM32_DI_CMU_AUXHFRCOCTRL 	(EFM32_DI+0x030)
-#define EFM32_DI_ADC0_CAL 		(EFM32_DI+0x040)
-#define EFM32_DI_ADC0_BIASPROG 		(EFM32_DI+0x048)
-#define EFM32_DI_DAC0_CAL 		(EFM32_DI+0x050)
-#define EFM32_DI_DAC0_BIASPROG 		(EFM32_DI+0x058)
-#define EFM32_DI_ACMP0_CTRL 		(EFM32_DI+0x060)
-#define EFM32_DI_ACMP1_CTRL 		(EFM32_DI+0x068)
-#define EFM32_DI_CMU_LCDCTRL 		(EFM32_DI+0x078)
-#define EFM32_DI_DAC0_OPACTRL 		(EFM32_DI+0x0A0)
-#define EFM32_DI_DAC0_OPAOFFSET 	(EFM32_DI+0x0A8)
-#define EFM32_DI_EMU_BUINACT 		(EFM32_DI+0x0B0)
-#define EFM32_DI_EMU_BUACT 		(EFM32_DI+0x0B8)
-#define EFM32_DI_EMU_BUBODBUVINCAL 	(EFM32_DI+0x0C0)
-#define EFM32_DI_EMU_BUBODUNREGCAL 	(EFM32_DI+0x0C8)
-#define EFM32_DI_MCM_REV_MIN 		(EFM32_DI+0x1AA)
-#define EFM32_DI_MCM_REV_MAJ 		(EFM32_DI+0x1AB)
-#define EFM32_DI_RADIO_REV_MIN 		(EFM32_DI+0x1AC)
-#define EFM32_DI_RADIO_REV_MAJ 		(EFM32_DI+0x1AD)
-#define EFM32_DI_RADIO_OPN 		(EFM32_DI+0x1AE)
-#define EFM32_DI_DI_CRC 		(EFM32_DI+0x1B0)
-#define EFM32_DI_CAL_TEMP_0 		(EFM32_DI+0x1B2)
-#define EFM32_DI_ADC0_CAL_1V25 		(EFM32_DI+0x1B4)
-#define EFM32_DI_ADC0_CAL_2V5 		(EFM32_DI+0x1B6)
-#define EFM32_DI_ADC0_CAL_VDD 		(EFM32_DI+0x1B8)
-#define EFM32_DI_ADC0_CAL_5VDIFF 	(EFM32_DI+0x1BA)
-#define EFM32_DI_ADC0_CAL_2XVDD 	(EFM32_DI+0x1BC)
-#define EFM32_DI_ADC0_TEMP_0_READ_1V25	(EFM32_DI+0x1BE)
-#define EFM32_DI_DAC0_CAL_1V25 		(EFM32_DI+0x1C8)
-#define EFM32_DI_DAC0_CAL_2V5 		(EFM32_DI+0x1CC)
-#define EFM32_DI_DAC0_CAL_VDD 		(EFM32_DI+0x1D0)
-#define EFM32_DI_AUXHFRCO_CALIB_BAND_1 	(EFM32_DI+0x1D4)
-#define EFM32_DI_AUXHFRCO_CALIB_BAND_7 	(EFM32_DI+0x1D5)
-#define EFM32_DI_AUXHFRCO_CALIB_BAND_11 (EFM32_DI+0x1D6)
-#define EFM32_DI_AUXHFRCO_CALIB_BAND_14 (EFM32_DI+0x1D7)
-#define EFM32_DI_AUXHFRCO_CALIB_BAND_21 (EFM32_DI+0x1D8)
-#define EFM32_DI_AUXHFRCO_CALIB_BAND_28 (EFM32_DI+0x1D9)
-#define EFM32_DI_HFRCO_CALIB_BAND_1 	(EFM32_DI+0x1DC)
-#define EFM32_DI_HFRCO_CALIB_BAND_7 	(EFM32_DI+0x1DD)
-#define EFM32_DI_HFRCO_CALIB_BAND_11 	(EFM32_DI+0x1DE)
-#define EFM32_DI_HFRCO_CALIB_BAND_14 	(EFM32_DI+0x1DF)
-#define EFM32_DI_HFRCO_CALIB_BAND_21 	(EFM32_DI+0x1E0)
-#define EFM32_DI_HFRCO_CALIB_BAND_28 	(EFM32_DI+0x1E1)
-#define EFM32_DI_MEM_INFO_PAGE_SIZE 	(EFM32_DI+0x1E7)
-#define EFM32_DI_RADIO_ID 		(EFM32_DI+0x1EE)
-#define EFM32_DI_EUI64_0 		(EFM32_DI+0x1F0)
-#define EFM32_DI_EUI64_1 		(EFM32_DI+0x1F4)
-#define EFM32_DI_MEM_INFO_FLASH 	(EFM32_DI+0x1F8)
-#define EFM32_DI_MEM_INFO_RAM 		(EFM32_DI+0x1FA)
-#define EFM32_DI_PART_NUMBER 		(EFM32_DI+0x1FC)
-#define EFM32_DI_PART_FAMILY 		(EFM32_DI+0x1FE)
-#define EFM32_DI_PROD_REV 		(EFM32_DI+0x1FF)
-
-/* top 24 bits of eui */
-#define EFM32_DI_EUI_SILABS	0x000b57
-
-#define EFM32_DI_PART_FAMILY_GECKO		71
-#define EFM32_DI_PART_FAMILY_GIANT_GECKO	72
-#define EFM32_DI_PART_FAMILY_TINY_GECKO		73
-#define EFM32_DI_PART_FAMILY_LEOPARD_GECKO	74
-#define EFM32_DI_PART_FAMILY_WONDER_GECKO	75
-#define EFM32_DI_PART_FAMILY_ZERO_GECKO		76
-#define EFM32_DI_PART_FAMILY_HAPPY_GECKO	77
-#define EFM32_DI_PART_FAMILY_EZR_WONDER_GECKO	120
-#define EFM32_DI_PART_FAMILY_EZR_LEOPARD_GECKO	121
-
-/* -------------------------------------------------------------------------- */
-/* Helper functions */
-/* -------------------------------------------------------------------------- */
-
-/**
- * Reads the EFM32 Extended Unique Identifier
- */
-	uint64_t efm32_read_eui(target *t)
-	{
-		uint64_t eui;
-
-		eui  = (uint64_t)target_mem_read32(t, EFM32_DI_EUI64_1) << 32;
-		eui |= (uint64_t)target_mem_read32(t, EFM32_DI_EUI64_0) <<  0;
-
-		return eui;
-	}
-/**
- * Reads the EFM32 flash size in kiB
- */
-uint16_t efm32_read_flash_size(target *t)
-{
-	return target_mem_read16(t, EFM32_DI_MEM_INFO_FLASH);
-}
-/**
- * Reads the EFM32 RAM size in kiB
- */
-uint16_t efm32_read_ram_size(target *t)
-{
-	return target_mem_read16(t, EFM32_DI_MEM_INFO_RAM);
-}
-/**
- * Reads the EFM32 Part Number
- */
-uint16_t efm32_read_part_number(target *t)
-{
-	return target_mem_read16(t, EFM32_DI_PART_NUMBER);
-}
-/**
- * Reads the EFM32 Part Family
- */
-uint8_t efm32_read_part_family(target *t)
-{
-	return target_mem_read8(t, EFM32_DI_PART_FAMILY);
-}
-/**
- * Reads the EFM32 Radio part number (EZR parts only)
- */
-uint16_t efm32_read_radio_part_number(target *t)
-{
-	return target_mem_read16(t, EFM32_DI_RADIO_OPN);
-}
-
-
-
-
-static void efm32_add_flash(target *t, target_addr addr, size_t length,
-			    size_t page_size)
-{
-	struct target_flash *f = calloc(1, sizeof(*f));
-	f->start = addr;
-	f->length = length;
-	f->blocksize = page_size;
-	f->erase = efm32_flash_erase;
-	f->write = target_flash_write_buffered;
-	f->done = target_flash_done_buffered;
-	f->write_buf = efm32_flash_write;
-	f->buf_size = page_size;
-	target_add_flash(t, f);
-}
-
-char variant_string[40];
-bool efm32_probe(target *t)
-{
-	/* Read the IDCODE register from the SW-DP */
-	ADIv5_AP_t *ap = cortexm_ap(t);
-	uint32_t ap_idcode = ap->dp->idcode;
-
-	/* Check the idcode is silabs. See AN0062 Section 2.2 */
-	if (ap_idcode == 0x2BA01477) {
-		/* Cortex M3, Cortex M4 */
-	} else if (ap_idcode == 0x0BC11477) {
-		/* Cortex M0+ */
-	} else {
-		return false;
-	}
-
-	/* Read the part number and family */
-	uint16_t part_number = efm32_read_part_number(t);
-	uint8_t part_family = efm32_read_part_family(t);
-	uint16_t radio_number, radio_number_short;  /* optional, for ezr parts */
-	uint32_t flash_page_size; uint16_t flash_kb;
-
-	switch(part_family) {
-		case EFM32_DI_PART_FAMILY_GECKO:
-			sprintf(variant_string,
-				"EFM32 Gecko");
-			flash_page_size = 512;
-			break;
-		case EFM32_DI_PART_FAMILY_GIANT_GECKO:
-			sprintf(variant_string,
-				"EFM32 Giant Gecko");
-			flash_page_size = 2048; /* Could be 2048 or 4096, assume 2048 */
-			break;
-		case EFM32_DI_PART_FAMILY_TINY_GECKO:
-			sprintf(variant_string,
-				"EFM32 Tiny Gecko");
-			flash_page_size = 512;
-			break;
-		case EFM32_DI_PART_FAMILY_LEOPARD_GECKO:
-			sprintf(variant_string,
-				"EFM32 Leopard Gecko");
-			flash_page_size = 2048; /* Could be 2048 or 4096, assume 2048 */
-			break;
-		case EFM32_DI_PART_FAMILY_WONDER_GECKO:
-			sprintf(variant_string,
-				"EFM32 Wonder Gecko");
-			flash_page_size = 2048;
-			break;
-		case EFM32_DI_PART_FAMILY_ZERO_GECKO:
-			sprintf(variant_string,
-				"EFM32 Zero Gecko");
-			flash_page_size = 1024;
-			break;
-		case EFM32_DI_PART_FAMILY_HAPPY_GECKO:
-			sprintf(variant_string,
-				"EFM32 Happy Gecko");
-			flash_page_size = 1024;
-			break;
-		case EFM32_DI_PART_FAMILY_EZR_WONDER_GECKO:
-			radio_number = efm32_read_radio_part_number(t); /* on-chip radio */
-			radio_number_short = radio_number % 100;
-			flash_kb = efm32_read_flash_size(t);
-
-			sprintf(variant_string,
-				"EZR32WG%dF%dR%d (radio si%d)",
-				part_number, flash_kb,
-				radio_number_short, radio_number);
-
-			flash_page_size = 2048;
-			break;
-		case EFM32_DI_PART_FAMILY_EZR_LEOPARD_GECKO:
-			radio_number = efm32_read_radio_part_number(t); /* on-chip radio */
-			radio_number_short = radio_number % 100;
-			flash_kb = efm32_read_flash_size(t);
-
-			sprintf(variant_string,
-				"EZR32LG%dF%dR%d (radio si%d)",
-				part_number, flash_kb,
-				radio_number_short, radio_number);
-
-			flash_page_size = 2048;
-			break;
-		default:	/* Unknown family */
-			return false;
-	}
-
-	/* Read memory sizes, convert to bytes */
-	uint32_t flash_size = efm32_read_flash_size(t) * 0x400;
-	uint32_t ram_size   = efm32_read_ram_size(t)   * 0x400;
-
-	/* Setup Target */
-	t->target_options |= CORTEXM_TOPT_INHIBIT_SRST;
-	t->driver = variant_string;
-	tc_printf(t, "flash size %d page size %d\n", flash_size, flash_page_size);
-	target_add_ram (t, SRAM_BASE, ram_size);
-	efm32_add_flash(t, 0x00000000, flash_size, flash_page_size);
-	target_add_commands(t, efm32_cmd_list, "EFM32");
-
-	return true;
-}
-
-/**
- * Erase flash row by row
- */
-static int efm32_flash_erase(struct target_flash *f, target_addr addr, size_t len)
-{
-	target *t = f->t;
-
-	/* Set WREN bit to enabel MSC write and erase functionality */
-	target_mem_write32(t, EFM32_MSC_WRITECTRL, 1);
-
-	while (len) {
-		/* Write address of first word in row to erase it */
-		target_mem_write32(t, EFM32_MSC_ADDRB, addr);
-		target_mem_write32(t, EFM32_MSC_WRITECMD, EFM32_MSC_WRITECMD_LADDRIM);
-
-		/* Issue the erase command */
-		target_mem_write32(t, EFM32_MSC_WRITECMD, EFM32_MSC_WRITECMD_ERASEPAGE );
-
-		/* Poll MSC Busy */
-		while ((target_mem_read32(t, EFM32_MSC_STATUS) & EFM32_MSC_STATUS_BUSY)) {
-			if (target_check_error(t))
-				return -1;
-		}
-
-		addr += f->blocksize;
-		len -= f->blocksize;
-	}
-
-	return 0;
-}
-
-/**
- * Write flash page by page
- */
-static int efm32_flash_write(struct target_flash *f,
-			     target_addr dest, const void *src, size_t len)
-{
-	(void)len;
-	target *t = f->t;
-
-	/* Write flashloader */
-	target_mem_write(t, SRAM_BASE, efm32_flash_write_stub,
-			 sizeof(efm32_flash_write_stub));
-	/* Write Buffer */
-	target_mem_write(t, STUB_BUFFER_BASE, src, len);
-	/* Run flashloader */
-	return cortexm_run_stub(t, SRAM_BASE, dest, STUB_BUFFER_BASE, len, 0);
-
-	return 0;
-}
-
-/**
- * Uses the MSC ERASEMAIN0 command to erase the entire flash
- */
-static bool efm32_cmd_erase_all(target *t)
-{
-	/* Set WREN bit to enabel MSC write and erase functionality */
-	target_mem_write32(t, EFM32_MSC_WRITECTRL, 1);
-
-	/* Unlock mass erase */
-	target_mem_write32(t, EFM32_MSC_MASSLOCK, EFM32_MSC_MASSLOCK_LOCKKEY);
-
-	/* Erase operation */
-	target_mem_write32(t, EFM32_MSC_WRITECMD, EFM32_MSC_WRITECMD_ERASEMAIN0);
-
-	/* Poll MSC Busy */
-	while ((target_mem_read32(t, EFM32_MSC_STATUS) & EFM32_MSC_STATUS_BUSY)) {
-		if (target_check_error(t))
-			return false;
-	}
-
-	/* Relock mass erase */
-	target_mem_write32(t, EFM32_MSC_MASSLOCK, 0);
-
-	tc_printf(t, "Erase successful!\n");
-
-	return true;
-}
-
-/**
- * Reads the 40-bit unique number
- */
-static bool efm32_cmd_serial(target *t)
-{
-	/* Read the extended unique identifier */
-	uint64_t eui = efm32_read_eui(t);
-
-	/* 64 bits of unique number */
-	tc_printf(t, "Unique Number: 0x%016llx\n", eui);
-
-	return true;
-}
diff --git a/src/target/jtag_scan.c b/src/target/jtag_scan.c
deleted file mode 100644
index a30a805..0000000
--- a/src/target/jtag_scan.c
+++ /dev/null
@@ -1,252 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2011  Black Sphere Technologies Ltd.
- * Written by Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/* This file implements JTAG protocol support.  Provides functionality
- * to detect devices on the scan chain and read their IDCODEs.
- * It depends on the low-level function provided by the platform's jtagtap.c.
- */
-
-#include "general.h"
-#include "jtagtap.h"
-#include "jtag_scan.h"
-#include "target.h"
-#include "adiv5.h"
-
-struct jtag_dev_s jtag_devs[JTAG_MAX_DEVS+1];
-int jtag_dev_count;
-
-static const struct jtag_dev_descr_s {
-	const uint32_t idcode;
-	const uint32_t idmask;
-	const char * const descr;
-	void (*const handler)(jtag_dev_t *dev);
-} dev_descr[] = {
-	{.idcode = 0x0BA00477, .idmask = 0x0FFF0FFF,
-		.descr = "ARM Limited: ADIv5 JTAG-DP port.",
-		.handler = adiv5_jtag_dp_handler},
-	{.idcode = 0x06410041, .idmask = 0x0FFFFFFF,
-		.descr = "ST Microelectronics: STM32, Medium density."},
-	{.idcode = 0x06412041, .idmask = 0x0FFFFFFF,
-		.descr = "ST Microelectronics: STM32, Low density."},
-	{.idcode = 0x06414041, .idmask = 0x0FFFFFFF,
-		.descr = "ST Microelectronics: STM32, High density."},
-	{.idcode = 0x06416041, .idmask = 0x0FFFFFFF,
-		.descr = "ST Microelectronics: STM32L."},
-	{.idcode = 0x06418041, .idmask = 0x0FFFFFFF,
-		.descr = "ST Microelectronics: STM32, Connectivity Line."},
-	{.idcode = 0x06420041, .idmask = 0x0FFFFFFF,
-		.descr = "ST Microelectronics: STM32, Value Line."},
-	{.idcode = 0x06428041, .idmask = 0x0FFFFFFF,
-		.descr = "ST Microelectronics: STM32, Value Line, High density."},
-	{.idcode = 0x06411041, .idmask = 0xFFFFFFFF,
-		.descr = "ST Microelectronics: STM32F2xx."},
-	{.idcode = 0x06413041 , .idmask = 0xFFFFFFFF,
-		.descr = "ST Microelectronics: STM32F4xx."},
-	{.idcode = 0x0BB11477 , .idmask = 0xFFFFFFFF,
-		.descr = "NPX: LPC11C24."},
-/* Just for fun, unsupported */
-	{.idcode = 0x8940303F, .idmask = 0xFFFFFFFF, .descr = "ATMEL: ATMega16."},
-	{.idcode = 0x0792603F, .idmask = 0xFFFFFFFF, .descr = "ATMEL: AT91SAM9261."},
-	{.idcode = 0x20270013, .idmask = 0xFFFFFFFF, .descr = "Intel: i80386ex."},
-	{.idcode = 0x07B7617F, .idmask = 0xFFFFFFFF, .descr = "Broadcom: BCM2835."},
-	{.idcode = 0x4BA00477, .idmask = 0xFFFFFFFF, .descr = "Broadcom: BCM2836."},
-	{.idcode = 0, .idmask = 0, .descr = "Unknown"},
-};
-
-/* bucket of ones for don't care TDI */
-static const uint8_t ones[] = "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF";
-
-/* Scan JTAG chain for devices, store IR length and IDCODE (if present).
- * Reset TAP state machine.
- * Select Shift-IR state.
- * Each device is assumed to shift out IR at 0x01. (this may not always be true)
- * Shift in ones until we read two consecutive ones, then we have shifted out the
- * 	IRs of all devices.
- *
- * After this process all the IRs are loaded with the BYPASS command.
- * Select Shift-DR state.
- * Shift in ones and count zeros shifted out. Should be one for each device.
- * Check this against device count obtained by IR scan above.
- *
- * Reset the TAP state machine again. This should load all IRs with IDCODE.
- * For each device, shift out one bit. If this is zero IDCODE isn't present,
- *	continue to next device. If this is one shift out the remaining 31 bits
- *	of the IDCODE register.
- */
-int jtag_scan(const uint8_t *irlens)
-{
-	int i;
-	uint32_t j;
-
-	target_list_free();
-
-	jtag_dev_count = 0;
-	memset(&jtag_devs, 0, sizeof(jtag_devs));
-
-	/* Run throught the SWD to JTAG sequence for the case where an attached SWJ-DP is
-	 * in SW-DP mode.
-	 */
-	DEBUG("Resetting TAP\n");
-	jtagtap_init();
-	jtagtap_reset();
-
-	if (irlens) {
-		DEBUG("Given list of IR lengths, skipping probe\n");
-		DEBUG("Change state to Shift-IR\n");
-		jtagtap_shift_ir();
-		j = 0;
-		while((jtag_dev_count <= JTAG_MAX_DEVS) &&
-		      (jtag_devs[jtag_dev_count].ir_len <= JTAG_MAX_IR_LEN)) {
-			uint32_t irout;
-			if(*irlens == 0)
-				break;
-			jtagtap_tdi_tdo_seq((uint8_t*)&irout, 0, ones, *irlens);
-			if (!(irout & 1)) {
-				DEBUG("check failed: IR[0] != 1\n");
-				return -1;
-			}
-			jtag_devs[jtag_dev_count].ir_len = *irlens;
-			jtag_devs[jtag_dev_count].ir_prescan = j;
-			jtag_devs[jtag_dev_count].dev = jtag_dev_count;
-			j += *irlens;
-			irlens++;
-			jtag_dev_count++;
-		}
-	} else {
-		DEBUG("Change state to Shift-IR\n");
-		jtagtap_shift_ir();
-
-		DEBUG("Scanning out IRs\n");
-		if(!jtagtap_next(0, 1)) {
-			DEBUG("jtag_scan: Sanity check failed: IR[0] shifted out as 0\n");
-			jtag_dev_count = -1;
-			return -1; /* must be 1 */
-		}
-		jtag_devs[0].ir_len = 1; j = 1;
-		while((jtag_dev_count <= JTAG_MAX_DEVS) &&
-		      (jtag_devs[jtag_dev_count].ir_len <= JTAG_MAX_IR_LEN)) {
-			if(jtagtap_next(0, 1)) {
-				if(jtag_devs[jtag_dev_count].ir_len == 1) break;
-				jtag_devs[++jtag_dev_count].ir_len = 1;
-				jtag_devs[jtag_dev_count].ir_prescan = j;
-				jtag_devs[jtag_dev_count].dev = jtag_dev_count;
-			} else jtag_devs[jtag_dev_count].ir_len++;
-			j++;
-		}
-		if(jtag_dev_count > JTAG_MAX_DEVS) {
-			DEBUG("jtag_scan: Maximum device count exceeded\n");
-			jtag_dev_count = -1;
-			return -1;
-		}
-		if(jtag_devs[jtag_dev_count].ir_len > JTAG_MAX_IR_LEN) {
-			DEBUG("jtag_scan: Maximum IR length exceeded\n");
-			jtag_dev_count = -1;
-			return -1;
-		}
-	}
-
-	DEBUG("Return to Run-Test/Idle\n");
-	jtagtap_next(1, 1);
-	jtagtap_return_idle();
-
-	/* All devices should be in BYPASS now */
-
-	/* Count device on chain */
-	DEBUG("Change state to Shift-DR\n");
-	jtagtap_shift_dr();
-	for(i = 0; (jtagtap_next(0, 1) == 0) && (i <= jtag_dev_count); i++)
-		jtag_devs[i].dr_postscan = jtag_dev_count - i - 1;
-
-	if(i != jtag_dev_count) {
-		DEBUG("jtag_scan: Sanity check failed: "
-			"BYPASS dev count doesn't match IR scan\n");
-		jtag_dev_count = -1;
-		return -1;
-	}
-
-	DEBUG("Return to Run-Test/Idle\n");
-	jtagtap_next(1, 1);
-	jtagtap_return_idle();
-	if(!jtag_dev_count) {
-		return 0;
-	}
-
-	/* Fill in the ir_postscan fields */
-	for(i = jtag_dev_count - 1; i; i--)
-		jtag_devs[i-1].ir_postscan = jtag_devs[i].ir_postscan +
-					jtag_devs[i].ir_len;
-
-	/* Reset jtagtap: should take all devs to IDCODE */
-	jtagtap_reset();
-	jtagtap_shift_dr();
-	for(i = 0; i < jtag_dev_count; i++) {
-		if(!jtagtap_next(0, 1)) continue;
-		jtag_devs[i].idcode = 1;
-		for(j = 2; j; j <<= 1)
-			if(jtagtap_next(0, 1)) jtag_devs[i].idcode |= j;
-
-	}
-	DEBUG("Return to Run-Test/Idle\n");
-	jtagtap_next(1, 1);
-	jtagtap_return_idle();
-
-	/* Check for known devices and handle accordingly */
-	for(i = 0; i < jtag_dev_count; i++)
-		for(j = 0; dev_descr[j].idcode; j++)
-			if((jtag_devs[i].idcode & dev_descr[j].idmask) ==
-			   dev_descr[j].idcode) {
-				jtag_devs[i].current_ir = -1;
-				/* Save description in table */
-				jtag_devs[i].descr = dev_descr[j].descr;
-				/* Call handler to initialise/probe device further */
-				if(dev_descr[j].handler)
-					dev_descr[j].handler(&jtag_devs[i]);
-				break;
-			}
-
-	return jtag_dev_count;
-}
-
-void jtag_dev_write_ir(jtag_dev_t *d, uint32_t ir)
-{
-	if(ir == d->current_ir) return;
-	for(int i = 0; i < jtag_dev_count; i++)
-		jtag_devs[i].current_ir = -1;
-	d->current_ir = ir;
-
-	jtagtap_shift_ir();
-	jtagtap_tdi_seq(0, ones, d->ir_prescan);
-	jtagtap_tdi_seq(d->ir_postscan?0:1, (void*)&ir, d->ir_len);
-	jtagtap_tdi_seq(1, ones, d->ir_postscan);
-	jtagtap_return_idle();
-}
-
-void jtag_dev_shift_dr(jtag_dev_t *d, uint8_t *dout, const uint8_t *din, int ticks)
-{
-	jtagtap_shift_dr();
-	jtagtap_tdi_seq(0, ones, d->dr_prescan);
-	if(dout)
-		jtagtap_tdi_tdo_seq((void*)dout, d->dr_postscan?0:1, (void*)din, ticks);
-	else
-		jtagtap_tdi_seq(d->dr_postscan?0:1, (void*)din, ticks);
-	jtagtap_tdi_seq(1, ones, d->dr_postscan);
-	jtagtap_return_idle();
-}
-
diff --git a/src/target/jtag_scan.h b/src/target/jtag_scan.h
deleted file mode 100644
index 3c723f4..0000000
--- a/src/target/jtag_scan.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2011  Black Sphere Technologies Ltd.
- * Written by Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef __JTAG_SCAN_H
-#define __JTAG_SCAN_H
-
-#define JTAG_MAX_DEVS	32
-#define JTAG_MAX_IR_LEN	16
-
-typedef struct jtag_dev_s {
-	union {
-		uint8_t dev;
-		uint8_t dr_prescan;
-	};
-	uint8_t dr_postscan;
-
-	uint8_t ir_len;
-	uint8_t ir_prescan;
-	uint8_t ir_postscan;
-
-	uint32_t idcode;
-	const char *descr;
-
-	uint32_t current_ir;
-
-} jtag_dev_t;
-
-extern struct jtag_dev_s jtag_devs[JTAG_MAX_DEVS+1];
-extern int jtag_dev_count;
-
-void jtag_dev_write_ir(jtag_dev_t *dev, uint32_t ir);
-void jtag_dev_shift_dr(jtag_dev_t *dev, uint8_t *dout, const uint8_t *din, int ticks);
-
-#endif
-
diff --git a/src/target/jtagtap_generic.c b/src/target/jtagtap_generic.c
deleted file mode 100644
index 416bcb6..0000000
--- a/src/target/jtagtap_generic.c
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2011  Black Sphere Technologies Ltd.
- * Written by Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/* This file provides generic forms of the low-level jtagtap functions
- * for platforms that don't require optimised forms.
- */
-#include "general.h"
-#include "jtagtap.h"
-
-void __attribute__((weak))
-jtagtap_tms_seq(uint32_t MS, int ticks)
-{
-	while(ticks--) {
-		jtagtap_next(MS & 1, 1);
-		MS >>= 1;
-	}
-}
-
-void __attribute__((weak))
-jtagtap_tdi_tdo_seq(uint8_t *DO, const uint8_t final_tms, const uint8_t *DI, int ticks)
-{
-	uint8_t index = 1;
-	while(ticks--) {
-		if(jtagtap_next(ticks?0:final_tms, *DI & index)) {
-			*DO |= index;
-		} else {
-			*DO &= ~index;
-		}
-		if(!(index <<= 1)) {
-			index = 1;
-			DI++; DO++;
-		}
-	}
-}
-
-void __attribute__((weak))
-jtagtap_tdi_seq(const uint8_t final_tms, const uint8_t *DI, int ticks)
-{
-	uint8_t index = 1;
-	while(ticks--) {
-		jtagtap_next(ticks?0:final_tms, *DI & index);
-		if(!(index <<= 1)) {
-			index = 1;
-			DI++;
-		}
-	}
-}
-
diff --git a/src/target/kinetis.c b/src/target/kinetis.c
deleted file mode 100644
index b65366c..0000000
--- a/src/target/kinetis.c
+++ /dev/null
@@ -1,364 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2015  Black Sphere Technologies Ltd.
- * Written by Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/* This file implements KL25 target specific functions providing
- * the XML memory map and Flash memory programming.
- *
- * According to Freescale doc KL25P80M48SF0RM:
- *    KL25 Sub-family Reference Manual
- *
- * Extended with support for KL02 family
- */
-
-#include "general.h"
-#include "target.h"
-#include "target_internal.h"
-
-#define SIM_SDID   0x40048024
-
-#define FTFA_BASE  0x40020000
-#define FTFA_FSTAT (FTFA_BASE + 0x00)
-#define FTFA_FCNFG (FTFA_BASE + 0x01)
-#define FTFA_FSEC  (FTFA_BASE + 0x02)
-#define FTFA_FOPT  (FTFA_BASE + 0x03)
-#define FTFA_FCCOB_0 (FTFA_BASE + 0x04)
-#define FTFA_FCCOB_1 (FTFA_BASE + 0x08)
-#define FTFA_FCCOB_2 (FTFA_BASE + 0x0C)
-
-#define FTFA_FSTAT_CCIF     (1 << 7)
-#define FTFA_FSTAT_RDCOLERR (1 << 6)
-#define FTFA_FSTAT_ACCERR   (1 << 5)
-#define FTFA_FSTAT_FPVIOL   (1 << 4)
-#define FTFA_FSTAT_MGSTAT0  (1 << 0)
-
-#define FTFA_CMD_CHECK_ERASE       0x01
-#define FTFA_CMD_PROGRAM_CHECK     0x02
-#define FTFA_CMD_READ_RESOURCE     0x03
-#define FTFA_CMD_PROGRAM_LONGWORD  0x06
-#define FTFA_CMD_ERASE_SECTOR      0x09
-#define FTFA_CMD_CHECK_ERASE_ALL   0x40
-#define FTFA_CMD_READ_ONCE         0x41
-#define FTFA_CMD_PROGRAM_ONCE      0x43
-#define FTFA_CMD_ERASE_ALL         0x44
-#define FTFA_CMD_BACKDOOR_ACCESS   0x45
-
-#define KL_GEN_PAGESIZE 0x400
-
-static bool kinetis_cmd_unsafe(target *t, int argc, char *argv[]);
-static bool unsafe_enabled;
-
-const struct command_s kinetis_cmd_list[] = {
-	{"unsafe", (cmd_handler)kinetis_cmd_unsafe, "Allow programming security byte (enable|disable)"},
-	{NULL, NULL, NULL}
-};
-
-static bool kinetis_cmd_unsafe(target *t, int argc, char *argv[])
-{
-	if (argc == 1)
-		tc_printf(t, "Allow programming security byte: %s\n",
-			  unsafe_enabled ? "enabled" : "disabled");
-	else
-		unsafe_enabled = argv[1][0] == 'e';
-	return true;
-}
-
-static int kl_gen_flash_erase(struct target_flash *f, target_addr addr, size_t len);
-static int kl_gen_flash_write(struct target_flash *f,
-                              target_addr dest, const void *src, size_t len);
-static int kl_gen_flash_done(struct target_flash *f);
-
-static void kl_gen_add_flash(target *t,
-                           uint32_t addr, size_t length, size_t erasesize)
-{
-	struct target_flash *f = calloc(1, sizeof(*f));
-	f->start = addr;
-	f->length = length;
-	f->blocksize = erasesize;
-	f->erase = kl_gen_flash_erase;
-	f->write = kl_gen_flash_write;
-	f->done = kl_gen_flash_done;
-	f->align = 4;
-	f->erased = 0xff;
-	target_add_flash(t, f);
-}
-
-bool kinetis_probe(target *t)
-{
-	uint32_t sdid = target_mem_read32(t, SIM_SDID);
-	switch (sdid >> 20) {
-	case 0x251:
-		t->driver = "KL25";
-		target_add_ram(t, 0x1ffff000, 0x1000);
-		target_add_ram(t, 0x20000000, 0x3000);
-		kl_gen_add_flash(t, 0x00000000, 0x20000, 0x400);
-		break;
-	case 0x231:
-		t->driver = "KL27";
-		target_add_ram(t, 0x1fffe000, 0x2000);
-		target_add_ram(t, 0x20000000, 0x6000);
-		kl_gen_add_flash(t, 0x00000000, 0x40000, 0x400);
-		break;
-	case 0x021: /* KL02 family */
-		switch((sdid>>16) & 0x0f){
-			case 3:
-				t->driver = "KL02x32";
-				target_add_ram(t, 0x1FFFFC00, 0x400);
-				target_add_ram(t, 0x20000000, 0xc00);
-				kl_gen_add_flash(t, 0x00000000, 0x7FFF, 0x400);
-				break;
-			case 2:
-				t->driver = "KL02x16";
-				target_add_ram(t, 0x1FFFFE00, 0x200);
-				target_add_ram(t, 0x20000000, 0x600);
-				kl_gen_add_flash(t, 0x00000000, 0x3FFF, 0x400);
-				break;
-			case 1:
-				t->driver = "KL02x8";
-				target_add_ram(t, 0x1FFFFF00, 0x100);
-				target_add_ram(t, 0x20000000, 0x300);
-				kl_gen_add_flash(t, 0x00000000, 0x1FFF, 0x400);
-				break;
-			default:
-				return false;
-			}
-		break;
-	case 0x031: /* KL03 family */
-		t->driver = "KL03";
-		target_add_ram(t, 0x1ffffe00, 0x200);
-		target_add_ram(t, 0x20000000, 0x600);
-		kl_gen_add_flash(t, 0, 0x8000, 0x400);
-		break;
-	case 0x220: /* K22F family */
-		t->driver = "K22F";
-		target_add_ram(t, 0x1c000000, 0x4000000);
-		target_add_ram(t, 0x20000000, 0x100000);
-		kl_gen_add_flash(t, 0, 0x40000, 0x800);
-		kl_gen_add_flash(t, 0x40000, 0x40000, 0x800);
-		break;
-	default:
-		return false;
-	}
-	unsafe_enabled = false;
-	target_add_commands(t, kinetis_cmd_list, t->driver);
-	return true;
-}
-
-static bool
-kl_gen_command(target *t, uint8_t cmd, uint32_t addr, const uint8_t data[8])
-{
-	uint8_t fstat;
-
-	/* clear errors unconditionally, so we can start a new operation */
-	target_mem_write8(t,FTFA_FSTAT,(FTFA_FSTAT_ACCERR | FTFA_FSTAT_FPVIOL));
-
-	/* Wait for CCIF to be high */
-	do {
-		fstat = target_mem_read8(t, FTFA_FSTAT);
-	} while (!(fstat & FTFA_FSTAT_CCIF));
-
-	/* Write command to FCCOB */
-	addr &= 0xffffff;
-	addr |= (uint32_t)cmd << 24;
-	target_mem_write32(t, FTFA_FCCOB_0, addr);
-	if (data) {
-		target_mem_write32(t, FTFA_FCCOB_1, *(uint32_t*)&data[0]);
-		target_mem_write32(t, FTFA_FCCOB_2, *(uint32_t*)&data[4]);
-	}
-
-	/* Enable execution by clearing CCIF */
-	target_mem_write8(t, FTFA_FSTAT, FTFA_FSTAT_CCIF);
-
-	/* Wait for execution to complete */
-	do {
-		fstat = target_mem_read8(t, FTFA_FSTAT);
-		/* Check ACCERR and FPVIOL are zero in FSTAT */
-		if (fstat & (FTFA_FSTAT_ACCERR | FTFA_FSTAT_FPVIOL))
-			return false;
-	} while (!(fstat & FTFA_FSTAT_CCIF));
-
-	return true;
-}
-
-static int kl_gen_flash_erase(struct target_flash *f, target_addr addr, size_t len)
-{
-	while (len) {
-		if (kl_gen_command(f->t, FTFA_CMD_ERASE_SECTOR, addr, NULL)) {
-			len -= KL_GEN_PAGESIZE;
-			addr += KL_GEN_PAGESIZE;
-		} else {
-			return 1;
-		}
-	}
-	return 0;
-}
-
-#define FLASH_SECURITY_BYTE_ADDRESS 0x40C
-#define FLASH_SECURITY_BYTE_UNSECURED 0xFE
-
-static int kl_gen_flash_write(struct target_flash *f,
-                              target_addr dest, const void *src, size_t len)
-{
-	/* Ensure we don't write something horrible over the security byte */
-	if (!unsafe_enabled &&
-	    (dest <= FLASH_SECURITY_BYTE_ADDRESS) &&
-	    ((dest + len) > FLASH_SECURITY_BYTE_ADDRESS)) {
-		((uint8_t*)src)[FLASH_SECURITY_BYTE_ADDRESS - dest] =
-		    FLASH_SECURITY_BYTE_UNSECURED;
-	}
-
-	while (len) {
-		if (kl_gen_command(f->t, FTFA_CMD_PROGRAM_LONGWORD, dest, src)) {
-			len -= 4;
-			dest += 4;
-			src += 4;
-		} else {
-			return 1;
-		}
-	}
-	return 0;
-}
-
-static int kl_gen_flash_done(struct target_flash *f)
-{
-
-	if (unsafe_enabled)
-		return 0;
-
-	if (target_mem_read8(f->t, FLASH_SECURITY_BYTE_ADDRESS) ==
-	    FLASH_SECURITY_BYTE_UNSECURED)
-		return 0;
-
-	uint32_t val = target_mem_read32(f->t, FLASH_SECURITY_BYTE_ADDRESS);
-	val = (val & 0xffffff00) | FLASH_SECURITY_BYTE_UNSECURED;
-	kl_gen_command(f->t, FTFA_CMD_PROGRAM_LONGWORD,
-	               FLASH_SECURITY_BYTE_ADDRESS, (uint8_t*)&val);
-
-	return 0;
-}
-
-/*** Kinetis recovery mode using the MDM-AP ***/
-
-/* Kinetis security bits are stored in regular flash, so it is possible
- * to enable protection by accident when flashing a bad binary.
- * a backdoor AP is provided which may allow a mass erase to recover the
- * device.  This provides a fake target to allow a monitor command interface
- */
-#include "adiv5.h"
-
-#define KINETIS_MDM_IDR_K22F 0x1c0000
-#define KINETIS_MDM_IDR_KZ03 0x1c0020
-
-static bool kinetis_mdm_cmd_erase_mass(target *t);
-
-const struct command_s kinetis_mdm_cmd_list[] = {
-	{"erase_mass", (cmd_handler)kinetis_mdm_cmd_erase_mass, "Erase entire flash memory"},
-	{NULL, NULL, NULL}
-};
-
-bool nop_function(void)
-{
-	return true;
-}
-
-enum target_halt_reason mdm_halt_poll(target *t, target_addr *watch)
-{
-	(void)t; (void)watch;
-	return TARGET_HALT_REQUEST;
-}
-
-void kinetis_mdm_probe(ADIv5_AP_t *ap)
-{
-	switch(ap->idr) {
-	case KINETIS_MDM_IDR_KZ03:
-	case KINETIS_MDM_IDR_K22F:
-		break;
-	default:
-		return;
-	}
-
-	target *t = target_new();
-	adiv5_ap_ref(ap);
-	t->priv = ap;
-	t->priv_free = (void*)adiv5_ap_unref;
-
-	t->driver = "Kinetis Recovery (MDM-AP)";
-	t->attach = (void*)nop_function;
-	t->detach = (void*)nop_function;
-	t->check_error = (void*)nop_function;
-	t->mem_read = (void*)nop_function;
-	t->mem_write = (void*)nop_function;
-	t->regs_size = 4;
-	t->regs_read = (void*)nop_function;
-	t->regs_write = (void*)nop_function;
-	t->reset = (void*)nop_function;
-	t->halt_request = (void*)nop_function;
-	t->halt_poll = mdm_halt_poll;
-	t->halt_resume = (void*)nop_function;
-
-	target_add_commands(t, kinetis_mdm_cmd_list, t->driver);
-}
-
-#define MDM_STATUS  ADIV5_AP_REG(0x00)
-#define MDM_CONTROL ADIV5_AP_REG(0x04)
-
-#define MDM_STATUS_MASS_ERASE_ACK (1 << 0)
-#define MDM_STATUS_FLASH_READY (1 << 1)
-#define MDM_STATUS_MASS_ERASE_ENABLED (1 << 5)
-
-#define MDM_CONTROL_MASS_ERASE (1 << 0)
-
-static bool kinetis_mdm_cmd_erase_mass(target *t)
-{
-	ADIv5_AP_t *ap = t->priv;
-
-	uint32_t status, control;
-	status = adiv5_ap_read(ap, MDM_STATUS);
-	control = adiv5_ap_read(ap, MDM_CONTROL);
-	tc_printf(t, "Requesting mass erase (status = 0x%"PRIx32")\n", status);
-
-	if (!(status & MDM_STATUS_MASS_ERASE_ENABLED)) {
-		tc_printf(t, "ERROR: Mass erase disabled!\n");
-		return false;
-	}
-
-	if (!(status & MDM_STATUS_FLASH_READY)) {
-		tc_printf(t, "ERROR: Flash not ready!\n");
-		return false;
-	}
-
-	if (status & MDM_STATUS_MASS_ERASE_ACK) {
-		tc_printf(t, "ERROR: Mass erase already in progress!\n");
-		return false;
-	}
-
-	adiv5_ap_write(ap, MDM_CONTROL, MDM_CONTROL_MASS_ERASE);
-
-	do {
-		status = adiv5_ap_read(ap, MDM_STATUS);
-	} while (!(status & MDM_STATUS_MASS_ERASE_ACK));
-	tc_printf(t, "Mass erase acknowledged\n");
-
-	do {
-		control = adiv5_ap_read(ap, MDM_CONTROL);
-	} while (!(control & MDM_CONTROL_MASS_ERASE));
-	tc_printf(t, "Mass erase complete\n");
-
-	return true;
-}
diff --git a/src/target/lmi.c b/src/target/lmi.c
deleted file mode 100644
index ed54d57..0000000
--- a/src/target/lmi.c
+++ /dev/null
@@ -1,140 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2011  Black Sphere Technologies Ltd.
- * Written by Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/* This file implements TI/LMI LM3S target specific functions providing
- * the XML memory map and Flash memory programming.
- *
- * According to: TivaTM TM4C123GH6PM Microcontroller Datasheet
- */
-
-#include "general.h"
-#include "target.h"
-#include "target_internal.h"
-#include "cortexm.h"
-
-#define SRAM_BASE            0x20000000
-#define STUB_BUFFER_BASE     ALIGN(SRAM_BASE + sizeof(lmi_flash_write_stub), 4)
-
-#define BLOCK_SIZE           0x400
-
-#define LMI_SCB_BASE         0x400FE000
-#define LMI_SCB_DID1         (LMI_SCB_BASE + 0x004)
-
-#define LMI_FLASH_BASE       0x400FD000
-#define LMI_FLASH_FMA        (LMI_FLASH_BASE + 0x000)
-#define LMI_FLASH_FMC        (LMI_FLASH_BASE + 0x008)
-
-#define LMI_FLASH_FMC_WRITE  (1 << 0)
-#define LMI_FLASH_FMC_ERASE  (1 << 1)
-#define LMI_FLASH_FMC_MERASE (1 << 2)
-#define LMI_FLASH_FMC_COMT   (1 << 3)
-#define LMI_FLASH_FMC_WRKEY  0xA4420000
-
-static int lmi_flash_erase(struct target_flash *f, target_addr addr, size_t len);
-static int lmi_flash_write(struct target_flash *f,
-                           target_addr dest, const void *src, size_t len);
-
-static const char lmi_driver_str[] = "TI Stellaris/Tiva";
-
-static const uint16_t lmi_flash_write_stub[] = {
-#include "flashstub/lmi.stub"
-};
-
-static void lmi_add_flash(target *t, size_t length)
-{
-	struct target_flash *f = calloc(1, sizeof(*f));
-	f->start = 0;
-	f->length = length;
-	f->blocksize = 0x400;
-	f->erase = lmi_flash_erase;
-	f->write = lmi_flash_write;
-	f->align = 4;
-	f->erased = 0xff;
-	target_add_flash(t, f);
-}
-
-bool lmi_probe(target *t)
-{
-	uint32_t did1 = target_mem_read32(t, LMI_SCB_DID1);
-	switch (did1 >> 16) {
-	case 0x1049:	/* LM3S3748 */
-		t->driver = lmi_driver_str;
-		target_add_ram(t, 0x20000000, 0x8000);
-		lmi_add_flash(t, 0x40000);
-		return true;
-
-	case 0x10A1:	/* TM4C123GH6PM */
-		t->driver = lmi_driver_str;
-		target_add_ram(t, 0x20000000, 0x10000);
-		lmi_add_flash(t, 0x80000);
-		/* On Tiva targets, asserting SRST results in the debug
-		 * logic also being reset.  We can't assert SRST and must
-		 * only use the AIRCR SYSRESETREQ. */
-		t->target_options |= CORTEXM_TOPT_INHIBIT_SRST;
-		return true;
-
-	case 0x1022:    /* TM4C1230C3PM */
-		t->driver = lmi_driver_str;
-		target_add_ram(t, 0x20000000, 0x6000);
-		lmi_add_flash(t, 0x10000);
-		t->target_options |= CORTEXM_TOPT_INHIBIT_SRST;
-		return true;
-	}
-	return false;
-}
-
-int lmi_flash_erase(struct target_flash *f, target_addr addr, size_t len)
-{
-	target  *t = f->t;
-
-	target_check_error(t);
-
-	while(len) {
-		target_mem_write32(t, LMI_FLASH_FMA, addr);
-		target_mem_write32(t, LMI_FLASH_FMC,
-		                   LMI_FLASH_FMC_WRKEY | LMI_FLASH_FMC_ERASE);
-		while (target_mem_read32(t, LMI_FLASH_FMC) &
-		       LMI_FLASH_FMC_ERASE);
-
-		if (target_check_error(t))
-			return -1;
-
-		len -= BLOCK_SIZE;
-		addr += BLOCK_SIZE;
-	}
-	return 0;
-}
-
-int lmi_flash_write(struct target_flash *f,
-                    target_addr dest, const void *src, size_t len)
-{
-	target  *t = f->t;
-
-	target_check_error(t);
-
-	target_mem_write(t, SRAM_BASE, lmi_flash_write_stub,
-	                 sizeof(lmi_flash_write_stub));
-	target_mem_write(t, STUB_BUFFER_BASE, src, len);
-
-	if (target_check_error(t))
-		return -1;
-
-	return cortexm_run_stub(t, SRAM_BASE, dest, STUB_BUFFER_BASE, len, 0);
-}
diff --git a/src/target/lpc11xx.c b/src/target/lpc11xx.c
deleted file mode 100644
index 248e7ee..0000000
--- a/src/target/lpc11xx.c
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2011 Mike Smith <drziplok@me.com>
- * Copyright (C) 2016 Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "general.h"
-#include "target.h"
-#include "target_internal.h"
-#include "cortexm.h"
-#include "lpc_common.h"
-
-#define IAP_PGM_CHUNKSIZE	512	/* should fit in RAM on any device */
-
-#define MIN_RAM_SIZE            1024
-#define RAM_USAGE_FOR_IAP_ROUTINES	32	/* IAP routines use 32 bytes at top of ram */
-
-#define IAP_ENTRYPOINT	0x1fff1ff1
-#define IAP_RAM_BASE	0x10000000
-
-#define LPC11XX_DEVICE_ID  0x400483F4
-#define LPC8XX_DEVICE_ID   0x400483F8
-
-void lpc11xx_add_flash(target *t, uint32_t addr, size_t len, size_t erasesize)
-{
-	struct lpc_flash *lf = lpc_add_flash(t, addr, len);
-	lf->f.blocksize = erasesize;
-	lf->f.buf_size = IAP_PGM_CHUNKSIZE;
-	lf->f.write_buf = lpc_flash_write_magic_vect;
-	lf->iap_entry = IAP_ENTRYPOINT;
-	lf->iap_ram = IAP_RAM_BASE;
-	lf->iap_msp = IAP_RAM_BASE + MIN_RAM_SIZE - RAM_USAGE_FOR_IAP_ROUTINES;
-}
-
-bool
-lpc11xx_probe(target *t)
-{
-	uint32_t idcode;
-
-	/* read the device ID register */
-	idcode = target_mem_read32(t, LPC11XX_DEVICE_ID);
-	switch (idcode) {
-	case 0x041E502B:
-	case 0x2516D02B:
-	case 0x0416502B:
-	case 0x2516902B:	/* lpc1111 */
-	case 0x2524D02B:
-	case 0x0425502B:
-	case 0x2524902B:
-	case 0x1421102B:	/* lpc1112 */
-	case 0x0434502B:
-	case 0x2532902B:
-	case 0x0434102B:
-	case 0x2532102B:	/* lpc1113 */
-	case 0x0444502B:
-	case 0x2540902B:
-	case 0x0444102B:
-	case 0x2540102B:
-	case 0x1440102B:	/* lpc1114 */
-	case 0x0A40902B:
-	case 0x1A40902B:
-	case 0x2058002B:	/* lpc1115 */
-	case 0x1431102B:	/* lpc11c22 */
-	case 0x1430102B:	/* lpc11c24 */
-	case 0x095C802B:	/* lpc11u12x/201 */
-	case 0x295C802B:
-	case 0x097A802B:	/* lpc11u13/201 */
-	case 0x297A802B:
-	case 0x0998802B:	/* lpc11u14x/201 */
-	case 0x2998802B:
-	case 0x2972402B:	/* lpc11u23/301 */
-	case 0x2988402B:	/* lpc11u24x/301 */
-	case 0x2980002B:	/* lpc11u24x/401 */
-		t->driver = "LPC11xx";
-		target_add_ram(t, 0x10000000, 0x2000);
-		lpc11xx_add_flash(t, 0x00000000, 0x20000, 0x1000);
-		return true;
-
-	case 0x0A24902B:
-	case 0x1A24902B:
-		t->driver = "LPC1112";
-		target_add_ram(t, 0x10000000, 0x1000);
-		lpc11xx_add_flash(t, 0x00000000, 0x10000, 0x1000);
-		return true;
-	}
-
-	idcode = target_mem_read32(t, LPC8XX_DEVICE_ID);
-	switch (idcode) {
-	case 0x00008100:  /* LPC810M021FN8 */
-	case 0x00008110:  /* LPC811M001JDH16 */
-	case 0x00008120:  /* LPC812M101JDH16 */
-	case 0x00008121:  /* LPC812M101JD20 */
-	case 0x00008122:  /* LPC812M101JDH20 / LPC812M101JTB16 */
-		t->driver = "LPC81x";
-		target_add_ram(t, 0x10000000, 0x1000);
-		lpc11xx_add_flash(t, 0x00000000, 0x4000, 0x400);
-		return true;
-        case 0x00008221:  /* LPC822M101JHI33 */
-        case 0x00008222:  /* LPC822M101JDH20 */
-        case 0x00008241:  /* LPC824M201JHI33 */
-        case 0x00008242:  /* LPC824M201JDH20 */
-		t->driver = "LPC82x";
-		target_add_ram(t, 0x10000000, 0x2000);
-		lpc11xx_add_flash(t, 0x00000000, 0x8000, 0x400);
-		return true;
-
-	}
-
-	return false;
-}
-
diff --git a/src/target/lpc15xx.c b/src/target/lpc15xx.c
deleted file mode 100644
index 4e362e2..0000000
--- a/src/target/lpc15xx.c
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2011 Mike Smith <drziplok@me.com>
- * Copyright (C) 2016 Gareth McMullin <gareth@blacksphere.co.nz>
- * Copyright (C) 2016 David Lawrence <dlaw@markforged.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "general.h"
-#include "target.h"
-#include "target_internal.h"
-#include "cortexm.h"
-#include "lpc_common.h"
-
-#define IAP_PGM_CHUNKSIZE	512	/* should fit in RAM on any device */
-
-#define MIN_RAM_SIZE            1024
-#define RAM_USAGE_FOR_IAP_ROUTINES	32	/* IAP routines use 32 bytes at top of ram */
-
-#define IAP_ENTRYPOINT	0x03000205
-#define IAP_RAM_BASE	0x02000000
-
-#define LPC15XX_DEVICE_ID  0x400743F8
-
-void lpc15xx_add_flash(target *t, uint32_t addr, size_t len, size_t erasesize)
-{
-	struct lpc_flash *lf = lpc_add_flash(t, addr, len);
-	lf->f.blocksize = erasesize;
-	lf->f.buf_size = IAP_PGM_CHUNKSIZE;
-	lf->f.write_buf = lpc_flash_write_magic_vect;
-	lf->iap_entry = IAP_ENTRYPOINT;
-	lf->iap_ram = IAP_RAM_BASE;
-	lf->iap_msp = IAP_RAM_BASE + MIN_RAM_SIZE - RAM_USAGE_FOR_IAP_ROUTINES;
-}
-
-bool
-lpc15xx_probe(target *t)
-{
-	uint32_t idcode;
-	uint32_t ram_size = 0;
-
-	/* read the device ID register */
-	idcode = target_mem_read32(t, LPC15XX_DEVICE_ID);
-	switch (idcode) {
-	case 0x00001549:
-	case 0x00001519:
-		ram_size = 0x9000;
-		break;
-	case 0x00001548:
-	case 0x00001518:
-		ram_size = 0x5000;
-		break;
-	case 0x00001547:
-	case 0x00001517:
-		ram_size = 0x3000;
-		break;
-	}
-	if (ram_size) {
-		t->driver = "LPC15xx";
-		target_add_ram(t, 0x02000000, ram_size);
-		lpc15xx_add_flash(t, 0x00000000, 0x40000, 0x1000);
-		return true;
-	}
-
-	return false;
-}
-
diff --git a/src/target/lpc43xx.c b/src/target/lpc43xx.c
deleted file mode 100644
index f08c4f8..0000000
--- a/src/target/lpc43xx.c
+++ /dev/null
@@ -1,267 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2014 Allen Ibara <aibara>
- * Copyright (C) 2015 Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "general.h"
-#include "target.h"
-#include "target_internal.h"
-#include "cortexm.h"
-#include "lpc_common.h"
-
-#define LPC43XX_CHIPID	0x40043200
-#define ARM_CPUID	0xE000ED00
-
-#define IAP_ENTRYPOINT_LOCATION	0x10400100
-
-#define LPC43XX_ETBAHB_SRAM_BASE 0x2000C000
-#define LPC43XX_ETBAHB_SRAM_SIZE (16*1024)
-
-#define LPC43XX_WDT_MODE 0x40080000
-#define LPC43XX_WDT_CNT  0x40080004
-#define LPC43XX_WDT_FEED 0x40080008
-#define LPC43XX_WDT_PERIOD_MAX 0xFFFFFF
-#define LPC43XX_WDT_PROTECT (1 << 4)
-
-#define IAP_RAM_SIZE	LPC43XX_ETBAHB_SRAM_SIZE
-#define IAP_RAM_BASE	LPC43XX_ETBAHB_SRAM_BASE
-
-#define IAP_PGM_CHUNKSIZE	4096
-
-#define FLASH_NUM_BANK		2
-#define FLASH_NUM_SECTOR	15
-
-static bool lpc43xx_cmd_erase(target *t, int argc, const char *argv[]);
-static bool lpc43xx_cmd_reset(target *t, int argc, const char *argv[]);
-static bool lpc43xx_cmd_mkboot(target *t, int argc, const char *argv[]);
-static int lpc43xx_flash_init(target *t);
-static int lpc43xx_flash_erase(struct target_flash *f, target_addr addr, size_t len);
-static void lpc43xx_set_internal_clock(target *t);
-static void lpc43xx_wdt_set_period(target *t);
-static void lpc43xx_wdt_pet(target *t);
-
-const struct command_s lpc43xx_cmd_list[] = {
-	{"erase_mass", lpc43xx_cmd_erase, "Erase entire flash memory"},
-	{"reset", lpc43xx_cmd_reset, "Reset target"},
-	{"mkboot", lpc43xx_cmd_mkboot, "Make flash bank bootable"},
-	{NULL, NULL, NULL}
-};
-
-void lpc43xx_add_flash(target *t, uint32_t iap_entry,
-                       uint8_t bank, uint8_t base_sector,
-                       uint32_t addr, size_t len, size_t erasesize)
-{
-	struct lpc_flash *lf = lpc_add_flash(t, addr, len);
-	lf->f.erase = lpc43xx_flash_erase;
-	lf->f.blocksize = erasesize;
-	lf->f.buf_size = IAP_PGM_CHUNKSIZE;
-	lf->bank = bank;
-	lf->base_sector = base_sector;
-	lf->iap_entry = iap_entry;
-	lf->iap_ram = IAP_RAM_BASE;
-	lf->iap_msp = IAP_RAM_BASE + IAP_RAM_SIZE;
-	lf->wdt_kick = lpc43xx_wdt_pet;
-}
-
-bool lpc43xx_probe(target *t)
-{
-	uint32_t chipid, cpuid;
-	uint32_t iap_entry;
-
-	chipid = target_mem_read32(t, LPC43XX_CHIPID);
-	cpuid = target_mem_read32(t, ARM_CPUID);
-
-	switch(chipid) {
-	case 0x4906002B:	/* Parts with on-chip flash */
-	case 0x7906002B:	/* LM43S?? - Undocumented? */
-		switch (cpuid & 0xFF00FFF0) {
-		case 0x4100C240:
-			t->driver = "LPC43xx Cortex-M4";
-			if (cpuid == 0x410FC241)
-			{
-				/* LPC4337 */
-				iap_entry = target_mem_read32(t,
-				                  IAP_ENTRYPOINT_LOCATION);
-				target_add_ram(t, 0, 0x1A000000);
-				lpc43xx_add_flash(t, iap_entry, 0, 0,
-				                  0x1A000000, 0x10000, 0x2000);
-				lpc43xx_add_flash(t, iap_entry, 0, 8,
-				                  0x1A010000, 0x70000, 0x10000);
-				target_add_ram(t, 0x1A080000, 0xF80000);
-				lpc43xx_add_flash(t, iap_entry, 1, 0,
-				                  0x1B000000, 0x10000, 0x2000);
-				lpc43xx_add_flash(t, iap_entry, 1, 8,
-				                  0x1B010000, 0x70000, 0x10000);
-				target_add_commands(t, lpc43xx_cmd_list, "LPC43xx");
-				target_add_ram(t, 0x1B080000, 0xE4F80000UL);
-				t->target_options |= CORTEXM_TOPT_INHIBIT_SRST;
-			}
-			break;
-		case 0x4100C200:
-			t->driver = "LPC43xx Cortex-M0";
-			break;
-		default:
-			t->driver = "LPC43xx <Unknown>";
-		}
-		return true;
-	case 0x5906002B:	/* Flashless parts */
-	case 0x6906002B:
-		switch (cpuid & 0xFF00FFF0) {
-		case 0x4100C240:
-			t->driver = "LPC43xx Cortex-M4";
-			break;
-		case 0x4100C200:
-			t->driver = "LPC43xx Cortex-M0";
-			break;
-		default:
-			t->driver = "LPC43xx <Unknown>";
-		}
-		return true;
-	}
-
-	return false;
-}
-
-/* Reset all major systems _except_ debug */
-static bool lpc43xx_cmd_reset(target *t, int argc, const char *argv[])
-{
-	(void)argc;
-	(void)argv;
-
-	/* Cortex-M4 Application Interrupt and Reset Control Register */
-	static const uint32_t AIRCR = 0xE000ED0C;
-	/* Magic value key */
-	static const uint32_t reset_val = 0x05FA0004;
-
-	/* System reset on target */
-	target_mem_write(t, AIRCR, &reset_val, sizeof(reset_val));
-
-	return true;
-}
-
-static bool lpc43xx_cmd_erase(target *t, int argc, const char *argv[])
-{
-	(void)argc;
-	(void)argv;
-
-	lpc43xx_flash_init(t);
-
-	for (int bank = 0; bank < FLASH_NUM_BANK; bank++)
-	{
-		struct lpc_flash *f = (struct lpc_flash *)t->flash;
-		if (lpc_iap_call(f, IAP_CMD_PREPARE,
-		                 0, FLASH_NUM_SECTOR-1, bank))
-			return false;
-
-		if (lpc_iap_call(f, IAP_CMD_ERASE,
-		                 0, FLASH_NUM_SECTOR-1, CPU_CLK_KHZ, bank))
-			return false;
-	}
-
-	tc_printf(t, "Erase OK.\n");
-
-	return true;
-}
-
-static int lpc43xx_flash_init(target *t)
-{
-	/* Deal with WDT */
-	lpc43xx_wdt_set_period(t);
-
-	/* Force internal clock */
-	lpc43xx_set_internal_clock(t);
-
-	/* Initialize flash IAP */
-	struct lpc_flash *f = (struct lpc_flash *)t->flash;
-	if (lpc_iap_call(f, IAP_CMD_INIT))
-		return -1;
-
-	return 0;
-}
-
-static int lpc43xx_flash_erase(struct target_flash *f, target_addr addr, size_t len)
-{
-	if (lpc43xx_flash_init(f->t))
-		return -1;
-
-	return lpc_flash_erase(f, addr, len);
-}
-
-static void lpc43xx_set_internal_clock(target *t)
-{
-	const uint32_t val2 = (1 << 11) | (1 << 24);
-	target_mem_write32(t, 0x40050000 + 0x06C, val2);
-}
-
-/*
- * Call Boot ROM code to make a flash bank bootable by computing and writing the
- * correct signature into the exception table near the start of the bank.
- *
- * This is done indepently of writing to give the user a chance to verify flash
- * before changing it.
- */
-static bool lpc43xx_cmd_mkboot(target *t, int argc, const char *argv[])
-{
-	/* Usage: mkboot 0 or mkboot 1 */
-	if (argc != 2) {
-		tc_printf(t, "Expected bank argument 0 or 1.\n");
-		return false;
-	}
-
-	const long int bank = strtol(argv[1], NULL, 0);
-
-	if ((bank != 0) && (bank != 1)) {
-		tc_printf(t, "Unexpected bank number, should be 0 or 1.\n");
-		return false;
-	}
-
-	lpc43xx_flash_init(t);
-
-	/* special command to compute/write magic vector for signature */
-	struct lpc_flash *f = (struct lpc_flash *)t->flash;
-	if (lpc_iap_call(f, IAP_CMD_SET_ACTIVE_BANK, bank, CPU_CLK_KHZ)) {
-		tc_printf(t, "Set bootable failed.\n");
-		return false;
-	}
-
-	tc_printf(t, "Set bootable OK.\n");
-	return true;
-}
-
-static void lpc43xx_wdt_set_period(target *t)
-{
-	/* Check if WDT is on */
-	uint32_t wdt_mode = target_mem_read32(t, LPC43XX_WDT_MODE);
-
-	/* If WDT on, we can't disable it, but we may be able to set a long period */
-	if (wdt_mode && !(wdt_mode & LPC43XX_WDT_PROTECT))
-		target_mem_write32(t, LPC43XX_WDT_CNT, LPC43XX_WDT_PERIOD_MAX);
-}
-
-static void lpc43xx_wdt_pet(target *t)
-{
-	/* Check if WDT is on */
-	uint32_t wdt_mode = target_mem_read32(t, LPC43XX_WDT_MODE);
-
-	/* If WDT on, pet */
-	if (wdt_mode) {
-		target_mem_write32(t, LPC43XX_WDT_FEED, 0xAA);
-		target_mem_write32(t, LPC43XX_WDT_FEED, 0xFF);
-	}
-}
-
diff --git a/src/target/lpc_common.c b/src/target/lpc_common.c
deleted file mode 100644
index 63d844e..0000000
--- a/src/target/lpc_common.c
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2015 Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-#include "general.h"
-#include "target.h"
-#include "target_internal.h"
-#include "cortexm.h"
-#include "lpc_common.h"
-
-#include <stdarg.h>
-
-struct flash_param {
-	uint16_t opcode;
-	uint16_t pad0;
-	uint32_t command;
-	uint32_t words[4];
-	uint32_t result;
-} __attribute__((aligned(4)));
-
-
-struct lpc_flash *lpc_add_flash(target *t, target_addr addr, size_t length)
-{
-	struct lpc_flash *lf = calloc(1, sizeof(*lf));
-	struct target_flash *f = &lf->f;
-	f->start = addr;
-	f->length = length;
-	f->erase = lpc_flash_erase;
-	f->write = target_flash_write_buffered;
-	f->done = target_flash_done_buffered;
-	f->write_buf = lpc_flash_write;
-	f->erased = 0xff;
-	target_add_flash(t, f);
-	return lf;
-}
-
-enum iap_status lpc_iap_call(struct lpc_flash *f, enum iap_cmd cmd, ...)
-{
-	target *t = f->f.t;
-	struct flash_param param = {
-		.opcode = ARM_THUMB_BREAKPOINT,
-		.command = cmd,
-	};
-
-	/* Pet WDT before each IAP call, if it is on */
-	if (f->wdt_kick)
-		f->wdt_kick(t);
-
-	/* fill out the remainder of the parameters */
-	va_list ap;
-	va_start(ap, cmd);
-	for (int i = 0; i < 4; i++)
-		param.words[i] = va_arg(ap, uint32_t);
-	va_end(ap);
-
-	/* copy the structure to RAM */
-	target_mem_write(t, f->iap_ram, &param, sizeof(param));
-
-	/* set up for the call to the IAP ROM */
-	uint32_t regs[t->regs_size / sizeof(uint32_t)];
-	target_regs_read(t, regs);
-	regs[0] = f->iap_ram + offsetof(struct flash_param, command);
-	regs[1] = f->iap_ram + offsetof(struct flash_param, result);
-	regs[REG_MSP] = f->iap_msp;
-	regs[REG_LR] = f->iap_ram | 1;
-	regs[REG_PC] = f->iap_entry;
-	target_regs_write(t, regs);
-
-	/* start the target and wait for it to halt again */
-	target_halt_resume(t, false);
-	while (!target_halt_poll(t, NULL));
-
-	/* copy back just the parameters structure */
-	target_mem_read(t, &param, f->iap_ram, sizeof(param));
-	return param.result;
-}
-
-static uint8_t lpc_sector_for_addr(struct lpc_flash *f, uint32_t addr)
-{
-	return f->base_sector + (addr - f->f.start) / f->f.blocksize;
-}
-
-int lpc_flash_erase(struct target_flash *tf, target_addr addr, size_t len)
-{
-	struct lpc_flash *f = (struct lpc_flash *)tf;
-	uint32_t start = lpc_sector_for_addr(f, addr);
-	uint32_t end = lpc_sector_for_addr(f, addr + len - 1);
-
-	if (lpc_iap_call(f, IAP_CMD_PREPARE, start, end, f->bank))
-		return -1;
-
-	/* and now erase them */
-	if (lpc_iap_call(f, IAP_CMD_ERASE, start, end, CPU_CLK_KHZ, f->bank))
-		return -2;
-
-	/* check erase ok */
-	if (lpc_iap_call(f, IAP_CMD_BLANKCHECK, start, end, f->bank))
-		return -3;
-
-	return 0;
-}
-
-int lpc_flash_write(struct target_flash *tf,
-                    target_addr dest, const void *src, size_t len)
-{
-	struct lpc_flash *f = (struct lpc_flash *)tf;
-	/* prepare... */
-	uint32_t sector = lpc_sector_for_addr(f, dest);
-	if (lpc_iap_call(f, IAP_CMD_PREPARE, sector, sector, f->bank))
-		return -1;
-
-	/* Write payload to target ram */
-	uint32_t bufaddr = ALIGN(f->iap_ram + sizeof(struct flash_param), 4);
-	target_mem_write(f->f.t, bufaddr, src, len);
-
-	/* set the destination address and program */
-	if (lpc_iap_call(f, IAP_CMD_PROGRAM, dest, bufaddr, len, CPU_CLK_KHZ))
-		return -2;
-
-	return 0;
-}
-
-int lpc_flash_write_magic_vect(struct target_flash *f,
-                               target_addr dest, const void *src, size_t len)
-{
-	if (dest == 0) {
-		/* Fill in the magic vector to allow booting the flash */
-		uint32_t *w = (uint32_t *)src;
-		uint32_t sum = 0;
-
-		for (unsigned i = 0; i < 7; i++)
-			sum += w[i];
-		w[7] = ~sum + 1;
-	}
-	return lpc_flash_write(f, dest, src, len);
-}
-
diff --git a/src/target/lpc_common.h b/src/target/lpc_common.h
deleted file mode 100644
index dd7dc88..0000000
--- a/src/target/lpc_common.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2016 Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef __LPC_COMMON_H
-#define __LPC_COMMON_H
-
-enum iap_cmd {
-	IAP_CMD_INIT = 49,
-	IAP_CMD_PREPARE = 50,
-	IAP_CMD_PROGRAM = 51,
-	IAP_CMD_ERASE = 52,
-	IAP_CMD_BLANKCHECK = 53,
-	IAP_CMD_SET_ACTIVE_BANK = 60,
-};
-
-enum iap_status {
-	IAP_STATUS_CMD_SUCCESS = 0,
-	IAP_STATUS_INVALID_COMMAND = 1,
-	IAP_STATUS_SRC_ADDR_ERROR = 2,
-	IAP_STATUS_DST_ADDR_ERROR = 3,
-	IAP_STATUS_SRC_ADDR_NOT_MAPPED = 4,
-	IAP_STATUS_DST_ADDR_NOT_MAPPED = 5,
-	IAP_STATUS_COUNT_ERROR = 6,
-	IAP_STATUS_INVALID_SECTOR = 7,
-	IAP_STATUS_SECTOR_NOT_BLANK = 8,
-	IAP_STATUS_SECTOR_NOT_PREPARED = 9,
-	IAP_STATUS_COMPARE_ERROR = 10,
-	IAP_STATUS_BUSY = 11,
-};
-
-/* CPU Frequency */
-#define CPU_CLK_KHZ 12000
-
-struct lpc_flash {
-	struct target_flash f;
-	uint8_t base_sector;
-	uint8_t bank;
-	/* Info filled in by specific driver */
-	void (*wdt_kick)(target *t);
-	uint32_t iap_entry;
-	uint32_t iap_ram;
-	uint32_t iap_msp;
-};
-
-struct lpc_flash *lpc_add_flash(target *t, target_addr addr, size_t length);
-enum iap_status lpc_iap_call(struct lpc_flash *f, enum iap_cmd cmd, ...);
-int lpc_flash_erase(struct target_flash *f, target_addr addr, size_t len);
-int lpc_flash_write(struct target_flash *f,
-                    target_addr dest, const void *src, size_t len);
-int lpc_flash_write_magic_vect(struct target_flash *f,
-                               target_addr dest, const void *src, size_t len);
-
-#endif
-
diff --git a/src/target/nrf51.c b/src/target/nrf51.c
deleted file mode 100644
index 91f1d43..0000000
--- a/src/target/nrf51.c
+++ /dev/null
@@ -1,335 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2014  Mike Walters <mike@flomp.net>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/* This file implements nRF51 target specific functions for detecting
- * the device, providing the XML memory map and Flash memory programming.
- */
-
-#include "general.h"
-#include "target.h"
-#include "target_internal.h"
-#include "cortexm.h"
-
-static int nrf51_flash_erase(struct target_flash *f, target_addr addr, size_t len);
-static int nrf51_flash_write(struct target_flash *f,
-                             target_addr dest, const void *src, size_t len);
-
-static bool nrf51_cmd_erase_all(target *t);
-static bool nrf51_cmd_read_hwid(target *t);
-static bool nrf51_cmd_read_fwid(target *t);
-static bool nrf51_cmd_read_deviceid(target *t);
-static bool nrf51_cmd_read_deviceaddr(target *t);
-static bool nrf51_cmd_read_help(target *t);
-static bool nrf51_cmd_read(target *t, int argc, const char *argv[]);
-
-const struct command_s nrf51_cmd_list[] = {
-	{"erase_mass", (cmd_handler)nrf51_cmd_erase_all, "Erase entire flash memory"},
-	{"read", (cmd_handler)nrf51_cmd_read, "Read device parameters"},
-	{NULL, NULL, NULL}
-};
-const struct command_s nrf51_read_cmd_list[] = {
-	{"help", (cmd_handler)nrf51_cmd_read_help, "Display help for read commands"},
-	{"hwid", (cmd_handler)nrf51_cmd_read_hwid, "Read hardware identification number"},
-	{"fwid", (cmd_handler)nrf51_cmd_read_fwid, "Read pre-loaded firmware ID"},
-	{"deviceid", (cmd_handler)nrf51_cmd_read_deviceid, "Read unique device ID"},
-	{"deviceaddr", (cmd_handler)nrf51_cmd_read_deviceaddr, "Read device address"},
-	{NULL, NULL, NULL}
-};
-
-/* Non-Volatile Memory Controller (NVMC) Registers */
-#define NRF51_NVMC					0x4001E000
-#define NRF51_NVMC_READY			(NRF51_NVMC + 0x400)
-#define NRF51_NVMC_CONFIG			(NRF51_NVMC + 0x504)
-#define NRF51_NVMC_ERASEPAGE		(NRF51_NVMC + 0x508)
-#define NRF51_NVMC_ERASEALL			(NRF51_NVMC + 0x50C)
-#define NRF51_NVMC_ERASEUICR		(NRF51_NVMC + 0x514)
-
-#define NRF51_NVMC_CONFIG_REN		0x0						// Read only access
-#define NRF51_NVMC_CONFIG_WEN		0x1						// Write enable
-#define NRF51_NVMC_CONFIG_EEN		0x2						// Erase enable
-
-/* Factory Information Configuration Registers (FICR) */
-#define NRF51_FICR				0x10000000
-#define NRF51_FICR_CODEPAGESIZE			(NRF51_FICR + 0x010)
-#define NRF51_FICR_CODESIZE			(NRF51_FICR + 0x014)
-#define NRF51_FICR_CONFIGID			(NRF51_FICR + 0x05C)
-#define NRF51_FICR_DEVICEID_LOW			(NRF51_FICR + 0x060)
-#define NRF51_FICR_DEVICEID_HIGH		(NRF51_FICR + 0x064)
-#define NRF51_FICR_DEVICEADDRTYPE		(NRF51_FICR + 0x0A0)
-#define NRF51_FICR_DEVICEADDR_LOW		(NRF51_FICR + 0x0A4)
-#define NRF51_FICR_DEVICEADDR_HIGH		(NRF51_FICR + 0x0A8)
-
-/* User Information Configuration Registers (UICR) */
-#define NRF51_UICR				0x10001000
-
-#define NRF51_PAGE_SIZE 1024
-#define NRF52_PAGE_SIZE 4096
-
-#define SRAM_BASE          0x20000000
-#define STUB_BUFFER_BASE   ALIGN(SRAM_BASE + sizeof(nrf51_flash_write_stub), 4)
-
-static const uint16_t nrf51_flash_write_stub[] = {
-#include "flashstub/nrf51.stub"
-};
-
-static void nrf51_add_flash(target *t,
-                            uint32_t addr, size_t length, size_t erasesize)
-{
-	struct target_flash *f = calloc(1, sizeof(*f));
-	f->start = addr;
-	f->length = length;
-	f->blocksize = erasesize;
-	f->erase = nrf51_flash_erase;
-	f->write = nrf51_flash_write;
-	f->align = 4;
-	f->erased = 0xff;
-	target_add_flash(t, f);
-}
-
-bool nrf51_probe(target *t)
-{
-	t->idcode = target_mem_read32(t, NRF51_FICR_CONFIGID) & 0xFFFF;
-
-	switch (t->idcode) {
-	case 0x001D: /* nRF51822 (rev 1) QFAA CA/C0 */
-	case 0x001E: /* nRF51422 (rev 1) QFAA CA */
-	case 0x0020: /* nRF51822 (rev 1) CEAA BA */
-	case 0x0024: /* nRF51422 (rev 1) QFAA C0 */
-	case 0x002A: /* nRF51822 (rev 2) QFAA FA0 */
-	case 0x004A: /* nRF51822 (rev 3) QFAA G1 */ 			
-	case 0x002D: /* nRF51422 (rev 2) QFAA DAA */
-	case 0x002E: /* nRF51422 (rev 2) QFAA E0 */
-	case 0x002F: /* nRF51822 (rev 1) CEAA B0 */
-	case 0x0031: /* nRF51422 (rev 1) CEAA A0A */
-	case 0x003C: /* nRF51822 (rev 2) QFAA G0 */
-	case 0x0057: /* nRF51422 (rev 2) QFAA G2 */
-	case 0x0040: /* nRF51822 (rev 2) CEAA CA0 */
-	case 0x0044: /* nRF51822 (rev 2) QFAA GC0 */
-	case 0x0047: /* nRF51822 (rev 2) CEAA DA0 */
-	case 0x004D: /* nRF51822 (rev 2) CEAA D00 */
-	case 0x0050: /* nRF51422 (rev 2) CEAA B0 */
-	case 0x0072: /* nRF51822 (rev 3) QFAA H0 */
-	case 0x0073: /* nRF51422 (rev 3) QFAA F0 */
-	case 0x0079: /* nRF51822 (rev 3) CEAA E0 */
-	case 0x007A: /* nRF51422 (rev 3) CEAA C0 */
-	case 0x008F: /* nRF51822 (rev 3) QFAA H1 See https://devzone.nordicsemi.com/question/97769/can-someone-conform-the-config-id-code-for-the-nrf51822qfaah1/ */
-	case 0x00D1: /* nRF51822 (rev 3) QFAA H2 */		
-		t->driver = "Nordic nRF51";
-		target_add_ram(t, 0x20000000, 0x4000);
-		nrf51_add_flash(t, 0x00000000, 0x40000, NRF51_PAGE_SIZE);
-		nrf51_add_flash(t, NRF51_UICR, 0x100, 0x100);
-		target_add_commands(t, nrf51_cmd_list, "nRF51");
-		return true;
-	case 0x0026: /* nRF51822 (rev 1) QFAB AA */
-	case 0x0027: /* nRF51822 (rev 1) QFAB A0 */
-	case 0x004C: /* nRF51822 (rev 2) QFAB B0 */
-	case 0x0061: /* nRF51422 (rev 2) QFAB A00 */
-	case 0x007B: /* nRF51822 (rev 3) QFAB C0 */
-	case 0x007C: /* nRF51422 (rev 3) QFAB B0 */
-	case 0x007D: /* nRF51822 (rev 3) CDAB A0 */
-	case 0x007E: /* nRF51422 (rev 3) CDAB A0 */
-		t->driver = "Nordic nRF51";
-		target_add_ram(t, 0x20000000, 0x4000);
-		nrf51_add_flash(t, 0x00000000, 0x20000, NRF51_PAGE_SIZE);
-		nrf51_add_flash(t, NRF51_UICR, 0x100, 0x100);
-		target_add_commands(t, nrf51_cmd_list, "nRF51");
-		return true;
-	case 0x0071: /* nRF51422 (rev 3) QFAC AB */
-	case 0x0083: /* nRF51822 (rev 3) QFAC A0 */
-	case 0x0084: /* nRF51422 (rev 3) QFAC A1 */
-	case 0x0085: /* nRF51422 (rev 3) QFAC A0 */
-	case 0x0086: /* nRF51422 (rev 3) QFAC A1 */
-	case 0x0087: /* nRF51822 (rev 3) CFAC A0 */
-	case 0x0088: /* nRF51422 (rev 3) CFAC A0 */
-		t->driver = "Nordic nRF51";
-		target_add_ram(t, 0x20000000, 0x8000);
-		nrf51_add_flash(t, 0x00000000, 0x40000, NRF51_PAGE_SIZE);
-		nrf51_add_flash(t, NRF51_UICR, 0x100, 0x100);
-		target_add_commands(t, nrf51_cmd_list, "nRF51");
-		return true;
-	case 0x00AC: /* nRF52832 Preview QFAA BA0 */
-	case 0x00C7: /* nRF52832 Revision 1 QFAA B00 */
-		t->driver = "Nordic nRF52";
-		target_add_ram(t, 0x20000000, 64*1024);
-		nrf51_add_flash(t, 0x00000000, 512*1024, NRF52_PAGE_SIZE);
-		nrf51_add_flash(t, NRF51_UICR, 0x100, 0x100);
-		target_add_commands(t, nrf51_cmd_list, "nRF52");
-		return true;
-	case 0x00EB: /* nRF52840 Preview QIAA AA0 */
-		t->driver = "Nordic nRF52";
-		target_add_ram(t, 0x20000000, 256*1024);
-		nrf51_add_flash(t, 0x00000000, 1024*1024, NRF52_PAGE_SIZE);
-		nrf51_add_flash(t, NRF51_UICR, 0x100, 0x100);
-		target_add_commands(t, nrf51_cmd_list, "nRF52");
-		return true;
-	}
-
-	return false;
-}
-
-static int nrf51_flash_erase(struct target_flash *f, target_addr addr, size_t len)
-{
-	target *t = f->t;
-	/* Enable erase */
-	target_mem_write32(t, NRF51_NVMC_CONFIG, NRF51_NVMC_CONFIG_EEN);
-
-	/* Poll for NVMC_READY */
-	while (target_mem_read32(t, NRF51_NVMC_READY) == 0)
-		if(target_check_error(t))
-			return -1;
-
-	while (len) {
-		if (addr == NRF51_UICR) { // Special Case
-			/* Write to the ERASE_UICR register to erase */
-			target_mem_write32(t, NRF51_NVMC_ERASEUICR, 0x1);
-
-		} else { // Standard Flash Page
-			/* Write address of first word in page to erase it */
-			target_mem_write32(t, NRF51_NVMC_ERASEPAGE, addr);
-		}
-
-		/* Poll for NVMC_READY */
-		while (target_mem_read32(t, NRF51_NVMC_READY) == 0)
-			if(target_check_error(t))
-				return -1;
-
-		addr += f->blocksize;
-		len -= f->blocksize;
-	}
-
-	/* Return to read-only */
-	target_mem_write32(t, NRF51_NVMC_CONFIG, NRF51_NVMC_CONFIG_REN);
-
-	/* Poll for NVMC_READY */
-	while (target_mem_read32(t, NRF51_NVMC_READY) == 0)
-		if(target_check_error(t))
-			return -1;
-
-	return 0;
-}
-
-static int nrf51_flash_write(struct target_flash *f,
-                             target_addr dest, const void *src, size_t len)
-{
-	target *t = f->t;
-
-	/* Enable write */
-	target_mem_write32(t, NRF51_NVMC_CONFIG, NRF51_NVMC_CONFIG_WEN);
-
-	/* Poll for NVMC_READY */
-	while (target_mem_read32(t, NRF51_NVMC_READY) == 0)
-		if(target_check_error(t))
-			return -1;
-
-	/* Write stub and data to target ram and call stub */
-	target_mem_write(t, SRAM_BASE, nrf51_flash_write_stub,
-	                 sizeof(nrf51_flash_write_stub));
-	target_mem_write(t, STUB_BUFFER_BASE, src, len);
-	int ret = cortexm_run_stub(t, SRAM_BASE, dest,
-	                           STUB_BUFFER_BASE, len, 0);
-	/* Return to read-only */
-	target_mem_write32(t, NRF51_NVMC_CONFIG, NRF51_NVMC_CONFIG_REN);
-
-	return ret;
-}
-
-static bool nrf51_cmd_erase_all(target *t)
-{
-	tc_printf(t, "erase..\n");
-
-	/* Enable erase */
-	target_mem_write32(t, NRF51_NVMC_CONFIG, NRF51_NVMC_CONFIG_EEN);
-
-	/* Poll for NVMC_READY */
-	while (target_mem_read32(t, NRF51_NVMC_READY) == 0)
-		if(target_check_error(t))
-			return false;
-
-	/* Erase all */
-	target_mem_write32(t, NRF51_NVMC_ERASEALL, 1);
-
-	/* Poll for NVMC_READY */
-	while (target_mem_read32(t, NRF51_NVMC_READY) == 0)
-		if(target_check_error(t))
-			return false;
-
-	return true;
-}
-
-static bool nrf51_cmd_read_hwid(target *t)
-{
-	uint32_t hwid = target_mem_read32(t, NRF51_FICR_CONFIGID) & 0xFFFF;
-	tc_printf(t, "Hardware ID: 0x%04X\n", hwid);
-
-	return true;
-}
-static bool nrf51_cmd_read_fwid(target *t)
-{
-	uint32_t fwid = (target_mem_read32(t, NRF51_FICR_CONFIGID) >> 16) & 0xFFFF;
-	tc_printf(t, "Firmware ID: 0x%04X\n", fwid);
-
-	return true;
-}
-static bool nrf51_cmd_read_deviceid(target *t)
-{
-	uint32_t deviceid_low = target_mem_read32(t, NRF51_FICR_DEVICEID_LOW);
-	uint32_t deviceid_high = target_mem_read32(t, NRF51_FICR_DEVICEID_HIGH);
-
-	tc_printf(t, "Device ID: 0x%08X%08X\n", deviceid_high, deviceid_low);
-
-	return true;
-}
-static bool nrf51_cmd_read_deviceaddr(target *t)
-{
-	uint32_t addr_type = target_mem_read32(t, NRF51_FICR_DEVICEADDRTYPE);
-	uint32_t addr_low = target_mem_read32(t, NRF51_FICR_DEVICEADDR_LOW);
-	uint32_t addr_high = target_mem_read32(t, NRF51_FICR_DEVICEADDR_HIGH) & 0xFFFF;
-
-	if ((addr_type & 1) == 0) {
-		tc_printf(t, "Publicly Listed Address: 0x%04X%08X\n", addr_high, addr_low);
-	} else {
-		tc_printf(t, "Randomly Assigned Address: 0x%04X%08X\n", addr_high, addr_low);
-	}
-
-	return true;
-}
-static bool nrf51_cmd_read_help(target *t)
-{
-	const struct command_s *c;
-
-	tc_printf(t, "Read commands:\n");
-	for(c = nrf51_read_cmd_list; c->cmd; c++)
-		tc_printf(t, "\t%s -- %s\n", c->cmd, c->help);
-
-	return true;
-}
-static bool nrf51_cmd_read(target *t, int argc, const char *argv[])
-{
-	const struct command_s *c;
-
-	for(c = nrf51_read_cmd_list; c->cmd; c++) {
-		/* Accept a partial match as GDB does.
-		 * So 'mon ver' will match 'monitor version'
-		 */
-		if(!strncmp(argv[1], c->cmd, strlen(argv[1])))
-			return !c->handler(t, argc - 1, &argv[1]);
-	}
-
-	return nrf51_cmd_read_help(t);
-}
diff --git a/src/target/sam3x.c b/src/target/sam3x.c
deleted file mode 100644
index 0a96308..0000000
--- a/src/target/sam3x.c
+++ /dev/null
@@ -1,358 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2015  Black Sphere Technologies Ltd.
- * Written by Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/* This file implements Atmel SAM3/4 target specific functions for detecting
- * the device, providing the XML memory map and Flash memory programming.
- *
- * Supported devices: SAM3N, SAM3S, SAM3U, SAM3X, and SAM4S
- */
-
-#include "general.h"
-#include "target.h"
-#include "target_internal.h"
-
-static int sam4_flash_erase(struct target_flash *f, target_addr addr, size_t len);
-static int sam3_flash_erase(struct target_flash *f, target_addr addr, size_t len);
-static int sam3x_flash_write(struct target_flash *f, target_addr dest,
-                             const void *src, size_t len);
-
-static bool sam3x_cmd_gpnvm_get(target *t);
-static bool sam3x_cmd_gpnvm_set(target *t, int argc, char *argv[]);
-
-const struct command_s sam3x_cmd_list[] = {
-	{"gpnvm_get", (cmd_handler)sam3x_cmd_gpnvm_get, "Get GPVNM value"},
-	{"gpnvm_set", (cmd_handler)sam3x_cmd_gpnvm_set, "Set GPVNM bit"},
-	{NULL, NULL, NULL}
-};
-
-/* Enhanced Embedded Flash Controller (EEFC) Register Map */
-#define SAM3N_EEFC_BASE 	0x400E0A00
-#define SAM3X_EEFC_BASE(x)	(0x400E0A00+((x)*0x400))
-#define SAM3U_EEFC_BASE(x)	(0x400E0800+((x)*0x200))
-#define SAM4S_EEFC_BASE(x)	(0x400E0A00+((x)*0x200))
-#define EEFC_FMR(base)		((base)+0x00)
-#define EEFC_FCR(base)		((base)+0x04)
-#define EEFC_FSR(base)		((base)+0x08)
-#define EEFC_FRR(base)		((base)+0x0C)
-
-#define EEFC_FCR_FKEY		(0x5A << 24)
-#define EEFC_FCR_FCMD_GETD	0x00
-#define EEFC_FCR_FCMD_WP	0x01
-#define EEFC_FCR_FCMD_WPL	0x02
-#define EEFC_FCR_FCMD_EWP	0x03
-#define EEFC_FCR_FCMD_EWPL	0x04
-#define EEFC_FCR_FCMD_EA	0x05
-#define EEFC_FCR_FCMD_EPA	0x07
-#define EEFC_FCR_FCMD_SLB	0x08
-#define EEFC_FCR_FCMD_CLB	0x09
-#define EEFC_FCR_FCMD_GLB	0x0A
-#define EEFC_FCR_FCMD_SGPB	0x0B
-#define EEFC_FCR_FCMD_CGPB	0x0C
-#define EEFC_FCR_FCMD_GGPB	0x0D
-#define EEFC_FCR_FCMD_STUI	0x0E
-#define EEFC_FCR_FCMD_SPUI	0x0F
-
-#define EEFC_FSR_FRDY		(1 << 0)
-#define EEFC_FSR_FCMDE		(1 << 1)
-#define EEFC_FSR_FLOCKE		(1 << 2)
-#define EEFC_FSR_ERROR		(EEFC_FSR_FCMDE | EEFC_FSR_FLOCKE)
-
-#define SAM3X_CHIPID_CIDR	0x400E0940
-#define SAM34NSU_CHIPID_CIDR	0x400E0740
-
-#define CHIPID_CIDR_VERSION_MASK	(0x1F << 0)
-#define CHIPID_CIDR_EPROC_CM3		(0x03 << 5)
-#define CHIPID_CIDR_EPROC_CM4		(0x07 << 5)
-#define CHIPID_CIDR_EPROC_MASK		(0x07 << 5)
-#define CHIPID_CIDR_NVPSIZ_MASK		(0x0F << 8)
-#define CHIPID_CIDR_NVPSIZ_8K		(0x01 << 8)
-#define CHIPID_CIDR_NVPSIZ_16K		(0x02 << 8)
-#define CHIPID_CIDR_NVPSIZ_32K		(0x03 << 8)
-#define CHIPID_CIDR_NVPSIZ_64K		(0x05 << 8)
-#define CHIPID_CIDR_NVPSIZ_128K		(0x07 << 8)
-#define CHIPID_CIDR_NVPSIZ_256K		(0x09 << 8)
-#define CHIPID_CIDR_NVPSIZ_512K		(0x0A << 8)
-#define CHIPID_CIDR_NVPSIZ_1024K	(0x0C << 8)
-#define CHIPID_CIDR_NVPSIZ_2048K	(0x0E << 8)
-#define CHIPID_CIDR_NVPSIZ2_MASK	(0x0F << 12)
-#define CHIPID_CIDR_SRAMSIZ_MASK	(0x0F << 16)
-#define CHIPID_CIDR_ARCH_MASK		(0xFF << 20)
-#define CHIPID_CIDR_ARCH_SAM3UxC	(0x80 << 20)
-#define CHIPID_CIDR_ARCH_SAM3UxE	(0x81 << 20)
-#define CHIPID_CIDR_ARCH_SAM3XxC	(0x84 << 20)
-#define CHIPID_CIDR_ARCH_SAM3XxE	(0x85 << 20)
-#define CHIPID_CIDR_ARCH_SAM3XxG	(0x86 << 20)
-#define CHIPID_CIDR_ARCH_SAM3NxA	(0x93 << 20)
-#define CHIPID_CIDR_ARCH_SAM3NxB	(0x94 << 20)
-#define CHIPID_CIDR_ARCH_SAM3NxC	(0x95 << 20)
-#define CHIPID_CIDR_ARCH_SAM3SxA	(0x88 << 20)
-#define CHIPID_CIDR_ARCH_SAM3SxB	(0x89 << 20)
-#define CHIPID_CIDR_ARCH_SAM3SxC	(0x8A << 20)
-#define CHIPID_CIDR_ARCH_SAM4SxA	(0x88 << 20)
-#define CHIPID_CIDR_ARCH_SAM4SxB	(0x89 << 20)
-#define CHIPID_CIDR_ARCH_SAM4SxC	(0x8A << 20)
-#define CHIPID_CIDR_NVPTYP_MASK		(0x07 << 28)
-#define CHIPID_CIDR_NVPTYP_FLASH	(0x02 << 28)
-#define CHIPID_CIDR_NVPTYP_ROM_FLASH	(0x03 << 28)
-#define CHIPID_CIDR_EXT			(0x01 << 31)
-
-#define SAM3_PAGE_SIZE 256
-#define SAM4_PAGE_SIZE 512
-
-struct sam_flash {
-	struct target_flash f;
-	uint32_t eefc_base;
-	uint8_t write_cmd;
-};
-
-static void sam3_add_flash(target *t,
-                           uint32_t eefc_base, uint32_t addr, size_t length)
-{
-	struct sam_flash *sf = calloc(1, sizeof(*sf));
-	struct target_flash *f = &sf->f;
-	f->start = addr;
-	f->length = length;
-	f->blocksize = SAM3_PAGE_SIZE;
-	f->erase = sam3_flash_erase;
-	f->write = target_flash_write_buffered;
-	f->done = target_flash_done_buffered;
-	f->write_buf = sam3x_flash_write;
-	f->buf_size = SAM3_PAGE_SIZE;
-	sf->eefc_base = eefc_base;
-	sf->write_cmd = EEFC_FCR_FCMD_EWP;
-	target_add_flash(t, f);
-}
-
-static void sam4_add_flash(target *t,
-                           uint32_t eefc_base, uint32_t addr, size_t length)
-{
-	struct sam_flash *sf = calloc(1, sizeof(*sf));
-	struct target_flash *f = &sf->f;
-	f->start = addr;
-	f->length = length;
-	f->blocksize = SAM4_PAGE_SIZE * 8;
-	f->erase = sam4_flash_erase;
-	f->write = target_flash_write_buffered;
-	f->done = target_flash_done_buffered;
-	f->write_buf = sam3x_flash_write;
-	f->buf_size = SAM4_PAGE_SIZE;
-	sf->eefc_base = eefc_base;
-	sf->write_cmd = EEFC_FCR_FCMD_WP;
-	target_add_flash(t, f);
-}
-
-static size_t sam_flash_size(uint32_t idcode)
-{
-	switch (idcode & CHIPID_CIDR_NVPSIZ_MASK) {
-	case CHIPID_CIDR_NVPSIZ_8K:
-		return 0x2000;
-	case CHIPID_CIDR_NVPSIZ_16K:
-		return 0x4000;
-	case CHIPID_CIDR_NVPSIZ_32K:
-		return 0x8000;
-	case CHIPID_CIDR_NVPSIZ_64K:
-		return 0x10000;
-	case CHIPID_CIDR_NVPSIZ_128K:
-		return 0x20000;
-	case CHIPID_CIDR_NVPSIZ_256K:
-		return 0x40000;
-	case CHIPID_CIDR_NVPSIZ_512K:
-		return 0x80000;
-	case CHIPID_CIDR_NVPSIZ_1024K:
-		return 0x100000;
-	case CHIPID_CIDR_NVPSIZ_2048K:
-		return 0x200000;
-	}
-	return 0;
-}
-
-bool sam3x_probe(target *t)
-{
-	t->idcode = target_mem_read32(t, SAM3X_CHIPID_CIDR);
-	size_t size = sam_flash_size(t->idcode);
-	switch (t->idcode & (CHIPID_CIDR_ARCH_MASK | CHIPID_CIDR_EPROC_MASK)) {
-	case CHIPID_CIDR_ARCH_SAM3XxC | CHIPID_CIDR_EPROC_CM3:
-	case CHIPID_CIDR_ARCH_SAM3XxE | CHIPID_CIDR_EPROC_CM3:
-	case CHIPID_CIDR_ARCH_SAM3XxG | CHIPID_CIDR_EPROC_CM3:
-		t->driver = "Atmel SAM3X";
-		target_add_ram(t, 0x20000000, 0x200000);
-		/* 2 Flash memories back-to-back starting at 0x80000 */
-		sam3_add_flash(t, SAM3X_EEFC_BASE(0), 0x80000, size/2);
-		sam3_add_flash(t, SAM3X_EEFC_BASE(1), 0x80000 + size/2, size/2);
-		target_add_commands(t, sam3x_cmd_list, "SAM3X");
-		return true;
-	}
-
-	t->idcode = target_mem_read32(t, SAM34NSU_CHIPID_CIDR);
-	size = sam_flash_size(t->idcode);
-	switch (t->idcode & (CHIPID_CIDR_ARCH_MASK | CHIPID_CIDR_EPROC_MASK)) {
-	case CHIPID_CIDR_ARCH_SAM3NxA | CHIPID_CIDR_EPROC_CM3:
-	case CHIPID_CIDR_ARCH_SAM3NxB | CHIPID_CIDR_EPROC_CM3:
-	case CHIPID_CIDR_ARCH_SAM3NxC | CHIPID_CIDR_EPROC_CM3:
-	case CHIPID_CIDR_ARCH_SAM3SxA | CHIPID_CIDR_EPROC_CM3:
-	case CHIPID_CIDR_ARCH_SAM3SxB | CHIPID_CIDR_EPROC_CM3:
-	case CHIPID_CIDR_ARCH_SAM3SxC | CHIPID_CIDR_EPROC_CM3:
-		t->driver = "Atmel SAM3N/S";
-		target_add_ram(t, 0x20000000, 0x200000);
-		/* These devices only have a single bank */
-		size = sam_flash_size(t->idcode);
-		sam3_add_flash(t, SAM3N_EEFC_BASE, 0x400000, size);
-		target_add_commands(t, sam3x_cmd_list, "SAM3N/S");
-		return true;
-	case CHIPID_CIDR_ARCH_SAM3UxC | CHIPID_CIDR_EPROC_CM3:
-	case CHIPID_CIDR_ARCH_SAM3UxE | CHIPID_CIDR_EPROC_CM3:
-		t->driver = "Atmel SAM3U";
-		target_add_ram(t, 0x20000000, 0x200000);
-		/* One flash up to 512K at 0x80000 */
-		sam3_add_flash(t, SAM3U_EEFC_BASE(0), 0x80000, MIN(size, 0x80000));
-		if (size >= 0x80000) {
-			/* Larger devices have a second bank at 0x100000 */
-			sam3_add_flash(t, SAM3U_EEFC_BASE(1),
-			               0x100000, 0x80000);
-		}
-		target_add_commands(t, sam3x_cmd_list, "SAM3U");
-		return true;
-	case CHIPID_CIDR_ARCH_SAM4SxA | CHIPID_CIDR_EPROC_CM4:
-	case CHIPID_CIDR_ARCH_SAM4SxB | CHIPID_CIDR_EPROC_CM4:
-	case CHIPID_CIDR_ARCH_SAM4SxC | CHIPID_CIDR_EPROC_CM4:
-		t->driver = "Atmel SAM4S";
-		target_add_ram(t, 0x20000000, 0x400000);
-		size_t size = sam_flash_size(t->idcode);
-		if (size <= 0x80000) {
-			/* Smaller devices have a single bank */
-			sam4_add_flash(t, SAM4S_EEFC_BASE(0), 0x400000, size);
-		} else {
-			/* Larger devices are split evenly between 2 */
-			sam4_add_flash(t, SAM4S_EEFC_BASE(0), 0x400000, size/2);
-			sam4_add_flash(t, SAM4S_EEFC_BASE(1),
-			               0x400000 + size/2, size/2);
-		}
-		target_add_commands(t, sam3x_cmd_list, "SAM4S");
-		return true;
-	}
-
-	return false;
-}
-
-static int
-sam3x_flash_cmd(target *t, uint32_t base, uint8_t cmd, uint16_t arg)
-{
-	DEBUG("%s: base = 0x%08"PRIx32" cmd = 0x%02X, arg = 0x%06X\n",
-		__func__, base, cmd, arg);
-	target_mem_write32(t, EEFC_FCR(base),
-	                   EEFC_FCR_FKEY | cmd | ((uint32_t)arg << 8));
-
-	while (!(target_mem_read32(t, EEFC_FSR(base)) & EEFC_FSR_FRDY))
-		if(target_check_error(t))
-			return -1;
-
-	uint32_t sr = target_mem_read32(t, EEFC_FSR(base));
-	return sr & EEFC_FSR_ERROR;
-}
-
-static uint32_t sam3x_flash_base(target *t)
-{
-	if (strcmp(t->driver, "Atmel SAM3X") == 0) {
-		return SAM3X_EEFC_BASE(0);
-	}
-	if (strcmp(t->driver, "Atmel SAM3U") == 0) {
-		return SAM3U_EEFC_BASE(0);
-	}
-	if (strcmp(t->driver, "Atmel SAM4S") == 0) {
-		return SAM4S_EEFC_BASE(0);
-	}
-	return SAM3N_EEFC_BASE;
-}
-
-static int sam4_flash_erase(struct target_flash *f, target_addr addr, size_t len)
-{
-	target *t = f->t;
-	uint32_t base = ((struct sam_flash *)f)->eefc_base;
-	uint32_t offset = addr - f->start;
-
-	/* The SAM4S is the only supported device with a page erase command.
-	 * Erasing is done in 8-page chunks. arg[15:2] contains the page
-	 * number and arg[1:0] contains 0x1, indicating 8-page chunks.
-	 */
-	unsigned chunk = offset / SAM4_PAGE_SIZE;
-
-	while (len) {
-		int16_t arg = chunk | 0x1;
-		if(sam3x_flash_cmd(t, base, EEFC_FCR_FCMD_EPA, arg))
-			return -1;
-
-		len -= f->blocksize;
-		chunk += 8;
-	}
-	return 0;
-}
-
-static int sam3_flash_erase(struct target_flash *f, target_addr addr, size_t len)
-{
-	/* The SAM3X/SAM3N don't really have a page erase function.
-	 * We do nothing here and use Erase/Write page in flash_write.
-	 */
-	(void)f; (void)addr; (void)len;
-	return 0;
-}
-
-static int sam3x_flash_write(struct target_flash *f, target_addr dest,
-                             const void *src, size_t len)
-{
-	target *t = f->t;
-	struct sam_flash *sf = (struct sam_flash *)f;
-	uint32_t base = sf->eefc_base;
-	unsigned chunk = (dest - f->start) / f->buf_size;
-
-	target_mem_write(t, dest, src, len);
-	if(sam3x_flash_cmd(t, base, sf->write_cmd, chunk))
-		return -1;
-
-	return 0;
-}
-
-static bool sam3x_cmd_gpnvm_get(target *t)
-{
-	uint32_t base = sam3x_flash_base(t);
-
-	sam3x_flash_cmd(t, base, EEFC_FCR_FCMD_GGPB, 0);
-	tc_printf(t, "GPNVM: 0x%08X\n", target_mem_read32(t, EEFC_FRR(base)));
-
-	return true;
-}
-
-static bool sam3x_cmd_gpnvm_set(target *t, int argc, char *argv[])
-{
-	uint32_t bit, cmd;
-	uint32_t base = sam3x_flash_base(t);
-
-	if (argc != 3) {
-		tc_printf(t, "usage: monitor gpnvm_set <bit> <val>\n");
-		return false;
-	}
-	bit = atol(argv[1]);
-	cmd = atol(argv[2]) ? EEFC_FCR_FCMD_SGPB : EEFC_FCR_FCMD_CGPB;
-
-	sam3x_flash_cmd(t, base, cmd, bit);
-	sam3x_cmd_gpnvm_get(t);
-
-	return true;
-}
-
diff --git a/src/target/sam4l.c b/src/target/sam4l.c
deleted file mode 100644
index cdb9072..0000000
--- a/src/target/sam4l.c
+++ /dev/null
@@ -1,398 +0,0 @@
-/*
- *
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2016  Chuck McManis <cmcmanis@mcmanis.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/* This file implements Atmel SAM4 target specific functions for detecting
- * the device, providing the XML memory map and Flash memory programming.
- *
- * Supported devices: SAM4L2, SAM4L4, SAM4L8
- */
-
-#include "general.h"
-#include "target.h"
-#include "target_internal.h"
-#include "cortexm.h"
-
-/*
- * Flash Controller defines
- */
-#define FLASHCALW_BASE				0x400A0000
-
-/* Flash Control Register */
-#define	FLASHCALW_FCR				(FLASHCALW_BASE + 0x00)
-#define	FLASHALCW_FCR_WS1OPT		(1 << 7)
-#define	FLASHALCW_FCR_FWS			(1 << 6)
-#define	FLASHALCW_FCR_ECCE			(1 << 4)
-#define	FLASHALCW_FCR_PROGE			(1 << 3)
-#define	FLASHALCW_FCR_LOCKE			(1 << 2)
-#define	FLASHALCW_FCR_FRDY			(1 << 0)
-
-/* Flash Command Register */
-#define	FLASHCALW_FCMD				(FLASHCALW_BASE + 0x04)
-#define FLASHCALW_FCMD_KEY_MASK		0xff
-#define FLASHCALW_FCMD_KEY_SHIFT	24
-#define FLASHCALW_FCMD_PAGEN_MASK	0xffff
-#define FLASHCALW_FCMD_PAGEN_SHIFT	8
-#define FLASHCALW_FCMD_CMD_MASK		0x3f
-#define FLASHCALW_FCMD_CMD_SHIFT	0
-
-#define FLASH_CMD_NOP		0
-#define FLASH_CMD_WP		1	/* Write Page */
-#define FLASH_CMD_EP		2	/* Erase Page */
-#define FLASH_CMD_CPB		3	/* Clear Page Buffer */
-#define FLASH_CMD_LP		4	/* Lock page region */
-#define FLASH_CMD_UP		5	/* Unlock page region */
-#define FLASH_CMD_EA		6	/* Erase All */
-#define FLASH_CMD_WGPB		7	/* Write General Purpose Fuse Bit */
-#define FLASH_CMD_EGPB		8	/* Erase General Purpose Fuse Bit */
-#define FLASH_CMD_SSB		9	/* Set Security Fuses */
-#define FLASH_CMD_PGPFB		10	/* Program General Purpose Fuse Byte */
-#define FLASH_CMD_EAGPF		11	/* Erase All GP Fuses */
-#define FLASH_CMD_QPR		12	/* Quick Page Read (erase check) */
-#define FLASH_CMD_WUP		13	/* Write User Page */
-#define FLASH_CMD_EUP		14	/* Erase User Page */
-#define FLASH_CMD_QPRUP		15	/* Quick Page Read User Page */
-#define FLASH_CMD_HSEN		16	/* High Speed Enable */
-#define FLASH_CMD_HSDIS		17	/* High Speed Disable */
-
-/* Flash Status Register */
-#define FLASHCALW_FSR				(FLASHCALW_BASE + 0x08)
-#define FLASHCALW_FSR_LOCK(x)		(1 << (16 + (x)))
-#define FLASHCALW_FSR_ECCERR		(1 << 9)
-#define FLASHCALW_FSR_ECCERR2		(1 << 8)
-#define FLASHCALW_FSR_HSMODE		(1 << 6)
-#define FLASHCALW_FSR_QPRR			(1 << 5)
-#define FLASHCALW_FSR_SECURITY		(1 << 4)
-#define FLASHCALW_FSR_PROGE			(1 << 3)
-#define FLASHCALW_FSR_LOCKE			(1 << 2)
-#define FLASHCALW_FSR_FRDY			(1 << 0)
-
-/* Flash Parameter Register */
-#define FLASHCALW_FPR				(FLASHCALW_BASE + 0x0a)
-#define FLASHCALW_FPR_PSZ_MASK		0x7	/* page size */
-#define FLASHCALW_FPR_PSZ_SHIFT		8
-#define FLASHCALW_FPR_FSZ_MASK		0xf	/* flash size */
-#define FLASHCALW_FPR_FSZ_SHIFT		0
-
-/* Flash Version Register */
-#define FLASHCALW_FVR				(FLASHCALW_BASE + 0x10)
-#define FLASHCALW_FVR_VARIANT_MASK	0xf
-#define FLASHCALW_FVR_VARIANT_SHIFT	16
-#define FLASHCALW_FVR_VERSION_MASK	0xfff
-#define FLASHCALW_FVR_VERSION_SHIFT	0
-
-/* Flash General Purpose Registers (high) */
-#define FLASHCALW_FGPFRHI			(FLASHCALW_BASE + 0x14)
-/* Flash General Purpose Registers (low) */
-#define FLASHCALW_FGPFRLO			(FLASHCALW_BASE + 0x18)
-
-static void sam4l_extended_reset(target *t);
-static int sam4l_flash_erase(struct target_flash *f, target_addr addr, size_t len);
-static int sam4l_flash_write_buf(struct target_flash *f, target_addr dest,
-									const void *src, size_t len);
-
-/* why Atmel couldn't make it sequential ... */
-static const size_t __ram_size[16] = {
-	48 * 1024,		/*  0: 48K */
-	1 * 1024,		/*  1: 1K */
-	2 * 1024,		/*  2: 2K */
-	6 * 1024,		/*  3: 6K */
-	24 * 1024,		/*  4: 24K */
-	4 * 1024,		/*  5: 4K */
-	80 * 1024,		/*  6: 80K */
-	160 * 1024,		/*  7: 160K */
-	8 * 1024,		/*  8: 8K */
-	16 * 1024,		/*  9: 16K */
-	32 * 1024,		/* 10: 32K */
-	64 * 1024,		/* 11: 64K */
-	128 * 1024,		/* 12: 128K */
-	256 * 1024,		/* 13: 256K */
-	96 * 1024,		/* 14: 96K */
-	512 * 1024		/* 15: 512K */
-};
-
-static const size_t __nvp_size[16] = {
-	0,				/*  0: none */
-	8 * 1024,		/*  1: 8K */
-	16 * 1024,		/*  2: 16K */
-	32 * 1024,		/*  3: 32K */
-	0,				/*  4: reserved */
-	64 * 1024,		/*  5: 64K */
-	0,				/*  6: reserved */
-	128 * 1024,		/*  7: 128K */
-	0,				/*  8: reserved */
-	256 * 1024,		/*  9: 256K */
-	512 * 1024,		/* 10: 512K */
-	0,				/* 11: reserved */
-	1024 * 1024,	/* 12: 1024K (1M) */
-	0,				/* 13: reserved */
-	2048 * 1024,	/* 14: 2048K (2M) */
-	0				/* 15: reserved */
-};
-
-
-/* All variants of 4L have a 512 byte page */
-#define SAM4L_PAGE_SIZE 512
-#define SAM4L_ARCH		0xb0
-#define SAM4L_CHIPID_CIDR	0x400E0740
-#define CHIPID_CIDR_ARCH_MASK		0xff
-#define CHIPID_CIDR_ARCH_SHIFT		20
-#define CHIPID_CIDR_SRAMSIZ_MASK	0xf
-#define CHIPID_CIDR_SRAMSIZ_SHIFT	16
-#define CHIPID_CIDR_NVPSIZ_MASK		0xf
-#define CHIPID_CIDR_NVPSIZ_SHIFT	8
-
-
-/* Arbitrary time to wait for FLASH controller to be ready */
-#define FLASH_TIMEOUT	10000
-
-/*
- * Populate a target_flash struct with the necessary function pointers
- * and constants to describe our flash.
- */
-static void sam4l_add_flash(target *t, uint32_t addr, size_t length)
-{
-	struct target_flash *f = calloc(1, sizeof(struct target_flash));
-	f->start = addr;
-	f->length = length;
-	f->blocksize = SAM4L_PAGE_SIZE;
-	f->erase = sam4l_flash_erase;
-	f->write = target_flash_write_buffered;
-	f->done = target_flash_done_buffered;
-	f->write_buf = sam4l_flash_write_buf;
-	f->buf_size = SAM4L_PAGE_SIZE;
-	f->erased = 0xff;
-	/* add it into the target structures flash chain */
-	target_add_flash(t, f);
-}
-
-/* Return size of RAM */
-static size_t sam_ram_size(uint32_t idcode) {
-	return __ram_size[((idcode >> CHIPID_CIDR_SRAMSIZ_SHIFT) & CHIPID_CIDR_SRAMSIZ_MASK)];
-}
-
-/* Return size of FLASH */
-static size_t sam_nvp_size(uint32_t idcode) {
-	return __nvp_size[((idcode >> CHIPID_CIDR_NVPSIZ_SHIFT) & CHIPID_CIDR_NVPSIZ_MASK)];
-}
-
-#define SMAP_BASE	0x400a3000
-#define SMAP_CR		(SMAP_BASE + 0x00)
-#define SMAP_SR		(SMAP_BASE + 0x04)
-#define SMAP_SR_DONE	(1 << 0)
-#define SMAP_SR_HCR		(1 << 1)
-#define SMAP_SR_BERR	(1 << 2)
-#define SMAP_SR_FAIL	(1 << 3)
-#define SMAP_SR_LCK		(1 << 4)
-#define SMAP_SR_EN		(1 << 8)
-#define SMAP_SR_PROT	(1 << 9)
-#define SMAP_SR_DBGP	(1 << 10)
-
-
-#define SMAP_SCR	(SMAP_BASE + 0x08)
-#define SMAP_ADDR	(SMAP_BASE + 0x0c)
-#define SMAP_LEN	(SMAP_BASE + 0x10)
-#define SMAP_DATA	(SMAP_BASE + 0x14)
-#define SMAP_VERS	(SMAP_BASE + 0x28)
-#define SMAP_CHIPID	(SMAP_BASE + 0xf0)
-#define SMAP_EXTID	(SMAP_BASE + 0xf4)
-#define SMAP_IDR	(SMAP_BASE + 0xfc)
-
-
-/*
- * The probe function, look where the CIDR register should be, see if
- * it matches the SAM4L architecture code.
- *
- * Figure out from the register how much RAM and FLASH this variant has.
- */
-bool sam4l_probe(target *t)
-{
-	size_t	ram_size, flash_size;
-
-	DEBUG("\nSAM4L: Probe function called\n");
-	t->idcode = target_mem_read32(t, SAM4L_CHIPID_CIDR);
-	if (((t->idcode >> CHIPID_CIDR_ARCH_SHIFT) & CHIPID_CIDR_ARCH_MASK) == SAM4L_ARCH) {
-		t->driver = "Atmel SAM4L";
-		/* this function says we need to do "extra" stuff after reset */
-		t->extended_reset = sam4l_extended_reset;
-		ram_size = sam_ram_size(t->idcode);
-		target_add_ram(t, 0x20000000, ram_size);
-		flash_size = sam_nvp_size(t->idcode);
-		sam4l_add_flash(t, 0x0, flash_size);
-		DEBUG("\nSAM4L: RAM = 0x%x (%dK), FLASH = 0x%x (%dK)\n",
-			(unsigned int) ram_size, (unsigned int) (ram_size / 1024),
-					(unsigned int) flash_size, (unsigned int)(flash_size / 1024));
-			
-		/* enable SMAP if not, check for HCR and reset if set */
-		sam4l_extended_reset(t);
-		DEBUG("\nSAM4L: SAM4L Selected.\n");
-		if (target_check_error(t)) {
-			DEBUG("SAM4L: target_check_error returned true\n");
-		}
-		return true;
-	}
-	return false;
-}
-
-/*
- * We've been reset, make sure we take the core out of reset
- */
-static void
-sam4l_extended_reset(target *t)
-{
-	uint32_t	reg;
-	int i;
-
-	DEBUG("SAM4L: Extended Reset\n");
-	/* enable SMAP in case we're dealing with a non-TCK SRST */
-	target_mem_write32(t, SMAP_CR, 0x1); /* enable SMAP */
-	reg = target_mem_read32(t, SMAP_SR);
-	DEBUG("\nSAM4L: SMAP_SR has 0x%08lx\n", (long unsigned int) reg);
-	if ((reg & SMAP_SR_HCR) != 0) {
-		/* write '1' bit to the status clear register */
-		target_mem_write32(t, SMAP_SCR, SMAP_SR_HCR);
-		/* waiting 250 loops for it to reset is arbitrary, it should happen right away */
-		for (i = 0; i < 250; i++) {
-			reg = target_mem_read32(t, SMAP_SR);
-		}
-		/* not sure what to do if we can't reset that bit */
-		if (i > 249) {
-			DEBUG("\nSAM4L: Reset failed. SMAP_SR has 0x%08lx\n", (long unsigned int) reg);
-		}
-	}
-	/* reset bus error if for some reason SMAP was disabled */
-	target_check_error(t);
-}
-
-/*
- * sam4l_flash_command
- *
- * Helper function, wait for the flash controller to be ready to receive a
- * command. Then send it the command, page number, and the authorization
- * key (always 0xA5) in the command register.
- *
- * Need the target struct to call the mem_read32 and mem_write32 function
- * pointers.
- */
-static int
-sam4l_flash_command(target *t, uint32_t page, uint32_t cmd)
-{
-	uint32_t cmd_reg;
-	uint32_t status;
-	int	timeout;
-	DEBUG("\nSAM4L: sam4l_flash_command: FSR: 0x%08x, page = %d, command = %d\n",
-		(unsigned int)(FLASHCALW_FSR), (int) page, (int) cmd);
-	/* wait for Flash controller ready */
-	for (timeout = 0; timeout < FLASH_TIMEOUT; timeout++) {
-		status = target_mem_read32(t, FLASHCALW_FSR);
-		if (status & FLASHCALW_FSR_FRDY) {
-			break;
-		}
-	}
-	if (timeout == FLASH_TIMEOUT) {
-		DEBUG("\nSAM4L: sam4l_flash_command: Not ready! Status = 0x%08x\n", (unsigned int) status);
-		return -1; /* Failed */
-	}
-	/* load up the new command */
-	cmd_reg = (cmd & FLASHCALW_FCMD_CMD_MASK) |
-			  ((page & FLASHCALW_FCMD_PAGEN_MASK) << FLASHCALW_FCMD_PAGEN_SHIFT) |
-		  	  (0xA5 << FLASHCALW_FCMD_KEY_SHIFT);
-	DEBUG("\nSAM4L: sam4l_flash_command: Wrting command word 0x%08x\n", (unsigned int) cmd_reg);
-	/* and kick it off */
-	target_mem_write32(t, FLASHCALW_FCMD, cmd_reg);
-	/* don't actually wait for it to finish, the next command will stall if it is not done */
-	return 0;
-}
-
-/*
- * Write data from 'src' into flash using the algorithim provided by
- * Atmel in their data sheet.
- */
-static int
-sam4l_flash_write_buf(struct target_flash *f, target_addr addr, const void *src, size_t len)
-{
-	target *t = f->t;
-	uint32_t *src_data = (uint32_t *)src;
-	uint32_t ndx;
-	uint16_t page;
-	
-	DEBUG("\nSAM4L: sam4l_flash_write_buf: addr = 0x%08lx, len %d\n", (long unsigned int) addr, (int) len);
-	/* This will fail with unaligned writes, the write_buf version */
-	page = addr / SAM4L_PAGE_SIZE;
-
-	if (len != SAM4L_PAGE_SIZE) {
-		return -1;
-	}
-
-	/* clear the page buffer */
-	if (sam4l_flash_command(t, 0, FLASH_CMD_CPB)) {
-		return -1;
-	}
-
-	/* Now fill page buffer with our 512 bytes of data */
-
-	/* I did try to use target_mem_write however that resulted in the
-	 * last 64 bits (8 bytes) to be incorrect on even pages (0, 2, 4, ...)
-	 * since it works this way I've not investigated further.
-	 */
-	for (ndx = 0; ndx < SAM4L_PAGE_SIZE; ndx += 4) {
-		/*
- 		 * the page buffer overlaps flash, its only 512 bytes long
-		 * and no matter where you write it from it goes to the page
-		 * you point it to. So we don't need the specific address here
-		 * instead we just write 0 - pagelen (512) and that fills our
-		 * buffer correctly.
-		 */
-		target_mem_write32(t, addr+ndx, *src_data);
-		src_data++;
-	}
-	/* write the page */
-	if (sam4l_flash_command(t, page, FLASH_CMD_WP)) {
-		return -1;
-	}
-	return 0;
-}
-
-/*
- * Erase flash across the addresses specified by addr and len
- */
-static int
-sam4l_flash_erase(struct target_flash *f, target_addr addr, size_t len)
-{
-	target *t = f->t;
-	uint16_t page;
-
-	DEBUG("SAM4L: flash erase address 0x%08x for %d bytes\n",
-		(unsigned int) addr, (unsigned int) len);
-	/*
-	 *  NB: if addr isn't aligned to a page boundary, or length
-	 * is not an even multiple of page sizes, we may end up
-	 * erasing data we didn't intend to.
-	 */
-
-	while (len) {
-		page = addr / SAM4L_PAGE_SIZE;
-		if (sam4l_flash_command(t, page, FLASH_CMD_EP)) {
-			return -1;
-		}
-		len -= SAM4L_PAGE_SIZE;
-		addr += SAM4L_PAGE_SIZE;
-	}
-	return 0;
-}
diff --git a/src/target/samd.c b/src/target/samd.c
deleted file mode 100644
index 7861873..0000000
--- a/src/target/samd.c
+++ /dev/null
@@ -1,701 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2014  Richard Meadows <richardeoin>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/* This file implements Atmel SAM D target specific functions for
- * detecting the device, providing the XML memory map and Flash memory
- * programming.
- *
- * Tested with
- * * SAMD20E17A (rev C)
- * * SAMD20J18A (rev B)
- * * SAMD21J18A (rev B)
- * *
- */
-/* Refer to the SAM D20 Datasheet:
- * http://www.atmel.com/Images/Atmel-42129-SAM-D20_Datasheet.pdf
- * particularly Sections 12. DSU and 20. NVMCTRL
- */
-
-#include "general.h"
-#include "target.h"
-#include "target_internal.h"
-#include "cortexm.h"
-
-static int samd_flash_erase(struct target_flash *t, target_addr addr, size_t len);
-static int samd_flash_write(struct target_flash *f,
-                            target_addr dest, const void *src, size_t len);
-
-static bool samd_cmd_erase_all(target *t);
-static bool samd_cmd_lock_flash(target *t);
-static bool samd_cmd_unlock_flash(target *t);
-static bool samd_cmd_read_userrow(target *t);
-static bool samd_cmd_serial(target *t);
-static bool samd_cmd_mbist(target *t);
-static bool samd_cmd_ssb(target *t);
-
-const struct command_s samd_cmd_list[] = {
-	{"erase_mass", (cmd_handler)samd_cmd_erase_all, "Erase entire flash memory"},
-	{"lock_flash", (cmd_handler)samd_cmd_lock_flash, "Locks flash against spurious commands"},
-	{"unlock_flash", (cmd_handler)samd_cmd_unlock_flash, "Unlocks flash"},
-	{"user_row", (cmd_handler)samd_cmd_read_userrow, "Prints user row from flash"},
-	{"serial", (cmd_handler)samd_cmd_serial, "Prints serial number"},
-	{"mbist", (cmd_handler)samd_cmd_mbist, "Runs the built-in memory test"},
-	{"set_security_bit", (cmd_handler)samd_cmd_ssb, "Sets the Security Bit"},
-	{NULL, NULL, NULL}
-};
-
-/* Non-Volatile Memory Controller (NVMC) Parameters */
-#define SAMD_ROW_SIZE			256
-#define SAMD_PAGE_SIZE			64
-
-/* -------------------------------------------------------------------------- */
-/* Non-Volatile Memory Controller (NVMC) Registers */
-/* -------------------------------------------------------------------------- */
-
-#define SAMD_NVMC			0x41004000
-#define SAMD_NVMC_CTRLA			(SAMD_NVMC + 0x0)
-#define SAMD_NVMC_CTRLB			(SAMD_NVMC + 0x04)
-#define SAMD_NVMC_PARAM			(SAMD_NVMC + 0x08)
-#define SAMD_NVMC_INTFLAG		(SAMD_NVMC + 0x14)
-#define SAMD_NVMC_STATUS		(SAMD_NVMC + 0x18)
-#define SAMD_NVMC_ADDRESS		(SAMD_NVMC + 0x1C)
-
-/* Control A Register (CTRLA) */
-#define SAMD_CTRLA_CMD_KEY		0xA500
-#define SAMD_CTRLA_CMD_ERASEROW		0x0002
-#define SAMD_CTRLA_CMD_WRITEPAGE	0x0004
-#define SAMD_CTRLA_CMD_ERASEAUXROW	0x0005
-#define SAMD_CTRLA_CMD_WRITEAUXPAGE	0x0006
-#define SAMD_CTRLA_CMD_LOCK		0x0040
-#define SAMD_CTRLA_CMD_UNLOCK		0x0041
-#define SAMD_CTRLA_CMD_PAGEBUFFERCLEAR	0x0044
-#define SAMD_CTRLA_CMD_SSB		0x0045
-#define SAMD_CTRLA_CMD_INVALL		0x0046
-
-/* Interrupt Flag Register (INTFLAG) */
-#define SAMD_NVMC_READY			(1 << 0)
-
-/* Non-Volatile Memory Calibration and Auxiliary Registers */
-#define SAMD_NVM_USER_ROW_LOW		0x00804000
-#define SAMD_NVM_USER_ROW_HIGH		0x00804004
-#define SAMD_NVM_CALIBRATION		0x00806020
-#define SAMD_NVM_SERIAL(n)		(0x0080A00C + (0x30 * ((n + 3) / 4)) + \
-					 (0x4 * n))
-
-/* -------------------------------------------------------------------------- */
-/* Device Service Unit (DSU) Registers */
-/* -------------------------------------------------------------------------- */
-
-#define SAMD_DSU			0x41002000
-#define SAMD_DSU_EXT_ACCESS		(SAMD_DSU + 0x100)
-#define SAMD_DSU_CTRLSTAT		(SAMD_DSU_EXT_ACCESS + 0x0)
-#define SAMD_DSU_ADDRESS		(SAMD_DSU_EXT_ACCESS + 0x4)
-#define SAMD_DSU_LENGTH			(SAMD_DSU_EXT_ACCESS + 0x8)
-#define SAMD_DSU_DID			(SAMD_DSU_EXT_ACCESS + 0x018)
-#define SAMD_DSU_PID(n)			(SAMD_DSU + 0x1FE0 + \
-					 (0x4 * (n % 4)) - (0x10 * (n / 4)))
-#define SAMD_DSU_CID(n)			(SAMD_DSU + 0x1FF0 + \
-					 (0x4 * (n % 4)))
-
-/* Control and Status Register (CTRLSTAT) */
-#define SAMD_CTRL_CHIP_ERASE		(1 << 4)
-#define SAMD_CTRL_MBIST			(1 << 3)
-#define SAMD_CTRL_CRC			(1 << 2)
-#define SAMD_STATUSA_PERR		(1 << 12)
-#define SAMD_STATUSA_FAIL		(1 << 11)
-#define SAMD_STATUSA_BERR		(1 << 10)
-#define SAMD_STATUSA_CRSTEXT		(1 << 9)
-#define SAMD_STATUSA_DONE		(1 << 8)
-#define SAMD_STATUSB_PROT		(1 << 16)
-
-/* Device Identification Register (DID) */
-#define SAMD_DID_MASK			0xFFBC0000
-#define SAMD_DID_CONST_VALUE		0x10000000
-#define SAMD_DID_DEVSEL_MASK		0x0F
-#define SAMD_DID_DEVSEL_POS		0
-#define SAMD_DID_REVISION_MASK		0x0F
-#define SAMD_DID_REVISION_POS		8
-#define SAMD_DID_SERIES_MASK		0x03
-#define SAMD_DID_SERIES_POS		16
-
-/* Peripheral ID */
-#define SAMD_PID_MASK			0x00F7FFFF
-#define SAMD_PID_CONST_VALUE		0x0001FCD0
-
-/* Component ID */
-#define SAMD_CID_VALUE			0xB105100D
-
-/**
- * Reads the SAM D20 Peripheral ID
- */
-uint64_t samd_read_pid(target *t)
-{
-	uint64_t pid = 0;
-	uint8_t i, j;
-
-	/* Five PID registers to read LSB first */
-	for (i = 0, j = 0; i < 5; i++, j += 8)
-		pid |= (target_mem_read32(t, SAMD_DSU_PID(i)) & 0xFF) << j;
-
-	return pid;
-}
-/**
- * Reads the SAM D20 Component ID
- */
-uint32_t samd_read_cid(target *t)
-{
-	uint64_t cid = 0;
-	uint8_t i, j;
-
-	/* Four CID registers to read LSB first */
-	for (i = 0, j = 0; i < 4; i++, j += 8)
-		cid |= (target_mem_read32(t, SAMD_DSU_CID(i)) & 0xFF) << j;
-
-	return cid;
-}
-
-/**
- * Overloads the default cortexm reset function with a version that
- * removes the target from extended reset where required.
- */
-static void
-samd_reset(target *t)
-{
-	/**
-	 * SRST is not asserted here as it appears to reset the adiv5
-	 * logic, meaning that subsequent adiv5_* calls PLATFORM_FATAL_ERROR.
-	 *
-	 * This is ok as normally you can just connect the debugger and go,
-	 * but if that's not possible (protection or SWCLK being used for
-	 * something else) then having SWCLK low on reset should get you
-	 * debug access (cold-plugging). TODO: Confirm this
-	 *
-	 * See the SAM D20 datasheet §12.6 Debug Operation for more
-	 * details.
-	 *
-	 * jtagtap_srst(true);
-	 * jtagtap_srst(false);
-	 */
-
-	/* Read DHCSR here to clear S_RESET_ST bit before reset */
-	target_mem_read32(t, CORTEXM_DHCSR);
-
-	/* Request system reset from NVIC: SRST doesn't work correctly */
-	/* This could be VECTRESET: 0x05FA0001 (reset only core)
-	 *          or SYSRESETREQ: 0x05FA0004 (system reset)
-	 */
-	target_mem_write32(t, CORTEXM_AIRCR,
-	                   CORTEXM_AIRCR_VECTKEY | CORTEXM_AIRCR_SYSRESETREQ);
-
-	/* Exit extended reset */
-	if (target_mem_read32(t, SAMD_DSU_CTRLSTAT) &
-	    SAMD_STATUSA_CRSTEXT) {
-		/* Write bit to clear from extended reset */
-		target_mem_write32(t, SAMD_DSU_CTRLSTAT, SAMD_STATUSA_CRSTEXT);
-	}
-
-	/* Poll for release from reset */
-	while (target_mem_read32(t, CORTEXM_DHCSR) & CORTEXM_DHCSR_S_RESET_ST);
-
-	/* Reset DFSR flags */
-	target_mem_write32(t, CORTEXM_DFSR, CORTEXM_DFSR_RESETALL);
-
-	/* Clear any target errors */
-	target_check_error(t);
-}
-
-/**
- * Overloads the default cortexm detached function with a version that
- * removes the target from extended reset where required.
- *
- * Only required for SAM D20 _Revision B_ Silicon
- */
-static void
-samd20_revB_detach(target *t)
-{
-	cortexm_detach(t);
-
-	/* ---- Additional ---- */
-	/* Exit extended reset */
-	if (target_mem_read32(t, SAMD_DSU_CTRLSTAT) &
-	    SAMD_STATUSA_CRSTEXT) {
-		/* Write bit to clear from extended reset */
-		target_mem_write32(t, SAMD_DSU_CTRLSTAT,
-		                   SAMD_STATUSA_CRSTEXT);
-	}
-}
-
-/**
- * Overloads the default cortexm halt_resume function with a version
- * that removes the target from extended reset where required.
- *
- * Only required for SAM D20 _Revision B_ Silicon
- */
-static void
-samd20_revB_halt_resume(target *t, bool step)
-{
-	cortexm_halt_resume(t, step);
-
-	/* ---- Additional ---- */
-	/* Exit extended reset */
-	if (target_mem_read32(t, SAMD_DSU_CTRLSTAT) & SAMD_STATUSA_CRSTEXT) {
-		/* Write bit to clear from extended reset */
-		target_mem_write32(t, SAMD_DSU_CTRLSTAT,
-		                   SAMD_STATUSA_CRSTEXT);
-	}
-}
-
-/**
- * Overload the default cortexm attach for when the samd is protected.
- *
- * If the samd is protected then the default cortexm attach will
- * fail as the S_HALT bit in the DHCSR will never go high. This
- * function allows users to attach on a temporary basis so they can
- * rescue the device.
- */
-static bool
-samd_protected_attach(target *t)
-{
-	/**
-	 * TODO: Notify the user that we're not really attached and
-	 * they should issue the 'monitor erase_mass' command to
-	 * regain access to the chip.
-	 */
-
-	/* Patch back in the normal cortexm attach for next time */
-	t->attach = cortexm_attach;
-
-	/* Allow attach this time */
-	return true;
-}
-
-/**
- * Use the DSU Device Indentification Register to populate a struct
- * describing the SAM D device.
- */
-struct samd_descr {
-	uint8_t series;
-	char revision;
-	char pin;
-	uint8_t mem;
-	char package[3];
-};
-struct samd_descr samd_parse_device_id(uint32_t did)
-{
-	struct samd_descr samd;
-	memset(samd.package, 0, 3);
-
-	uint8_t series = (did >> SAMD_DID_SERIES_POS)
-	  & SAMD_DID_SERIES_MASK;
-	uint8_t revision = (did >> SAMD_DID_REVISION_POS)
-	  & SAMD_DID_REVISION_MASK;
-	uint8_t devsel = (did >> SAMD_DID_DEVSEL_POS)
-	  & SAMD_DID_DEVSEL_MASK;
-
-	/* Series */
-	switch (series) {
-		case 0: samd.series = 20; break;
-		case 1: samd.series = 21; break;
-		case 2: samd.series = 10; break;
-		case 3: samd.series = 11; break;
-	}
-	/* Revision */
-	samd.revision = 'A' + revision;
-
-	switch (samd.series) {
-	case 20: /* SAM D20 */
-	case 21: /* SAM D21 */
-		switch (devsel / 5) {
-			case 0: samd.pin = 'J'; break;
-			case 1: samd.pin = 'G'; break;
-			case 2: samd.pin = 'E'; break;
-			default: samd.pin = 'u'; break;
-		}
-		samd.mem = 18 - (devsel % 5);
-		break;
-	case 10: /* SAM D10 */
-	case 11: /* SAM D11 */
-		switch (devsel / 3) {
-			case 0: samd.package[0] = 'M'; break;
-			case 1: samd.package[0] = 'S'; samd.package[1] = 'S'; break;
-		}
-		samd.pin = 'D';
-		samd.mem = 14 - (devsel % 3);
-		break;
-	}
-
-	return samd;
-}
-
-static void samd_add_flash(target *t, uint32_t addr, size_t length)
-{
-	struct target_flash *f = calloc(1, sizeof(*f));
-	f->start = addr;
-	f->length = length;
-	f->blocksize = SAMD_ROW_SIZE;
-	f->erase = samd_flash_erase;
-	f->write = target_flash_write_buffered;
-	f->done = target_flash_done_buffered;
-	f->write_buf = samd_flash_write;
-	f->buf_size = SAMD_PAGE_SIZE;
-	target_add_flash(t, f);
-}
-
-char variant_string[40];
-bool samd_probe(target *t)
-{
-	uint32_t cid = samd_read_cid(t);
-	uint32_t pid = samd_read_pid(t);
-
-	/* Check the ARM Coresight Component and Perhiperal IDs */
-	if ((cid != SAMD_CID_VALUE) ||
-	    ((pid & SAMD_PID_MASK) != SAMD_PID_CONST_VALUE))
-		return false;
-
-	/* Read the Device ID */
-	uint32_t did = target_mem_read32(t, SAMD_DSU_DID);
-
-	/* If the Device ID matches */
-	if ((did & SAMD_DID_MASK) != SAMD_DID_CONST_VALUE)
-		return false;
-
-	uint32_t ctrlstat = target_mem_read32(t, SAMD_DSU_CTRLSTAT);
-	struct samd_descr samd = samd_parse_device_id(did);
-
-	/* Protected? */
-	bool protected = (ctrlstat & SAMD_STATUSB_PROT);
-
-	/* Part String */
-	if (protected) {
-		sprintf(variant_string,
-		        "Atmel SAMD%d%c%dA%s (rev %c) (PROT=1)",
-		        samd.series, samd.pin, samd.mem,
-		        samd.package, samd.revision);
-	} else {
-		sprintf(variant_string,
-		        "Atmel SAMD%d%c%dA%s (rev %c)",
-		        samd.series, samd.pin, samd.mem,
-		        samd.package, samd.revision);
-	}
-
-	/* Setup Target */
-	t->driver = variant_string;
-	t->reset = samd_reset;
-
-	if (samd.series == 20 && samd.revision == 'B') {
-		/**
-		 * These functions check for and
-		 * extended reset. Appears to be
-		 * related to Errata 35.4.1 ref 12015
-		 */
-		t->detach      = samd20_revB_detach;
-		t->halt_resume = samd20_revB_halt_resume;
-	}
-	if (protected) {
-		/**
-		 * Overload the default cortexm attach
-		 * for when the samd is protected.
-		 * This function allows users to
-		 * attach on a temporary basis so they
-		 * can rescue the device.
-		 */
-		t->attach = samd_protected_attach;
-	}
-
-	target_add_ram(t, 0x20000000, 0x8000);
-	samd_add_flash(t, 0x00000000, 0x40000);
-	target_add_commands(t, samd_cmd_list, "SAMD");
-
-	/* If we're not in reset here */
-	if (!platform_srst_get_val()) {
-		/* We'll have to release the target from
-		 * extended reset to make attach possible */
-		if (target_mem_read32(t, SAMD_DSU_CTRLSTAT) &
-		    SAMD_STATUSA_CRSTEXT) {
-
-			/* Write bit to clear from extended reset */
-			target_mem_write32(t, SAMD_DSU_CTRLSTAT,
-			                   SAMD_STATUSA_CRSTEXT);
-		}
-	}
-
-	return true;
-}
-
-/**
- * Temporary (until next reset) flash memory locking / unlocking
- */
-static void samd_lock_current_address(target *t)
-{
-	/* Issue the unlock command */
-	target_mem_write32(t, SAMD_NVMC_CTRLA,
-	                   SAMD_CTRLA_CMD_KEY | SAMD_CTRLA_CMD_LOCK);
-}
-static void samd_unlock_current_address(target *t)
-{
-	/* Issue the unlock command */
-	target_mem_write32(t, SAMD_NVMC_CTRLA,
-	                   SAMD_CTRLA_CMD_KEY | SAMD_CTRLA_CMD_UNLOCK);
-}
-
-/**
- * Erase flash row by row
- */
-static int samd_flash_erase(struct target_flash *f, target_addr addr, size_t len)
-{
-	target *t = f->t;
-	while (len) {
-		/* Write address of first word in row to erase it */
-		/* Must be shifted right for 16-bit address, see Datasheet §20.8.8 Address */
-		target_mem_write32(t, SAMD_NVMC_ADDRESS, addr >> 1);
-
-		/* Unlock */
-		samd_unlock_current_address(t);
-
-		/* Issue the erase command */
-		target_mem_write32(t, SAMD_NVMC_CTRLA,
-		                   SAMD_CTRLA_CMD_KEY | SAMD_CTRLA_CMD_ERASEROW);
-		/* Poll for NVM Ready */
-		while ((target_mem_read32(t, SAMD_NVMC_INTFLAG) & SAMD_NVMC_READY) == 0)
-			if (target_check_error(t))
-				return -1;
-
-		/* Lock */
-		samd_lock_current_address(t);
-
-		addr += f->blocksize;
-		len -= f->blocksize;
-	}
-
-	return 0;
-}
-
-/**
- * Write flash page by page
- */
-static int samd_flash_write(struct target_flash *f,
-                            target_addr dest, const void *src, size_t len)
-{
-	target *t = f->t;
-
-	/* Write within a single page. This may be part or all of the page */
-	target_mem_write(t, dest, src, len);
-
-	/* Unlock */
-	samd_unlock_current_address(t);
-
-	/* Issue the write page command */
-	target_mem_write32(t, SAMD_NVMC_CTRLA,
-	                   SAMD_CTRLA_CMD_KEY | SAMD_CTRLA_CMD_WRITEPAGE);
-
-	/* Poll for NVM Ready */
-	while ((target_mem_read32(t, SAMD_NVMC_INTFLAG) & SAMD_NVMC_READY) == 0)
-		if (target_check_error(t))
-			return -1;
-
-	/* Lock */
-	samd_lock_current_address(t);
-
-	return 0;
-}
-
-/**
- * Uses the Device Service Unit to erase the entire flash
- */
-static bool samd_cmd_erase_all(target *t)
-{
-	/* Clear the DSU status bits */
-	target_mem_write32(t, SAMD_DSU_CTRLSTAT,
-	                   SAMD_STATUSA_DONE | SAMD_STATUSA_PERR |
-	                   SAMD_STATUSA_FAIL);
-
-	/* Erase all */
-	target_mem_write32(t, SAMD_DSU_CTRLSTAT, SAMD_CTRL_CHIP_ERASE);
-
-	/* Poll for DSU Ready */
-	uint32_t status;
-	while (((status = target_mem_read32(t, SAMD_DSU_CTRLSTAT)) &
-		(SAMD_STATUSA_DONE | SAMD_STATUSA_PERR | SAMD_STATUSA_FAIL)) == 0)
-		if (target_check_error(t))
-			return false;
-
-	/* Test the protection error bit in Status A */
-	if (status & SAMD_STATUSA_PERR) {
-		tc_printf(t, "Erase failed due to a protection error.\n");
-		return true;
-	}
-
-	/* Test the fail bit in Status A */
-	if (status & SAMD_STATUSA_FAIL) {
-		tc_printf(t, "Erase failed.\n");
-		return true;
-	}
-
-	tc_printf(t, "Erase successful!\n");
-
-	return true;
-}
-
-/**
- * Sets the NVM region lock bits in the User Row. This value is read
- * at startup as the default value for the lock bits, and hence does
- * not take effect until a reset.
- *
- * 0x0000 = Lock, 0xFFFF = Unlock (default)
- */
-static bool samd_set_flashlock(target *t, uint16_t value)
-{
-	uint32_t high = target_mem_read32(t, SAMD_NVM_USER_ROW_HIGH);
-	uint32_t low = target_mem_read32(t, SAMD_NVM_USER_ROW_LOW);
-
-	/* Write address of a word in the row to erase it */
-	/* Must be shifted right for 16-bit address, see Datasheet §20.8.8 Address */
-	target_mem_write32(t, SAMD_NVMC_ADDRESS, SAMD_NVM_USER_ROW_LOW >> 1);
-
-	/* Issue the erase command */
-	target_mem_write32(t, SAMD_NVMC_CTRLA,
-	                   SAMD_CTRLA_CMD_KEY | SAMD_CTRLA_CMD_ERASEAUXROW);
-
-	/* Poll for NVM Ready */
-	while ((target_mem_read32(t, SAMD_NVMC_INTFLAG) & SAMD_NVMC_READY) == 0)
-		if (target_check_error(t))
-			return -1;
-
-	/* Modify the high byte of the user row */
-	high = (high & 0x0000FFFF) | ((value << 16) & 0xFFFF0000);
-
-	/* Write back */
-	target_mem_write32(t, SAMD_NVM_USER_ROW_LOW, low);
-	target_mem_write32(t, SAMD_NVM_USER_ROW_HIGH, high);
-
-	/* Issue the page write command */
-	target_mem_write32(t, SAMD_NVMC_CTRLA,
-	                   SAMD_CTRLA_CMD_KEY | SAMD_CTRLA_CMD_WRITEAUXPAGE);
-
-	return true;
-}
-
-static bool samd_cmd_lock_flash(target *t)
-{
-	return samd_set_flashlock(t, 0x0000);
-}
-
-static bool samd_cmd_unlock_flash(target *t)
-{
-	return samd_set_flashlock(t, 0xFFFF);
-}
-
-static bool samd_cmd_read_userrow(target *t)
-{
-	tc_printf(t, "User Row: 0x%08x%08x\n",
-		target_mem_read32(t, SAMD_NVM_USER_ROW_HIGH),
-		target_mem_read32(t, SAMD_NVM_USER_ROW_LOW));
-
-	return true;
-}
-
-/**
- * Reads the 128-bit serial number from the NVM
- */
-static bool samd_cmd_serial(target *t)
-{
-	tc_printf(t, "Serial Number: 0x");
-
-	for (uint32_t i = 0; i < 4; i++) {
-		tc_printf(t, "%08x", target_mem_read32(t, SAMD_NVM_SERIAL(i)));
-	}
-
-	tc_printf(t, "\n");
-
-	return true;
-}
-
-/**
- * Returns the size (in bytes) of the current SAM D20's flash memory.
- */
-static uint32_t samd_flash_size(target *t)
-{
-	/* Read the Device ID */
-	uint32_t did = target_mem_read32(t, SAMD_DSU_DID);
-
-	/* Mask off the device select bits */
-	uint8_t devsel = did & SAMD_DID_DEVSEL_MASK;
-
-	/* Shift the maximum flash size (256KB) down as appropriate */
-	return (0x40000 >> (devsel % 5));
-}
-
-/**
- * Runs the Memory Built In Self Test (MBIST)
- */
-static bool samd_cmd_mbist(target *t)
-{
-	/* Write the memory parameters to the DSU */
-	target_mem_write32(t, SAMD_DSU_ADDRESS, 0);
-	target_mem_write32(t, SAMD_DSU_LENGTH, samd_flash_size(t));
-
-	/* Clear the fail bit */
-	target_mem_write32(t, SAMD_DSU_CTRLSTAT, SAMD_STATUSA_FAIL);
-
-	/* Write the MBIST command */
-	target_mem_write32(t, SAMD_DSU_CTRLSTAT, SAMD_CTRL_MBIST);
-
-	/* Poll for DSU Ready */
-	uint32_t status;
-	while (((status = target_mem_read32(t, SAMD_DSU_CTRLSTAT)) &
-		(SAMD_STATUSA_DONE | SAMD_STATUSA_PERR | SAMD_STATUSA_FAIL)) == 0)
-		if (target_check_error(t))
-			return false;
-
-	/* Test the protection error bit in Status A */
-	if (status & SAMD_STATUSA_PERR) {
-		tc_printf(t, "MBIST not run due to protection error.\n");
-		return true;
-	}
-
-	/* Test the fail bit in Status A */
-	if (status & SAMD_STATUSA_FAIL) {
-		tc_printf(t, "MBIST Fail @ 0x%08x\n",
-		          target_mem_read32(t, SAMD_DSU_ADDRESS));
-	} else {
-		tc_printf(t, "MBIST Passed!\n");
-	}
-
-	return true;
-}
-/**
- * Sets the security bit
- */
-static bool samd_cmd_ssb(target *t)
-{
-	/* Issue the ssb command */
-	target_mem_write32(t, SAMD_NVMC_CTRLA,
-	                   SAMD_CTRLA_CMD_KEY | SAMD_CTRLA_CMD_SSB);
-
-	/* Poll for NVM Ready */
-	while ((target_mem_read32(t, SAMD_NVMC_INTFLAG) & SAMD_NVMC_READY) == 0)
-		if (target_check_error(t))
-			return -1;
-
-	tc_printf(t, "Set the security bit! "
-		  "You will need to issue 'monitor erase_mass' to clear this.\n");
-
-	return true;
-}
-
diff --git a/src/target/stm32f1.c b/src/target/stm32f1.c
deleted file mode 100644
index 1b70659..0000000
--- a/src/target/stm32f1.c
+++ /dev/null
@@ -1,362 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2011  Black Sphere Technologies Ltd.
- * Written by Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/* This file implements STM32 target specific functions for detecting
- * the device, providing the XML memory map and Flash memory programming.
- *
- * Refereces:
- * ST doc - RM0008
- *   Reference manual - STM32F101xx, STM32F102xx, STM32F103xx, STM32F105xx
- *   and STM32F107xx advanced ARM-based 32-bit MCUs
- * ST doc - RM0091
- *   Reference manual - STM32F0x1/STM32F0x2/STM32F0x8
- *   advanced ARM®-based 32-bit MCUs
- * ST doc - RM0360
- *   Reference manual - STM32F030x4/x6/x8/xC and STM32F070x6/xB
- * ST doc - PM0075
- *   Programming manual - STM32F10xxx Flash memory microcontrollers
- */
-
-#include "general.h"
-#include "target.h"
-#include "target_internal.h"
-#include "cortexm.h"
-
-static bool stm32f1_cmd_erase_mass(target *t);
-static bool stm32f1_cmd_option(target *t, int argc, char *argv[]);
-
-const struct command_s stm32f1_cmd_list[] = {
-	{"erase_mass", (cmd_handler)stm32f1_cmd_erase_mass, "Erase entire flash memory"},
-	{"option", (cmd_handler)stm32f1_cmd_option, "Manipulate option bytes"},
-	{NULL, NULL, NULL}
-};
-
-
-static int stm32f1_flash_erase(struct target_flash *f,
-                               target_addr addr, size_t len);
-static int stm32f1_flash_write(struct target_flash *f,
-                               target_addr dest, const void *src, size_t len);
-
-/* Flash Program ad Erase Controller Register Map */
-#define FPEC_BASE	0x40022000
-#define FLASH_ACR	(FPEC_BASE+0x00)
-#define FLASH_KEYR	(FPEC_BASE+0x04)
-#define FLASH_OPTKEYR	(FPEC_BASE+0x08)
-#define FLASH_SR	(FPEC_BASE+0x0C)
-#define FLASH_CR	(FPEC_BASE+0x10)
-#define FLASH_AR	(FPEC_BASE+0x14)
-#define FLASH_OBR	(FPEC_BASE+0x1C)
-#define FLASH_WRPR	(FPEC_BASE+0x20)
-
-#define FLASH_CR_OBL_LAUNCH (1<<13)
-#define FLASH_CR_OPTWRE	(1 << 9)
-#define FLASH_CR_STRT	(1 << 6)
-#define FLASH_CR_OPTER	(1 << 5)
-#define FLASH_CR_OPTPG	(1 << 4)
-#define FLASH_CR_MER	(1 << 2)
-#define FLASH_CR_PER	(1 << 1)
-
-#define FLASH_OBR_RDPRT (1 << 1)
-
-#define FLASH_SR_BSY	(1 << 0)
-
-#define FLASH_OBP_RDP 0x1FFFF800
-#define FLASH_OBP_RDP_KEY 0x5aa5
-#define FLASH_OBP_RDP_KEY_F3 0x55AA
-
-#define KEY1 0x45670123
-#define KEY2 0xCDEF89AB
-
-#define SR_ERROR_MASK	0x14
-#define SR_EOP		0x20
-
-#define DBGMCU_IDCODE	0xE0042000
-#define DBGMCU_IDCODE_F0	0x40015800
-
-#define FLASHSIZE     0x1FFFF7E0
-#define FLASHSIZE_F0  0x1FFFF7CC
-
-static const uint16_t stm32f1_flash_write_stub[] = {
-#include "flashstub/stm32f1.stub"
-};
-
-#define SRAM_BASE 0x20000000
-#define STUB_BUFFER_BASE ALIGN(SRAM_BASE + sizeof(stm32f1_flash_write_stub), 4)
-
-static void stm32f1_add_flash(target *t,
-                              uint32_t addr, size_t length, size_t erasesize)
-{
-	struct target_flash *f = calloc(1, sizeof(*f));
-	f->start = addr;
-	f->length = length;
-	f->blocksize = erasesize;
-	f->erase = stm32f1_flash_erase;
-	f->write = stm32f1_flash_write;
-	f->align = 2;
-	f->erased = 0xff;
-	target_add_flash(t, f);
-}
-
-bool stm32f1_probe(target *t)
-{
-	size_t flash_size;
-	size_t block_size = 0x400;
-	t->idcode = target_mem_read32(t, DBGMCU_IDCODE) & 0xfff;
-	switch(t->idcode) {
-	case 0x410:  /* Medium density */
-	case 0x412:  /* Low denisty */
-	case 0x420:  /* Value Line, Low-/Medium density */
-		t->driver = "STM32F1 medium density";
-		target_add_ram(t, 0x20000000, 0x5000);
-		stm32f1_add_flash(t, 0x8000000, 0x20000, 0x400);
-		target_add_commands(t, stm32f1_cmd_list, "STM32 LD/MD");
-		return true;
-	case 0x414:	 /* High density */
-	case 0x418:  /* Connectivity Line */
-	case 0x428:	 /* Value Line, High Density */
-		t->driver = "STM32F1 high density";
-		target_add_ram(t, 0x20000000, 0x10000);
-		stm32f1_add_flash(t, 0x8000000, 0x80000, 0x800);
-		target_add_commands(t, stm32f1_cmd_list, "STM32 HD/CL");
-		return true;
-	case 0x438:  /* STM32F303x6/8 and STM32F328 */
-	case 0x422:  /* STM32F30x */
-	case 0x446:  /* STM32F303xD/E and STM32F398xE */
-		target_add_ram(t, 0x10000000, 0x4000);
-	case 0x432:  /* STM32F37x */
-	case 0x439:  /* STM32F302C8 */
-		t->driver = "STM32F3";
-		target_add_ram(t, 0x20000000, 0x10000);
-		stm32f1_add_flash(t, 0x8000000, 0x80000, 0x800);
-		target_add_commands(t, stm32f1_cmd_list, "STM32F3");
-		return true;
-	}
-
-	t->idcode = target_mem_read32(t, DBGMCU_IDCODE_F0) & 0xfff;
-	switch(t->idcode) {
-	case 0x444:  /* STM32F03 RM0091 Rev.7, STM32F030x[4|6] RM0360 Rev. 4*/
-		t->driver = "STM32F03";
-		break;
-	case 0x445:  /* STM32F04 RM0091 Rev.7, STM32F070x6 RM0360 Rev. 4*/
-		t->driver = "STM32F04/F070x6";
-		break;
-	case 0x440:  /* STM32F05 RM0091 Rev.7, STM32F030x8 RM0360 Rev. 4*/
-		t->driver = "STM32F05/F030x8";
-		break;
-	case 0x448:  /* STM32F07 RM0091 Rev.7, STM32F070xB RM0360 Rev. 4*/
-		t->driver = "STM32F07";
-		block_size = 0x800;
-		break;
-	case 0x442:  /* STM32F09 RM0091 Rev.7, STM32F030xC RM0360 Rev. 4*/
-		t->driver = "STM32F09/F030xC";
-		block_size = 0x800;
-		break;
-	default:     /* NONE */
-		return false;
-	}
-
-	flash_size = (target_mem_read32(t, FLASHSIZE_F0) & 0xffff) *0x400;
-	target_add_ram(t, 0x20000000, 0x5000);
-	stm32f1_add_flash(t, 0x8000000, flash_size, block_size);
-	target_add_commands(t, stm32f1_cmd_list, "STM32F0");
-	return true;
-}
-
-static void stm32f1_flash_unlock(target *t)
-{
-	target_mem_write32(t, FLASH_KEYR, KEY1);
-	target_mem_write32(t, FLASH_KEYR, KEY2);
-}
-
-static int stm32f1_flash_erase(struct target_flash *f,
-                               target_addr addr, size_t len)
-{
-	target *t = f->t;
-	uint16_t sr;
-
-	stm32f1_flash_unlock(t);
-
-	while(len) {
-		/* Flash page erase instruction */
-		target_mem_write32(t, FLASH_CR, FLASH_CR_PER);
-		/* write address to FMA */
-		target_mem_write32(t, FLASH_AR, addr);
-		/* Flash page erase start instruction */
-		target_mem_write32(t, FLASH_CR, FLASH_CR_STRT | FLASH_CR_PER);
-
-		/* Read FLASH_SR to poll for BSY bit */
-		while (target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
-			if(target_check_error(t))
-				return -1;
-
-		len -= f->blocksize;
-		addr += f->blocksize;
-	}
-
-	/* Check for error */
-	sr = target_mem_read32(t, FLASH_SR);
-	if ((sr & SR_ERROR_MASK) || !(sr & SR_EOP))
-		return -1;
-
-	return 0;
-}
-
-static int stm32f1_flash_write(struct target_flash *f,
-                               target_addr dest, const void *src, size_t len)
-{
-	target *t = f->t;
-	/* Write stub and data to target ram and set PC */
-	target_mem_write(t, SRAM_BASE, stm32f1_flash_write_stub,
-	                 sizeof(stm32f1_flash_write_stub));
-	target_mem_write(t, STUB_BUFFER_BASE, src, len);
-	return cortexm_run_stub(t, SRAM_BASE, dest, STUB_BUFFER_BASE, len, 0);
-}
-
-static bool stm32f1_cmd_erase_mass(target *t)
-{
-	stm32f1_flash_unlock(t);
-
-	/* Flash mass erase start instruction */
-	target_mem_write32(t, FLASH_CR, FLASH_CR_MER);
-	target_mem_write32(t, FLASH_CR, FLASH_CR_STRT | FLASH_CR_MER);
-
-	/* Read FLASH_SR to poll for BSY bit */
-	while (target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
-		if(target_check_error(t))
-			return false;
-
-	/* Check for error */
-	uint16_t sr = target_mem_read32(t, FLASH_SR);
-	if ((sr & SR_ERROR_MASK) || !(sr & SR_EOP))
-		return false;
-
-	return true;
-}
-
-static bool stm32f1_option_erase(target *t)
-{
-	/* Erase option bytes instruction */
-	target_mem_write32(t, FLASH_CR, FLASH_CR_OPTER | FLASH_CR_OPTWRE);
-	target_mem_write32(t, FLASH_CR,
-			   FLASH_CR_STRT | FLASH_CR_OPTER | FLASH_CR_OPTWRE);
-	/* Read FLASH_SR to poll for BSY bit */
-	while (target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
-		if(target_check_error(t))
-			return false;
-	return true;
-}
-
-static bool stm32f1_option_write_erased(target *t, uint32_t addr, uint16_t value)
-{
-	if (value == 0xffff)
-		return true;
-	/* Erase option bytes instruction */
-	target_mem_write32(t, FLASH_CR, FLASH_CR_OPTPG | FLASH_CR_OPTWRE);
-	target_mem_write16(t, addr, value);
-	/* Read FLASH_SR to poll for BSY bit */
-	while (target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
-		if(target_check_error(t))
-			return false;
-	return true;
-}
-
-static bool stm32f1_option_write(target *t, uint32_t addr, uint16_t value)
-{
-	uint16_t opt_val[8];
-	int i, index;
-
-	index = (addr - FLASH_OBP_RDP) / 2;
-	if ((index < 0) || (index > 7))
-		 return false;
-	/* Retrieve old values */
-	for (i = 0; i < 16; i = i +4) {
-		 uint32_t val = target_mem_read32(t, FLASH_OBP_RDP + i);
-		 opt_val[i/2] = val & 0xffff;
-		 opt_val[i/2 +1] = val >> 16;
-	}
-	if (opt_val[index] == value)
-		return true;
-	/* Check for erased value */
-	if (opt_val[index] != 0xffff)
-		if (!(stm32f1_option_erase(t)))
-			return false;
-	opt_val[index] = value;
-	/* Write changed values*/
-	for (i = 0; i < 8; i++)
-		if (!(stm32f1_option_write_erased
-			(t, FLASH_OBP_RDP + i*2,opt_val[i])))
-			return false;
-	return true;
-}
-
-static bool stm32f1_cmd_option(target *t, int argc, char *argv[])
-{
-	uint32_t addr, val;
-	uint32_t flash_obp_rdp_key;
-	uint32_t rdprt;
-
-	switch(t->idcode) {
-	case 0x422:  /* STM32F30x */
-	case 0x432:  /* STM32F37x */
-	case 0x438:  /* STM32F303x6/8 and STM32F328 */
-	case 0x440:  /* STM32F0 */
-	case 0x446:  /* STM32F303xD/E and STM32F398xE */
-		flash_obp_rdp_key = FLASH_OBP_RDP_KEY_F3;
-		break;
-	default: flash_obp_rdp_key = FLASH_OBP_RDP_KEY;
-	}
-	rdprt = target_mem_read32(t, FLASH_OBR) & FLASH_OBR_RDPRT;
-	stm32f1_flash_unlock(t);
-	target_mem_write32(t, FLASH_OPTKEYR, KEY1);
-	target_mem_write32(t, FLASH_OPTKEYR, KEY2);
-
-	if ((argc == 2) && !strcmp(argv[1], "erase")) {
-		stm32f1_option_erase(t);
-		stm32f1_option_write_erased(t, FLASH_OBP_RDP, flash_obp_rdp_key);
-	} else if (rdprt) {
-		tc_printf(t, "Device is Read Protected\n");
-		tc_printf(t, "Use \"monitor option erase\" to unprotect, erasing device\n");
-		return true;
-	} else if (argc == 3) {
-		addr = strtol(argv[1], NULL, 0);
-		val = strtol(argv[2], NULL, 0);
-		stm32f1_option_write(t, addr, val);
-	} else {
-		tc_printf(t, "usage: monitor option erase\n");
-		tc_printf(t, "usage: monitor option <addr> <value>\n");
-	}
-
-	if (0 && flash_obp_rdp_key == FLASH_OBP_RDP_KEY_F3) {
-		/* Reload option bytes on F0 and F3*/
-		val = target_mem_read32(t, FLASH_CR);
-		val |= FLASH_CR_OBL_LAUNCH;
-		stm32f1_option_write(t, FLASH_CR, val);
-		val &= ~FLASH_CR_OBL_LAUNCH;
-		stm32f1_option_write(t, FLASH_CR, val);
-	}
-
-	for (int i = 0; i < 0xf; i += 4) {
-		addr = 0x1ffff800 + i;
-		val = target_mem_read32(t, addr);
-		tc_printf(t, "0x%08X: 0x%04X\n", addr, val & 0xFFFF);
-		tc_printf(t, "0x%08X: 0x%04X\n", addr + 2, val >> 16);
-	}
-	return true;
-}
diff --git a/src/target/stm32f4.c b/src/target/stm32f4.c
deleted file mode 100644
index c6a9a5f..0000000
--- a/src/target/stm32f4.c
+++ /dev/null
@@ -1,648 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2011  Black Sphere Technologies Ltd.
- * Written by Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/* This file implements STM32F4 target specific functions for detecting
- * the device, providing the XML memory map and Flash memory programming.
- *
- * Refereces:
- * ST doc - RM0090
- *   Reference manual - STM32F405xx, STM32F407xx, STM32F415xx and STM32F417xx
- *   advanced ARM-based 32-bit MCUs
- * ST doc - PM0081
- *   Programming manual - STM32F40xxx and STM32F41xxx Flash programming
- *    manual
- */
-
-#include "general.h"
-#include "target.h"
-#include "target_internal.h"
-#include "cortexm.h"
-
-static bool stm32f4_cmd_erase_mass(target *t);
-static bool stm32f4_cmd_option(target *t, int argc, char *argv[]);
-static bool stm32f4_cmd_psize(target *t, int argc, char *argv[]);
-
-const struct command_s stm32f4_cmd_list[] = {
-	{"erase_mass", (cmd_handler)stm32f4_cmd_erase_mass,
-	 "Erase entire flash memory"},
-	{"option", (cmd_handler)stm32f4_cmd_option, "Manipulate option bytes"},
-	{"psize", (cmd_handler)stm32f4_cmd_psize,
-	 "Configure flash write parallelism: (x8|x32(default))"},
-	{NULL, NULL, NULL}
-};
-
-
-static int stm32f4_flash_erase(struct target_flash *f, target_addr addr,
-							   size_t len);
-static int stm32f4_flash_write(struct target_flash *f,
-                               target_addr dest, const void *src, size_t len);
-
-/* Flash Program ad Erase Controller Register Map */
-#define FPEC_BASE	0x40023C00
-#define FLASH_ACR	(FPEC_BASE+0x00)
-#define FLASH_KEYR	(FPEC_BASE+0x04)
-#define FLASH_OPTKEYR	(FPEC_BASE+0x08)
-#define FLASH_SR	(FPEC_BASE+0x0C)
-#define FLASH_CR	(FPEC_BASE+0x10)
-#define FLASH_OPTCR	(FPEC_BASE+0x14)
-
-#define FLASH_CR_PG		(1 << 0)
-#define FLASH_CR_SER		(1 << 1)
-#define FLASH_CR_MER		(1 << 2)
-#define FLASH_CR_PSIZE8		(0 << 8)
-#define FLASH_CR_PSIZE16	(1 << 8)
-#define FLASH_CR_PSIZE32	(2 << 8)
-#define FLASH_CR_PSIZE64	(3 << 8)
-#define FLASH_CR_MER1		(1 << 15)
-#define FLASH_CR_STRT		(1 << 16)
-#define FLASH_CR_EOPIE		(1 << 24)
-#define FLASH_CR_ERRIE		(1 << 25)
-#define FLASH_CR_STRT		(1 << 16)
-#define FLASH_CR_LOCK		(1 << 31)
-
-#define FLASH_SR_BSY		(1 << 16)
-
-#define FLASH_OPTCR_OPTLOCK	(1 << 0)
-#define FLASH_OPTCR_OPTSTRT	(1 << 1)
-#define FLASH_OPTCR_nDBANK	(1 << 29)
-#define FLASH_OPTCR_DB1M	(1 << 30)
-
-#define KEY1 0x45670123
-#define KEY2 0xCDEF89AB
-
-#define OPTKEY1 0x08192A3B
-#define OPTKEY2 0x4C5D6E7F
-
-#define SR_ERROR_MASK	0xF2
-#define SR_EOP		0x01
-
-#define F4_FLASHSIZE	0x1FFF7A22
-#define F7_FLASHSIZE	0x1FF0F442
-#define F72X_FLASHSIZE	0x1FF07A22
-#define DBGMCU_IDCODE	0xE0042000
-#define ARM_CPUID	0xE000ED00
-
-#define DBGMCU_CR		0xE0042004
-#define DBG_STANDBY		(1 << 0)
-#define DBG_STOP		(1 << 1)
-#define DBG_SLEEP		(1 << 2)
-
-#define DBGMCU_APB1_FZ	0xE0042008
-#define DBG_WWDG_STOP	(1 << 11)
-#define DBG_IWDG_STOP	(1 << 12)
-
-/* This routine uses word access.  Only usable on target voltage >2.7V */
-static const uint16_t stm32f4_flash_write_x32_stub[] = {
-#include "flashstub/stm32f4_x32.stub"
-};
-
-/* This routine uses byte access. Usable on target voltage <2.2V */
-static const uint16_t stm32f4_flash_write_x8_stub[] = {
-#include "flashstub/stm32f4_x8.stub"
-};
-
-#define SRAM_BASE 0x20000000
-#define STUB_BUFFER_BASE \
-	ALIGN(SRAM_BASE + MAX(sizeof(stm32f4_flash_write_x8_stub), \
-			      sizeof(stm32f4_flash_write_x32_stub)), 4)
-
-#define AXIM_BASE 0x8000000
-#define ITCM_BASE 0x0200000
-
-struct stm32f4_flash {
-	struct target_flash f;
-	uint8_t base_sector;
-	uint8_t psize;
-	uint8_t bank_split;
-};
-
-enum ID_STM32F47 {
-	ID_STM32F20X  = 0x411,
-	ID_STM32F40X  = 0x413,
-	ID_STM32F42X  = 0x419,
-	ID_STM32F446  = 0x421,
-	ID_STM32F401C = 0x423,
-	ID_STM32F411  = 0x431,
-	ID_STM32F401E = 0x433,
-	ID_STM32F46X  = 0x434,
-	ID_STM32F412  = 0x441,
-	ID_STM32F74X  = 0x449,
-	ID_STM32F76X  = 0x451,
-	ID_STM32F72X  = 0x452,
-	ID_STM32F410  = 0x458,
-	ID_STM32F413  = 0x463
-};
-
-static void stm32f4_add_flash(target *t,
-                              uint32_t addr, size_t length, size_t blocksize,
-                              unsigned int base_sector, int split)
-{
-	struct stm32f4_flash *sf = calloc(1, sizeof(*sf));
-	struct target_flash *f = &sf->f;
-	f->start = addr;
-	f->length = length;
-	f->blocksize = blocksize;
-	f->erase = stm32f4_flash_erase;
-	f->write = stm32f4_flash_write;
-	f->align = 4;
-	f->erased = 0xff;
-	sf->base_sector = base_sector;
-	sf->psize = 32;
-	sf->bank_split = split;
-	target_add_flash(t, f);
-}
-
-bool stm32f4_probe(target *t)
-{
-	uint32_t idcode;
-	const char* designator = NULL;
-	bool dual_bank = false;
-	bool has_ccmram = false;
-	bool is_f7  = false;
-	bool large_sectors = false;
-	uint32_t flashsize_base = F4_FLASHSIZE;
-
-	idcode = target_mem_read32(t, DBGMCU_IDCODE);
-	idcode &= 0xFFF;
-
-	if (idcode == ID_STM32F20X) {
-		/* F405 revision A have a wrong IDCODE, use ARM_CPUID to make the
-		 * distinction with F205. Revision is also wrong (0x2000 instead
-		 * of 0x1000). See F40x/F41x errata. */
-		uint32_t cpuid = target_mem_read32(t, ARM_CPUID);
-		if ((cpuid & 0xFFF0) == 0xC240)
-			idcode = ID_STM32F40X;
-	}
-	switch(idcode) {
-	case ID_STM32F40X:
-		designator = "STM32F40x";
-		has_ccmram = true;
-		break;
-	case ID_STM32F42X: /* 427/437 */
-		designator = "STM32F42x";
-		has_ccmram = true;
-		dual_bank  = true;
-		break;
-	case ID_STM32F46X: /* 469/479 */
-		designator = "STM32F47x";
-		has_ccmram = true;
-		dual_bank  = true;
-		break;
-	case ID_STM32F20X: /* F205 */
-		designator = "STM32F2";
-		break;
-	case ID_STM32F446: /* F446 */
-		designator = "STM32F446";
-		break;
-	case ID_STM32F401C: /* F401 B/C RM0368 Rev.3 */
-		designator = "STM32F401C";
-		break;
-	case ID_STM32F411: /* F411     RM0383 Rev.4 */
-		designator = "STM32F411";
-		break;
-	case ID_STM32F412: /* F412     RM0402 Rev.4, 256 kB Ram */
-		designator = "STM32F412";
-		break;
-	case ID_STM32F401E: /* F401 D/E RM0368 Rev.3 */
-		designator = "STM32F401E";
-		break;
-	case ID_STM32F413: /* F413     RM0430 Rev.2, 320 kB Ram, 1.5 MB flash. */
-		designator = "STM32F413";
-		break;
-	case ID_STM32F74X: /* F74x RM0385 Rev.4 */
-		designator = "STM32F74x";
-		is_f7 = true;
-		large_sectors = true;
-		flashsize_base = F7_FLASHSIZE;
-		break;
-	case ID_STM32F76X: /* F76x F77x RM0410 */
-		designator = "STM32F76x";
-		is_f7 = true;
-		dual_bank = true;
-		flashsize_base = F7_FLASHSIZE;
-		break;
-	case ID_STM32F72X: /* F72x F73x RM0431 */
-		designator = "STM32F72x";
-		is_f7 = true;
-		flashsize_base = F72X_FLASHSIZE;
-		break;
-	default:
-		return false;
-	}
-	target_mem_write32(t, DBGMCU_CR, DBG_STANDBY| DBG_STOP | DBG_SLEEP);
-	t->driver = designator;
-	target_add_commands(t, stm32f4_cmd_list, designator);
-	t->idcode = idcode;
-	bool use_dual_bank = false;
-	uint32_t flashsize = target_mem_read32(t, flashsize_base) & 0xffff;
-	if (is_f7) {
-		target_add_ram(t, 0x00000000, 0x4000);  /* 16 k ITCM Ram */
-		target_add_ram(t, 0x20000000, 0x10000); /* 64 k DTCM Ram */
-		if (dual_bank) {
-			uint32_t optcr;
-			optcr = target_mem_read32(t, FLASH_OPTCR);
-			use_dual_bank =  !(optcr & FLASH_OPTCR_nDBANK);
-		}
-	} else {
-		if (has_ccmram)
-			target_add_ram(t, 0x10000000, 0x10000); /* 64 k CCM Ram*/
-		target_add_ram(t, 0x20000000, 0x10000);     /* 64 k RAM */
-		if (dual_bank) {
-			use_dual_bank = true;
-			if (flashsize < 0x800) {
-				/* Check Dual-bank on 1 Mbyte Flash memory devices*/
-				uint32_t optcr;
-				optcr = target_mem_read32(t, FLASH_OPTCR);
-				use_dual_bank = !(optcr & FLASH_OPTCR_DB1M);
-			}
-		}
-	}
-	int split = 0;
-	uint32_t banksize;
-	if (use_dual_bank) {
-		banksize = flashsize << 9; /* flas split on two sectors. */
-		split = (flashsize == 0x400) ? 8 : 12;
-	}
-	else
-		banksize = flashsize << 10;
-	if (large_sectors) {
-		uint32_t remains = banksize - 0x40000;
-		/* 256 k in small sectors.*/
-		stm32f4_add_flash(t, ITCM_BASE, 0x20000,  0x8000, 0, split);
-		stm32f4_add_flash(t, 0x0220000, 0x20000, 0x20000, 4, split);
-		stm32f4_add_flash(t, 0x0240000, remains, 0x40000, 5, split);
-		stm32f4_add_flash(t, AXIM_BASE, 0x20000,  0x8000, 0, split);
-		stm32f4_add_flash(t, 0x8020000, 0x20000, 0x20000, 4, split);
-		stm32f4_add_flash(t, 0x8040000, remains, 0x40000, 5, split);
-	} else {
-		uint32_t remains = banksize - 0x20000; /* 128 k in small sectors.*/
-		if (is_f7) {
-			stm32f4_add_flash(t, ITCM_BASE, 0x10000,  0x4000,  0, split);
-			stm32f4_add_flash(t, 0x0210000, 0x10000, 0x10000,  4, split);
-			stm32f4_add_flash(t, 0x0220000, remains, 0x20000,  5, split);
-		}
-		stm32f4_add_flash(t, 0x8000000, 0x10000,  0x4000,  0, split);
-		stm32f4_add_flash(t, 0x8010000, 0x10000, 0x10000,  4, split);
-		stm32f4_add_flash(t, 0x8020000, remains, 0x20000,  5, split);
-		if (use_dual_bank) {
-			if (is_f7) {
-				uint32_t bk1 = ITCM_BASE + banksize;
-				stm32f4_add_flash(t, bk1          , 0x10000,  0x4000, 0, split);
-				stm32f4_add_flash(t, bk1 + 0x10000, 0x10000, 0x10000, 4, split);
-				stm32f4_add_flash(t, bk1 + 0x20000, remains, 0x20000, 5, split);
-			}
-			uint32_t bk2 = 0x8000000 + banksize;
-			stm32f4_add_flash(t, bk2          , 0x10000,  0x4000, 16, split);
-			stm32f4_add_flash(t, bk2 + 0x10000, 0x10000, 0x10000, 20, split);
-			stm32f4_add_flash(t, bk2 + 0x20000, remains, 0x20000, 21, split);
-		}
-	}
-	return true;
-}
-
-static void stm32f4_flash_unlock(target *t)
-{
-	if (target_mem_read32(t, FLASH_CR) & FLASH_CR_LOCK) {
-		/* Enable FPEC controller access */
-		target_mem_write32(t, FLASH_KEYR, KEY1);
-		target_mem_write32(t, FLASH_KEYR, KEY2);
-	}
-}
-
-static int stm32f4_flash_erase(struct target_flash *f, target_addr addr,
-							   size_t len)
-{
-	target *t = f->t;
-	struct stm32f4_flash *sf = (struct stm32f4_flash *)f;
-	uint32_t sr;
-	/* No address translation is needed here, as we erase by sector number */
-	uint8_t sector = sf->base_sector + (addr - f->start)/f->blocksize;
-	stm32f4_flash_unlock(t);
-
-	while(len) {
-		uint32_t cr = FLASH_CR_EOPIE | FLASH_CR_ERRIE | FLASH_CR_SER |
-		              (sector << 3);
-		/* Flash page erase instruction */
-		target_mem_write32(t, FLASH_CR, cr);
-		/* write address to FMA */
-		target_mem_write32(t, FLASH_CR, cr | FLASH_CR_STRT);
-
-		/* Read FLASH_SR to poll for BSY bit */
-		while(target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
-			if(target_check_error(t)) {
-				DEBUG("stm32f4 flash erase: comm error\n");
-				return -1;
-			}
-		len -= f->blocksize;
-		sector++;
-		if ((sf->bank_split) && (sector == sf->bank_split))
-			sector = 16;
-	}
-
-	/* Check for error */
-	sr = target_mem_read32(t, FLASH_SR);
-	if(sr & SR_ERROR_MASK) {
-		DEBUG("stm32f4 flash erase: sr error: 0x%" PRIu32 "\n", sr);
-		return -1;
-	}
-	return 0;
-}
-
-static int stm32f4_flash_write(struct target_flash *f,
-                               target_addr dest, const void *src, size_t len)
-{
-	/* Translate ITCM addresses to AXIM */
-	if ((dest >= ITCM_BASE) && (dest < AXIM_BASE)) {
-		dest = AXIM_BASE + (dest - ITCM_BASE);
-	}
-
-	/* Write buffer to target ram call stub */
-	if (((struct stm32f4_flash *)f)->psize == 32)
-		target_mem_write(f->t, SRAM_BASE, stm32f4_flash_write_x32_stub,
-		                 sizeof(stm32f4_flash_write_x32_stub));
-	else
-		target_mem_write(f->t, SRAM_BASE, stm32f4_flash_write_x8_stub,
-		                 sizeof(stm32f4_flash_write_x8_stub));
-	target_mem_write(f->t, STUB_BUFFER_BASE, src, len);
-	return cortexm_run_stub(f->t, SRAM_BASE, dest,
-	                        STUB_BUFFER_BASE, len, 0);
-}
-
-static bool stm32f4_cmd_erase_mass(target *t)
-{
-	const char spinner[] = "|/-\\";
-	int spinindex = 0;
-	struct target_flash *f = t->flash;
-	struct stm32f4_flash *sf = (struct stm32f4_flash *)f;
-
-	tc_printf(t, "Erasing flash... This may take a few seconds.  ");
-	stm32f4_flash_unlock(t);
-
-	/* Flash mass erase start instruction */
-	uint32_t cr =  FLASH_CR_MER;
-	if (sf->bank_split)
-		cr |=  FLASH_CR_MER1;
-	target_mem_write32(t, FLASH_CR, cr);
-	target_mem_write32(t, FLASH_CR, cr | FLASH_CR_STRT);
-
-	/* Read FLASH_SR to poll for BSY bit */
-	while (target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY) {
-		tc_printf(t, "\b%c", spinner[spinindex++ % 4]);
-		if(target_check_error(t)) {
-			tc_printf(t, "\n");
-			return false;
-		}
-	}
-	tc_printf(t, "\n");
-
-	/* Check for error */
-	uint32_t sr = target_mem_read32(t, FLASH_SR);
-	if ((sr & SR_ERROR_MASK) || !(sr & SR_EOP))
-		return false;
-
-	return true;
-}
-
-/* Dev   | DOC  |Rev|ID |OPTCR    |OPTCR   |OPTCR1   |OPTCR1 | OPTCR2
-                    |hex|default  |reserved|default  |resvd  | default|resvd
- * F20x  |pm0059|5.1|411|0FFFAAED |F0000010|
- * F40x  |rm0090|11 |413|0FFFAAED |F0000010|
- * F42x  |rm0090|11 |419|0FFFAAED |30000000|0FFF0000 |F000FFFF
- * F446  |rm0390| 2 |421|0FFFAAED |7F000010|
- * F401BC|rm0368| 3 |423|0FFFAAED |7FC00010|
- * F411  |rm0383| 2 |431|0FFFAAED |7F000010|
- * F401DE|rm0368| 3 |433|0FFFAAED |7F000010|
- * F46x  |rm0386| 2 |434|0FFFAAED |30000000|0FFF0000 |F000FFFF
- * F412  |rm0402| 4 |441|0FFFAAED*|70000010|
- * F74x  |rm0385| 4 |449|C0FFAAFD |3F000000|00400080*|00000000
- * F76x  |rm0410| 2 |451|FFFFAAFD*|00000000|00400080*|00000000
- * F72x  |rm0431| 1 |452|C0FFAAFD |3F000000|00400080*|00000000|00000000|800000FF
- * F410  |rm0401| 2 |458|0FFFAAED*|7FE00010|
- * F413  |rm0430| 2 |463|7FFFAAED*|00000010|
- *
- * * Documentation for F7 with OPTCR1 default = 0fff7f0080 seems wrong!
- * * Documentation for F412 with OPTCR default = 0ffffffed seems wrong!
- * * Documentation for F413 with OPTCR default = 0ffffffed seems wrong!
- */
-
-bool optcr_mask(target *t, uint32_t *val)
-{
-	switch (t->idcode) {
-	case ID_STM32F20X:
-	case ID_STM32F40X:
-		val[0] &= ~0xF0000010;
-		break;
-	case ID_STM32F46X:
-	case ID_STM32F42X:
-		val[0] &= ~0x30000000;
-		val[1] &=  0x0fff0000;
-		break;
-	case ID_STM32F401C:
-		val[0] &= ~0x7FC00010;
-		break;
-	case ID_STM32F446:
-	case ID_STM32F411:
-	case ID_STM32F401E:
-		val[0] &= ~0x7F000010;
-		break;
-	case ID_STM32F410:
-		val[0] &= ~0x7FE00010;
-		break;
-	case ID_STM32F412:
-		val[0] &= ~0x70000010;
-		break;
-	case ID_STM32F413:
-		val[0] &= ~0x00000010;
-		break;
-	case ID_STM32F72X:
-		val[2] &=  ~0x800000ff;
-		/* Fall through*/
-	case ID_STM32F74X:
-		val[0] &= ~0x3F000000;
-		break;
-	case ID_STM32F76X:
-		break;
-	default:
-		return false;
-	}
-	return true;
-}
-
-static bool stm32f4_option_write(target *t, uint32_t *val, int count)
-{
-	target_mem_write32(t, FLASH_OPTKEYR, OPTKEY1);
-	target_mem_write32(t, FLASH_OPTKEYR, OPTKEY2);
-	while (target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
-		if(target_check_error(t))
-			return -1;
-
-	/* WRITE option bytes instruction */
-	if (((t->idcode == ID_STM32F42X) || (t->idcode == ID_STM32F46X) ||
-		 (t->idcode == ID_STM32F72X) || (t->idcode == ID_STM32F74X) ||
-		 (t->idcode == ID_STM32F76X)) && (count > 1))
-	    /* Checkme: Do we need to read old value and then set it? */
-		target_mem_write32(t, FLASH_OPTCR + 4, val[1]);
-	if ((t->idcode == ID_STM32F72X) && (count > 2))
-			target_mem_write32(t, FLASH_OPTCR + 8, val[2]);
-
-	target_mem_write32(t, FLASH_OPTCR, val[0]);
-	target_mem_write32(t, FLASH_OPTCR, val[0] | FLASH_OPTCR_OPTSTRT);
-	/* Read FLASH_SR to poll for BSY bit */
-	while(target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
-		if(target_check_error(t))
-			return false;
-	target_mem_write32(t, FLASH_OPTCR, FLASH_OPTCR_OPTLOCK);
-	return true;
-}
-
-static bool stm32f4_option_write_default(target *t)
-{
-	uint32_t val[3];
-	switch (t->idcode) {
-	case ID_STM32F42X:
-	case ID_STM32F46X:
-		val[0] = 0x0FFFAAED;
-		val[1] = 0x0FFF0000;
-		return stm32f4_option_write(t, val, 2);
-	case ID_STM32F72X:
-		val[0] = 0xC0FFAAFD;
-		val[1] = 0x00400080;
-		val[2] = 0;
-		return stm32f4_option_write(t, val, 3);
-	case ID_STM32F74X:
-		val[0] = 0xC0FFAAFD;
-		val[1] = 0x00400080;
-		return stm32f4_option_write(t, val, 2);
-	case ID_STM32F76X:
-		val[0] = 0xFFFFAAFD;
-		val[1] = 0x00400080;
-		return stm32f4_option_write(t, val, 2);
-	case ID_STM32F413:
-		val[0] = 0x7FFFAAFD;
-		return stm32f4_option_write(t, val, 1);
-	default:
-		val[0] = 0x0FFFAAED;
-		return stm32f4_option_write(t, val, 1);
-	}
-}
-
-static bool stm32f4_cmd_option(target *t, int argc, char *argv[])
-{
-	uint32_t start = 0x1FFFC000, val[3];
-	int count = 0, readcount = 1;
-
-	switch (t->idcode) {
-	case ID_STM32F72X: /* STM32F72|3 */
-		readcount++;
-		/* fall through.*/
-	case ID_STM32F74X:
-	case ID_STM32F76X:
-		/* F7 Devices have option bytes at 0x1FFF0000. */
-		start = 0x1FFF0000;
-		readcount++;
-		break;
-	case ID_STM32F42X:
-	case ID_STM32F46X:
-		readcount++;
-	}
-
-	if ((argc == 2) && !strcmp(argv[1], "erase")) {
-		stm32f4_option_write_default(t);
-	}
-	else if ((argc > 1) && !strcmp(argv[1], "write")) {
-		val[0] = strtoul(argv[2], NULL, 0);
-		count++;
-		if (argc > 2) {
-			val[1] = strtoul(argv[3], NULL, 0);
-			count ++;
-		}
-		if (argc > 3) {
-			val[2] = strtoul(argv[4], NULL, 0);
-			count ++;
-		}
-		if (optcr_mask(t, val))
-			stm32f4_option_write(t, val, count);
-		else
-			tc_printf(t, "error\n");
-	} else {
-		tc_printf(t, "usage: monitor option erase\n");
-		tc_printf(t, "usage: monitor option write <OPTCR>");
-		if (readcount > 1)
-			tc_printf(t, " <OPTCR1>");
-		if (readcount > 2)
-			tc_printf(t, " <OPTCR2>");
-		tc_printf(t, "\n");
-	}
-
-	val[0]  = (target_mem_read32(t, start + 8) & 0xffff) << 16;
-	val[0] |= (target_mem_read32(t, start    ) & 0xffff);
-	if (readcount > 1) {
-		if (start == 0x1FFFC000) /* F4 */ {
-			val[1] = target_mem_read32(t, 0x1ffec008);
-			val[1] &= 0xffff;
-			val[1] <<= 16;
-		} else {
-			val[1] =  (target_mem_read32(t, start + 0x18) & 0xffff) << 16;
-			val[1] |= (target_mem_read32(t, start + 0x10) & 0xffff);
-		}
-	}
-	if (readcount > 2) {
-			val[2] =  (target_mem_read32(t, start + 0x28) & 0xffff) << 16;
-			val[2] |= (target_mem_read32(t, start + 0x20) & 0xffff);
-	}
-	optcr_mask(t, val);
-	tc_printf(t, "OPTCR: 0x%08X ", val[0]);
-	if (readcount > 1)
-		tc_printf(t, "OPTCR1: 0x%08lx ", val[1]);
-	if (readcount > 2)
-		tc_printf(t, "OPTCR2: 0x%08lx" , val[2]);
-	tc_printf(t, "\n");
-	return true;
-}
-
-static bool stm32f4_cmd_psize(target *t, int argc, char *argv[])
-{
-	if (argc == 1) {
-		uint8_t psize = 8;
-		for (struct target_flash *f = t->flash; f; f = f->next) {
-			if (f->write == stm32f4_flash_write) {
-				psize = ((struct stm32f4_flash *)f)->psize;
-			}
-		}
-		tc_printf(t, "Flash write parallelism: %s\n",
-		          psize == 32 ? "x32" : "x8");
-	} else {
-		uint8_t psize;
-		if (!strcmp(argv[1], "x8")) {
-			psize = 8;
-		} else if (!strcmp(argv[1], "x32")) {
-			psize = 32;
-		} else {
-			tc_printf(t, "usage: monitor psize (x8|x32)\n");
-			return false;
-		}
-		for (struct target_flash *f = t->flash; f; f = f->next) {
-			if (f->write == stm32f4_flash_write) {
-				((struct stm32f4_flash *)f)->psize = psize;
-			}
-		}
-	}
-	return true;
-}
diff --git a/src/target/stm32l0.c b/src/target/stm32l0.c
deleted file mode 100644
index ea22cb9..0000000
--- a/src/target/stm32l0.c
+++ /dev/null
@@ -1,769 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2014,2015 Marc Singer <elf@woollysoft.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/* Description
-   -----------
-
-   This is an implementation of the target-specific functions for the
-   STM32L0x[1] and STM32L1x[2] families of ST Microelectronics MCUs,
-   Cortex M0+ SOCs.  The NVM interface is substantially similar to the
-   STM32L1x parts.  This module is written to better generalize the
-   NVM interface and to provide more features.
-
-   [1] ST Microelectronics Document RM0377 (DocID025942), "Reference
-       manual for Ultra-low-power STM32L0x1 advanced ARM-based 32-bit
-       MCUs," April 2014.
-
-   [2] ST Microelectronics Document RM0038 (DocID15965, "..."Reference
-       manual for STM32L100xx, STM32L151xx, STM32L152xx and STM32L162xx
-       advanced ARM®-based 32-bit MCUs, " July 2014
-
-
-   NOTES
-   =====
-
-   o Mass erase unimplemented.  The method for performing a mass erase
-     is to set the options for read protection, reload the option
-     bytes, set options for no protection, and then reload the option
-     bytes again.  The command fails because we lose contact with the
-     target when we perform the option byte reload.  For the time
-     being, the command is disabled.
-
-     The body of the function was the following.  It is left here for
-     reference in case someone either discovers what is wrong with
-     these lines, or a change is made to the emulator that allows it
-     to regain control of the target after the option byte reload.
-
-       stm32l0_option_write(t, 0x1ff80000, 0xffff0000);
-       target_mem_write32(target, STM32L0_NVM_PECR, STM32L0_NVM_PECR_OBL_LAUNCH);
-       stm32l0_option_write(t, 0x1ff80000, 0xff5500aa);
-       target_mem_write32(target, STM32L0_NVM_PECR, STM32L0_NVM_PECR_OBL_LAUNCH);
-
-       uint32_t sr;
-       do {
-         sr = target_mem_read32(target, STM32L0_NVM_SR);
-       } while (sr & STM32L0_NVM_SR_BSY);
-
-   o Errors.  We probably should clear SR errors immediately after
-     detecting them.  If we don't then we always must wait for the NVM
-     module to complete the last operation before we can start another.
-
-   o There are minor inconsistencies between the stm32l0 and the
-     stm32l1 in when handling NVM operations.
-
-   o On the STM32L1xx, PECR can only be changed when the NVM
-     hardware is idle.  The STM32L0xx allows the PECR to be updated
-     while an operation is in progress.
-
-*/
-
-#include "general.h"
-#include "target.h"
-#include "target_internal.h"
-#include "cortexm.h"
-
-#define STM32Lx_NVM_PECR(p)     ((p) + 0x04)
-#define STM32Lx_NVM_PEKEYR(p)   ((p) + 0x0C)
-#define STM32Lx_NVM_PRGKEYR(p)  ((p) + 0x10)
-#define STM32Lx_NVM_OPTKEYR(p)  ((p) + 0x14)
-#define STM32Lx_NVM_SR(p)       ((p) + 0x18)
-#define STM32Lx_NVM_OPTR(p)     ((p) + 0x1C)
-
-#define STM32L0_NVM_PHYS             (0x40022000ul)
-#define STM32L0_NVM_OPT_SIZE         (12)
-#define STM32L0_NVM_EEPROM_CAT1_SIZE (1*512)
-#define STM32L0_NVM_EEPROM_CAT2_SIZE (1*1024)
-#define STM32L0_NVM_EEPROM_CAT3_SIZE (2*1024)
-#define STM32L0_NVM_EEPROM_CAT5_SIZE (6*1024)
-
-#define STM32L1_NVM_PHYS             (0x40023c00ul)
-#define STM32L1_NVM_OPT_SIZE         (32)
-#define STM32L1_NVM_EEPROM_SIZE      (16*1024)
-
-#define STM32Lx_NVM_OPT_PHYS         0x1ff80000ul
-#define STM32Lx_NVM_EEPROM_PHYS      0x08080000ul
-
-#define STM32Lx_NVM_PEKEY1           (0x89abcdeful)
-#define STM32Lx_NVM_PEKEY2           (0x02030405ul)
-#define STM32Lx_NVM_PRGKEY1          (0x8c9daebful)
-#define STM32Lx_NVM_PRGKEY2          (0x13141516ul)
-#define STM32Lx_NVM_OPTKEY1          (0xfbead9c8ul)
-#define STM32Lx_NVM_OPTKEY2          (0x24252627ul)
-
-#define STM32Lx_NVM_PECR_OBL_LAUNCH  (1<<18)
-#define STM32Lx_NVM_PECR_ERRIE       (1<<17)
-#define STM32Lx_NVM_PECR_EOPIE       (1<<16)
-#define STM32Lx_NVM_PECR_FPRG        (1<<10)
-#define STM32Lx_NVM_PECR_ERASE       (1<< 9)
-#define STM32Lx_NVM_PECR_FIX         (1<< 8) /* FTDW */
-#define STM32Lx_NVM_PECR_DATA        (1<< 4)
-#define STM32Lx_NVM_PECR_PROG        (1<< 3)
-#define STM32Lx_NVM_PECR_OPTLOCK     (1<< 2)
-#define STM32Lx_NVM_PECR_PRGLOCK     (1<< 1)
-#define STM32Lx_NVM_PECR_PELOCK      (1<< 0)
-
-#define STM32Lx_NVM_SR_NOTZEROERR    (1<<16)
-#define STM32Lx_NVM_SR_SIZERR        (1<<10)
-#define STM32Lx_NVM_SR_PGAERR        (1<<9)
-#define STM32Lx_NVM_SR_WRPERR        (1<<8)
-#define STM32Lx_NVM_SR_EOP           (1<<1)
-#define STM32Lx_NVM_SR_BSY           (1<<0)
-#define STM32Lx_NVM_SR_ERR_M         (STM32Lx_NVM_SR_WRPERR | \
-                                      STM32Lx_NVM_SR_PGAERR | \
-                                      STM32Lx_NVM_SR_SIZERR | \
-                                      STM32Lx_NVM_SR_NOTZEROERR)
-
-#define STM32L0_NVM_OPTR_BOOT1       (1<<31)
-#define STM32Lx_NVM_OPTR_WDG_SW      (1<<20)
-#define STM32L0_NVM_OPTR_WPRMOD      (1<<8)
-#define STM32Lx_NVM_OPTR_RDPROT_S    (0)
-#define STM32Lx_NVM_OPTR_RDPROT_M    (0xff)
-#define STM32Lx_NVM_OPTR_RDPROT_0    (0xaa)
-#define STM32Lx_NVM_OPTR_RDPROT_2    (0xcc)
-
-#define STM32L1_NVM_OPTR_nBFB2       (1<<23)
-#define STM32L1_NVM_OPTR_nRST_STDBY  (1<<22)
-#define STM32L1_NVM_OPTR_nRST_STOP   (1<<21)
-#define STM32L1_NVM_OPTR_BOR_LEV_S   (16)
-#define STM32L1_NVM_OPTR_BOR_LEV_M   (0xf)
-#define STM32L1_NVM_OPTR_SPRMOD      (1<<8)
-
-static int stm32lx_nvm_prog_erase(struct target_flash* f,
-                                  target_addr addr, size_t len);
-static int stm32lx_nvm_prog_write(struct target_flash* f,
-                                  target_addr destination,
-                                  const void* src,
-                                  size_t size);
-
-static int stm32lx_nvm_data_erase(struct target_flash* f,
-                                  target_addr addr, size_t len);
-static int stm32lx_nvm_data_write(struct target_flash* f,
-                                  target_addr destination,
-                                  const void* source,
-                                  size_t size);
-
-static bool stm32lx_cmd_option     (target* t, int argc, char** argv);
-static bool stm32lx_cmd_eeprom     (target* t, int argc, char** argv);
-
-static const struct command_s stm32lx_cmd_list[] = {
-        { "option",		(cmd_handler) stm32lx_cmd_option,
-          "Manipulate option bytes"},
-        { "eeprom",		(cmd_handler) stm32lx_cmd_eeprom,
-          "Manipulate EEPROM(NVM data) memory"},
-        { NULL, NULL, NULL },
-};
-
-enum {
-        STM32L0_DBGMCU_IDCODE_PHYS = 0x40015800,
-        STM32L1_DBGMCU_IDCODE_PHYS = 0xe0042000,
-};
-
-static bool stm32lx_is_stm32l1(target* t)
-{
-        switch (t->idcode) {
-        case 0x457:                   /* STM32L0xx Cat1 */
-        case 0x425:                   /* STM32L0xx Cat2 */
-        case 0x417:                   /* STM32L0xx Cat3 */
-        case 0x447:                   /* STM32L0xx Cat5 */
-               return false;
-        default:                      /* STM32L1xx */
-                return true;
-        }
-}
-
-static uint32_t stm32lx_nvm_eeprom_size(target *t)
-{
-        switch (t->idcode) {
-        case 0x457:                   /* STM32L0xx Cat1 */
-                return STM32L0_NVM_EEPROM_CAT1_SIZE;
-        case 0x425:                   /* STM32L0xx Cat2 */
-                return STM32L0_NVM_EEPROM_CAT2_SIZE;
-        case 0x417:                   /* STM32L0xx Cat3 */
-                return STM32L0_NVM_EEPROM_CAT3_SIZE;
-        case 0x447:                   /* STM32L0xx Cat5 */
-                return STM32L0_NVM_EEPROM_CAT5_SIZE;
-        default:                      /* STM32L1xx */
-                return STM32L1_NVM_EEPROM_SIZE;
-        }
-}
-
-static uint32_t stm32lx_nvm_phys(target *t)
-{
-        switch (t->idcode) {
-        case 0x457:                   /* STM32L0xx Cat1 */
-        case 0x425:                   /* STM32L0xx Cat2 */
-        case 0x417:                   /* STM32L0xx Cat3 */
-        case 0x447:                   /* STM32L0xx Cat5 */
-                return STM32L0_NVM_PHYS;
-        default:                      /* STM32L1xx */
-                return STM32L1_NVM_PHYS;
-        }
-}
-
-static uint32_t stm32lx_nvm_option_size(target *t)
-{
-        switch (t->idcode) {
-        case 0x457:                   /* STM32L0xx Cat1 */
-        case 0x425:                   /* STM32L0xx Cat2 */
-        case 0x417:                   /* STM32L0xx Cat3 */
-        case 0x447:                   /* STM32L0xx Cat5 */
-                return STM32L0_NVM_OPT_SIZE;
-        default:                      /* STM32L1xx */
-                return STM32L1_NVM_OPT_SIZE;
-        }
-}
-
-static void stm32l_add_flash(target *t,
-                             uint32_t addr, size_t length, size_t erasesize)
-{
-	struct target_flash *f = calloc(1, sizeof(*f));
-	f->start = addr;
-	f->length = length;
-	f->blocksize = erasesize;
-	f->erase = stm32lx_nvm_prog_erase;
-	f->write = target_flash_write_buffered;
-	f->done = target_flash_done_buffered;
-	f->write_buf = stm32lx_nvm_prog_write;
-	f->buf_size = erasesize/2;
-	target_add_flash(t, f);
-}
-
-static void stm32l_add_eeprom(target *t, uint32_t addr, size_t length)
-{
-	struct target_flash *f = calloc(1, sizeof(*f));
-	f->start = addr;
-	f->length = length;
-	f->blocksize = 4;
-	f->erase = stm32lx_nvm_data_erase;
-	f->write = stm32lx_nvm_data_write;
-	f->align = 1;
-	target_add_flash(t, f);
-}
-
-/** Query MCU memory for an indication as to whether or not the
-    currently attached target is served by this module.  We detect the
-    STM32L0xx parts as well as the STM32L1xx's. */
-bool stm32l0_probe(target* t)
-{
-	uint32_t idcode;
-
-	idcode = target_mem_read32(t, STM32L1_DBGMCU_IDCODE_PHYS) & 0xfff;
-	switch (idcode) {
-	case 0x416:                   /* CAT. 1 device */
-	case 0x429:                   /* CAT. 2 device */
-	case 0x427:                   /* CAT. 3 device */
-	case 0x436:                   /* CAT. 4 device */
-	case 0x437:                   /* CAT. 5 device  */
-		t->idcode = idcode;
-		t->driver = "STM32L1x";
-		target_add_ram(t, 0x20000000, 0x14000);
-		stm32l_add_flash(t, 0x8000000, 0x80000, 0x100);
-		//stm32l_add_eeprom(t, 0x8080000, 0x4000);
-		target_add_commands(t, stm32lx_cmd_list, "STM32L1x");
-		return true;
-	}
-
-	idcode = target_mem_read32(t, STM32L0_DBGMCU_IDCODE_PHYS) & 0xfff;
-	switch (idcode) {
-	case 0x457:                   /* STM32L0xx Cat1 */
-	case 0x425:                   /* STM32L0xx Cat2 */
-	case 0x417:                   /* STM32L0xx Cat3 */
-	case 0x447:                   /* STM32L0xx Cat5 */
-		t->idcode = idcode;
-		t->driver = "STM32L0x";
-		target_add_ram(t, 0x20000000, 0x5000);
-		stm32l_add_flash(t, 0x8000000, 0x10000, 0x80);
-		stm32l_add_flash(t, 0x8010000, 0x10000, 0x80);
-		stm32l_add_flash(t, 0x8020000, 0x10000, 0x80);
-		stm32l_add_eeprom(t, 0x8080000, 0x1800);
-		target_add_commands(t, stm32lx_cmd_list, "STM32L0x");
-		return true;
-	}
-
-	return false;
-}
-
-
-/** Lock the NVM control registers preventing writes or erases. */
-static void stm32lx_nvm_lock(target *t, uint32_t nvm)
-{
-        target_mem_write32(t, STM32Lx_NVM_PECR(nvm), STM32Lx_NVM_PECR_PELOCK);
-}
-
-
-/** Unlock the NVM control registers for modifying program or
-    data flash.  Returns true if the unlock succeeds. */
-static bool stm32lx_nvm_prog_data_unlock(target* t, uint32_t nvm)
-{
-        /* Always lock first because that's the only way to know that the
-           unlock can succeed on the STM32L0's. */
-        target_mem_write32(t, STM32Lx_NVM_PECR(nvm),  STM32Lx_NVM_PECR_PELOCK);
-        target_mem_write32(t, STM32Lx_NVM_PEKEYR(nvm),  STM32Lx_NVM_PEKEY1);
-        target_mem_write32(t, STM32Lx_NVM_PEKEYR(nvm),  STM32Lx_NVM_PEKEY2);
-        target_mem_write32(t, STM32Lx_NVM_PRGKEYR(nvm), STM32Lx_NVM_PRGKEY1);
-        target_mem_write32(t, STM32Lx_NVM_PRGKEYR(nvm), STM32Lx_NVM_PRGKEY2);
-
-        return !(target_mem_read32(t, STM32Lx_NVM_PECR(nvm))
-                 & STM32Lx_NVM_PECR_PRGLOCK);
-}
-
-
-/** Unlock the NVM control registers for modifying option bytes.
-    Returns true if the unlock succeeds. */
-static bool stm32lx_nvm_opt_unlock(target *t, uint32_t nvm)
-{
-        /* Always lock first because that's the only way to know that the
-           unlock can succeed on the STM32L0's. */
-        target_mem_write32(t, STM32Lx_NVM_PECR(nvm),  STM32Lx_NVM_PECR_PELOCK);
-        target_mem_write32(t, STM32Lx_NVM_PEKEYR(nvm),  STM32Lx_NVM_PEKEY1);
-        target_mem_write32(t, STM32Lx_NVM_PEKEYR(nvm),  STM32Lx_NVM_PEKEY2);
-        target_mem_write32(t, STM32Lx_NVM_OPTKEYR(nvm), STM32Lx_NVM_OPTKEY1);
-        target_mem_write32(t, STM32Lx_NVM_OPTKEYR(nvm), STM32Lx_NVM_OPTKEY2);
-
-        return !(target_mem_read32(t, STM32Lx_NVM_PECR(nvm))
-                 & STM32Lx_NVM_PECR_OPTLOCK);
-}
-
-/** Erase a region of program flash using operations through the debug
-    interface.  This is slower than stubbed versions(see NOTES).  The
-    flash array is erased for all pages from addr to addr+len
-    inclusive.  NVM register file address chosen from target. */
-static int stm32lx_nvm_prog_erase(struct target_flash* f,
-                                  target_addr addr, size_t len)
-{
-	target *t = f->t;
-	const size_t page_size = f->blocksize;
-	const uint32_t nvm = stm32lx_nvm_phys(t);
-
-	if (!stm32lx_nvm_prog_data_unlock(t, nvm))
-	        return -1;
-
-	/* Flash page erase instruction */
-	target_mem_write32(t, STM32Lx_NVM_PECR(nvm),
-	                   STM32Lx_NVM_PECR_ERASE | STM32Lx_NVM_PECR_PROG);
-
-	uint32_t pecr = target_mem_read32(t, STM32Lx_NVM_PECR(nvm));
-	if ((pecr & (STM32Lx_NVM_PECR_PROG | STM32Lx_NVM_PECR_ERASE))
-	   != (STM32Lx_NVM_PECR_PROG | STM32Lx_NVM_PECR_ERASE))
-		return -1;
-
-	/* Clear errors.  Note that this only works when we wait for the NVM
-	   block to complete the last operation. */
-	target_mem_write32(t, STM32Lx_NVM_SR(nvm), STM32Lx_NVM_SR_ERR_M);
-
-	while (len > 0) {
-		/* Write first word of page to 0 */
-		target_mem_write32(t, addr, 0);
-
-		len  -= page_size;
-		addr += page_size;
-	}
-
-	/* Disable further programming by locking PECR */
-	stm32lx_nvm_lock(t, nvm);
-
-	/* Wait for completion or an error */
-	uint32_t sr;
-	do {
-		sr = target_mem_read32(t, STM32Lx_NVM_SR(nvm));
-	} while (sr & STM32Lx_NVM_SR_BSY);
-
-	if ((sr & STM32Lx_NVM_SR_ERR_M) || !(sr & STM32Lx_NVM_SR_EOP) ||
-	    target_check_error(t))
-			return -1;
-
-	return 0;
-}
-
-
-/** Write to program flash using operations through the debug
-    interface. */
-static int stm32lx_nvm_prog_write(struct target_flash *f,
-                                  target_addr dest,
-                                  const void* src,
-                                  size_t size)
-{
-	target *t = f->t;
-	const uint32_t nvm = stm32lx_nvm_phys(t);
-
-	if (!stm32lx_nvm_prog_data_unlock(t, nvm))
-	        return -1;
-
-	/* Wait for BSY to clear because we cannot write the PECR until
-	   the previous operation completes on STM32Lxxx. */
-	while (target_mem_read32(t, STM32Lx_NVM_SR(nvm))
-	       & STM32Lx_NVM_SR_BSY)
-		if (target_check_error(t))
-			return -1;
-
-	target_mem_write32(t, STM32Lx_NVM_PECR(nvm),
-	                   STM32Lx_NVM_PECR_PROG | STM32Lx_NVM_PECR_FPRG);
-	target_mem_write(t, dest, src, size);
-
-	/* Disable further programming by locking PECR */
-	stm32lx_nvm_lock(t, nvm);
-
-	/* Wait for completion or an error */
-	uint32_t sr;
-	do {
-		sr = target_mem_read32(t, STM32Lx_NVM_SR(nvm));
-	} while (sr & STM32Lx_NVM_SR_BSY);
-
-	if ((sr & STM32Lx_NVM_SR_ERR_M) || !(sr & STM32Lx_NVM_SR_EOP) ||
-	    target_check_error(t))
-			return -1;
-
-	return 0;
-}
-
-
-/** Erase a region of data flash using operations through the debug
-    interface .  The flash is erased for all pages from addr to
-    addr+len, inclusive, on a word boundary.  NVM register file
-    address chosen from target. */
-static int stm32lx_nvm_data_erase(struct target_flash *f,
-                                  target_addr addr, size_t len)
-{
-	target *t = f->t;
-	const size_t page_size = f->blocksize;
-	const uint32_t nvm = stm32lx_nvm_phys(t);
-
-	/* Word align */
-	len += (addr & 3);
-	addr &= ~3;
-
-	if (!stm32lx_nvm_prog_data_unlock(t, nvm))
-		return -1;
-
-	/* Flash data erase instruction */
-	target_mem_write32(t, STM32Lx_NVM_PECR(nvm),
-	                   STM32Lx_NVM_PECR_ERASE | STM32Lx_NVM_PECR_DATA);
-
-	uint32_t pecr = target_mem_read32(t, STM32Lx_NVM_PECR(nvm));
-	if ((pecr & (STM32Lx_NVM_PECR_ERASE | STM32Lx_NVM_PECR_DATA))
-	   != (STM32Lx_NVM_PECR_ERASE | STM32Lx_NVM_PECR_DATA))
-		return -1;
-
-	while (len > 0) {
-		/* Write first word of page to 0 */
-		target_mem_write32(t, addr, 0);
-
-		len  -= page_size;
-		addr += page_size;
-	}
-
-	/* Disable further programming by locking PECR */
-	stm32lx_nvm_lock(t, nvm);
-
-	/* Wait for completion or an error */
-	uint32_t sr;
-	do {
-		sr = target_mem_read32(t, STM32Lx_NVM_SR(nvm));
-	} while (sr & STM32Lx_NVM_SR_BSY);
-
-	if ((sr & STM32Lx_NVM_SR_ERR_M) || !(sr & STM32Lx_NVM_SR_EOP) ||
-	    target_check_error(t))
-			return -1;
-
-	return 0;
-}
-
-
-/** Write to data flash using operations through the debug interface.
-    NVM register file address chosen from target.  Unaligned
-    destination writes are supported (though unaligned sources are
-    not). */
-static int stm32lx_nvm_data_write(struct target_flash *f,
-                                  target_addr destination,
-                                  const void* src,
-                                  size_t size)
-{
-	target *t = f->t;
-	const uint32_t nvm = stm32lx_nvm_phys(t);
-	const bool is_stm32l1 = stm32lx_is_stm32l1(t);
-	uint32_t* source = (uint32_t*) src;
-
-	if (!stm32lx_nvm_prog_data_unlock(t, nvm))
-		return -1;
-
-	target_mem_write32(t, STM32Lx_NVM_PECR(nvm),
-	                   is_stm32l1 ? 0 : STM32Lx_NVM_PECR_DATA);
-
-	while (size) {
-		size -= 4;
-		uint32_t v = *source++;
-		target_mem_write32(t, destination, v);
-		destination += 4;
-
-		if (target_check_error(t))
-			return -1;
-	}
-
-	/* Disable further programming by locking PECR */
-	stm32lx_nvm_lock(t, nvm);
-
-	/* Wait for completion or an error */
-	uint32_t sr;
-	do {
-		sr = target_mem_read32(t, STM32Lx_NVM_SR(nvm));
-	} while (sr & STM32Lx_NVM_SR_BSY);
-
-	if ((sr & STM32Lx_NVM_SR_ERR_M) || !(sr & STM32Lx_NVM_SR_EOP) ||
-	    target_check_error(t))
-			return -1;
-
-	return 0;
-}
-
-
-/** Write one option word.  The address is the physical address of the
-    word and the value is a complete word value.  The caller is
-    responsible for making sure that the value satisfies the proper
-    format where the upper 16 bits are the 1s complement of the lower
-    16 bits.  The funtion returns when the operation is complete.
-    The return value is true if the write succeeded. */
-static bool stm32lx_option_write(target *t, uint32_t address, uint32_t value)
-{
-        const uint32_t nvm = stm32lx_nvm_phys(t);
-
-        /* Erase and program option in one go. */
-        target_mem_write32(t, STM32Lx_NVM_PECR(nvm), STM32Lx_NVM_PECR_FIX);
-        target_mem_write32(t, address, value);
-
-        uint32_t sr;
-        do {
-                sr = target_mem_read32(t, STM32Lx_NVM_SR(nvm));
-        } while (sr & STM32Lx_NVM_SR_BSY);
-
-        return !(sr & STM32Lx_NVM_SR_ERR_M);
-}
-
-
-/** Write one eeprom value.  This version is more flexible than that
-    bulk version used for writing data from the executable file.  The
-    address is the physical address of the word and the value is a
-    complete word value.  The funtion returns when the operation is
-    complete.  The return value is true if the write succeeded.
-    FWIW, byte writing isn't supported because the adiv5 layer
-    doesn't support byte-level operations. */
-static bool stm32lx_eeprom_write(target *t, uint32_t address,
-                                 size_t cb, uint32_t value)
-{
-        const uint32_t nvm        = stm32lx_nvm_phys(t);
-        const bool     is_stm32l1 = stm32lx_is_stm32l1(t);
-
-        /* Clear errors. */
-        target_mem_write32(t, STM32Lx_NVM_SR(nvm), STM32Lx_NVM_SR_ERR_M);
-
-        /* Erase and program option in one go. */
-        target_mem_write32(t, STM32Lx_NVM_PECR(nvm),
-                           (is_stm32l1 ? 0 : STM32Lx_NVM_PECR_DATA)
-                           | STM32Lx_NVM_PECR_FIX);
-        if (cb == 4)
-                target_mem_write32(t, address, value);
-        else if (cb == 2)
-                target_mem_write16(t, address, value);
-        else if (cb == 1)
-                target_mem_write8(t, address, value);
-        else
-                return false;
-
-        uint32_t sr;
-        do {
-                sr = target_mem_read32(t, STM32Lx_NVM_SR(nvm));
-        } while (sr & STM32Lx_NVM_SR_BSY);
-
-        return !(sr & STM32Lx_NVM_SR_ERR_M);
-}
-
-static bool stm32lx_cmd_option(target* t, int argc, char** argv)
-{
-        const uint32_t nvm      = stm32lx_nvm_phys(t);
-        const size_t   opt_size = stm32lx_nvm_option_size(t);
-
-        if (!stm32lx_nvm_opt_unlock(t, nvm)) {
-                tc_printf(t, "unable to unlock NVM option bytes\n");
-                return true;
-        }
-
-        size_t cb = strlen(argv[1]);
-
-        if (argc == 2 && !strncasecmp(argv[1], "obl_launch", cb)) {
-                target_mem_write32(t, STM32Lx_NVM_PECR(nvm),
-                                   STM32Lx_NVM_PECR_OBL_LAUNCH);
-        }
-        else if (argc == 4 && !strncasecmp(argv[1], "raw", cb)) {
-                uint32_t addr = strtoul(argv[2], NULL, 0);
-                uint32_t val  = strtoul(argv[3], NULL, 0);
-                tc_printf(t, "raw %08x <- %08x\n", addr, val);
-                if (   addr <  STM32Lx_NVM_OPT_PHYS
-                    || addr >= STM32Lx_NVM_OPT_PHYS + opt_size
-                    || (addr & 3))
-                        goto usage;
-                if (!stm32lx_option_write(t, addr, val))
-                        tc_printf(t, "option write failed\n");
-        }
-        else if (argc == 4 && !strncasecmp(argv[1], "write", cb)) {
-                uint32_t addr = strtoul(argv[2], NULL, 0);
-                uint32_t val  = strtoul(argv[3], NULL, 0);
-                val = (val & 0xffff) | ((~val & 0xffff) << 16);
-                tc_printf(t, "write %08x <- %08x\n", addr, val);
-                if (   addr <  STM32Lx_NVM_OPT_PHYS
-                    || addr >= STM32Lx_NVM_OPT_PHYS + opt_size
-                    || (addr & 3))
-                        goto usage;
-                if (!stm32lx_option_write(t, addr, val))
-                        tc_printf(t, "option write failed\n");
-        }
-        else if (argc == 2 && !strncasecmp(argv[1], "show", cb))
-                ;
-        else
-                goto usage;
-
-        /* Report the current option values */
-        for(unsigned i = 0; i < opt_size; i += sizeof(uint32_t)) {
-                uint32_t addr = STM32Lx_NVM_OPT_PHYS + i;
-                uint32_t val = target_mem_read32(t, addr);
-                tc_printf(t, "0x%08x: 0x%04x 0x%04x %s\n",
-                          addr, val & 0xffff, (val >> 16) & 0xffff,
-                          ((val & 0xffff) == ((~val >> 16) & 0xffff))
-                          ? "OK" : "ERR");
-        }
-
-        if (stm32lx_is_stm32l1(t)) {
-                uint32_t optr   = target_mem_read32(t, STM32Lx_NVM_OPTR(nvm));
-                uint8_t  rdprot = (optr >> STM32Lx_NVM_OPTR_RDPROT_S)
-                        & STM32Lx_NVM_OPTR_RDPROT_M;
-                if (rdprot == STM32Lx_NVM_OPTR_RDPROT_0)
-                        rdprot = 0;
-                else if (rdprot == STM32Lx_NVM_OPTR_RDPROT_2)
-                        rdprot = 2;
-                else
-                        rdprot = 1;
-                tc_printf(t, "OPTR: 0x%08x, RDPRT %d, SPRMD %d, "
-                          "BOR %d, WDG_SW %d, nRST_STP %d, nRST_STBY %d, "
-                          "nBFB2 %d\n",
-                          optr, rdprot,
-                          (optr &  STM32L1_NVM_OPTR_SPRMOD)     ? 1 : 0,
-                          (optr >> STM32L1_NVM_OPTR_BOR_LEV_S)
-                           & STM32L1_NVM_OPTR_BOR_LEV_M,
-                          (optr &  STM32Lx_NVM_OPTR_WDG_SW)     ? 1 : 0,
-                          (optr &  STM32L1_NVM_OPTR_nRST_STOP)  ? 1 : 0,
-                          (optr &  STM32L1_NVM_OPTR_nRST_STDBY) ? 1 : 0,
-                          (optr &  STM32L1_NVM_OPTR_nBFB2)      ? 1 : 0);
-        }
-        else {
-                uint32_t optr   = target_mem_read32(t, STM32Lx_NVM_OPTR(nvm));
-                uint8_t  rdprot = (optr >> STM32Lx_NVM_OPTR_RDPROT_S)
-                        & STM32Lx_NVM_OPTR_RDPROT_M;
-                if (rdprot == STM32Lx_NVM_OPTR_RDPROT_0)
-                        rdprot = 0;
-                else if (rdprot == STM32Lx_NVM_OPTR_RDPROT_2)
-                        rdprot = 2;
-                else
-                        rdprot = 1;
-                tc_printf(t, "OPTR: 0x%08x, RDPROT %d, WPRMOD %d, WDG_SW %d, "
-                          "BOOT1 %d\n",
-                          optr, rdprot,
-                          (optr & STM32L0_NVM_OPTR_WPRMOD) ? 1 : 0,
-                          (optr & STM32Lx_NVM_OPTR_WDG_SW) ? 1 : 0,
-                          (optr & STM32L0_NVM_OPTR_BOOT1)  ? 1 : 0);
-        }
-
-        goto done;
-
-usage:
-        tc_printf(t, "usage: monitor option [ARGS]\n");
-        tc_printf(t, "  show                   - Show options in NVM and as"
-                  " loaded\n");
-        tc_printf(t, "  obl_launch             - Reload options from NVM\n");
-        tc_printf(t, "  write <addr> <value16> - Set option half-word; "
-                  "complement computed\n");
-        tc_printf(t, "  raw <addr> <value32>   - Set option word\n");
-        tc_printf(t, "The value of <addr> must be word aligned and from 0x%08x "
-                  "to +0x%x\n",
-                  STM32Lx_NVM_OPT_PHYS,
-                  STM32Lx_NVM_OPT_PHYS + opt_size - sizeof(uint32_t));
-
-done:
-        stm32lx_nvm_lock(t, nvm);
-        return true;
-}
-
-
-static bool stm32lx_cmd_eeprom(target* t, int argc, char** argv)
-{
-        const uint32_t nvm = stm32lx_nvm_phys(t);
-
-        if (!stm32lx_nvm_prog_data_unlock(t, nvm)) {
-                tc_printf(t, "unable to unlock EEPROM\n");
-                return true;
-        }
-
-        size_t cb = strlen(argv[1]);
-
-        if (argc == 4) {
-                uint32_t addr = strtoul(argv[2], NULL, 0);
-                uint32_t val  = strtoul(argv[3], NULL, 0);
-
-                if (   addr <  STM32Lx_NVM_EEPROM_PHYS
-                    || addr >= STM32Lx_NVM_EEPROM_PHYS
-                       	        + stm32lx_nvm_eeprom_size(t))
-                        goto usage;
-
-                if (!strncasecmp(argv[1], "byte", cb)) {
-                        tc_printf(t, "write byte 0x%08x <- 0x%08x\n", addr, val);
-                        if (!stm32lx_eeprom_write(t, addr, 1, val))
-                                tc_printf(t, "eeprom write failed\n");
-                } else if (!strncasecmp(argv[1], "halfword", cb)) {
-                        val &= 0xffff;
-                        tc_printf(t, "write halfword 0x%08x <- 0x%04x\n",
-                                 addr, val);
-                        if (addr & 1)
-                                goto usage;
-                        if (!stm32lx_eeprom_write(t, addr, 2, val))
-                                tc_printf(t, "eeprom write failed\n");
-                } else if (!strncasecmp(argv[1], "word", cb)) {
-                        tc_printf(t, "write word 0x%08x <- 0x%08x\n", addr, val);
-                        if (addr & 3)
-                                goto usage;
-                        if (!stm32lx_eeprom_write(t, addr, 4, val))
-                                tc_printf(t, "eeprom write failed\n");
-                }
-                else
-                        goto usage;
-        }
-        else
-                goto usage;
-
-        goto done;
-
-usage:
-        tc_printf(t, "usage: monitor eeprom [ARGS]\n");
-        tc_printf(t, "  byte     <addr> <value8>  - Write a byte\n");
-        tc_printf(t, "  halfword <addr> <value16> - Write a half-word\n");
-        tc_printf(t, "  word     <addr> <value32> - Write a word\n");
-        tc_printf(t, "The value of <addr> must in the interval [0x%08x, 0x%x)\n",
-                  STM32Lx_NVM_EEPROM_PHYS,
-                  STM32Lx_NVM_EEPROM_PHYS + stm32lx_nvm_eeprom_size(t));
-
-done:
-        stm32lx_nvm_lock(t, nvm);
-        return true;
-}
diff --git a/src/target/stm32l4.c b/src/target/stm32l4.c
deleted file mode 100644
index c5432b4..0000000
--- a/src/target/stm32l4.c
+++ /dev/null
@@ -1,377 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2015, 2017  Uwe Bonnes
- * Written by Uwe Bonnes <bon@elektron.ikp.physik.tu-darmstadt.de>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/* This file implements STM32L4 target specific functions for detecting
- * the device, providing the XML memory map and Flash memory programming.
- *
- * On L4, flash and options are written in DWORDs (8-Byte) only.
- *
- * References:
- * RM0351 STM32L4x5 and STM32L4x6 advanced ARM®-based 32-bit MCUs Rev. 5
- * RM0392 STM32L4x1 advanced ARM®-based 32-bit MCUs Rev. 2
- * RM0393 STM32L4x2 advanced ARM®-based 32-bit MCUs Rev. 2
- * RM0394 STM32L431xx STM32L433xx STM32L443xx advanced ARM®-based 32-bit MCUs
- *        Rev.3
- * RM0395 STM32L4x5 advanced ARM®-based 32-bit MCUs Rev.1
- *
- *
- */
-
-#include "general.h"
-#include "target.h"
-#include "target_internal.h"
-#include "cortexm.h"
-
-static bool stm32l4_cmd_erase_mass(target *t);
-static bool stm32l4_cmd_erase_bank1(target *t);
-static bool stm32l4_cmd_erase_bank2(target *t);
-static bool stm32l4_cmd_option(target *t, int argc, char *argv[]);
-
-const struct command_s stm32l4_cmd_list[] = {
-	{"erase_mass", (cmd_handler)stm32l4_cmd_erase_mass, "Erase entire flash memory"},
-	{"erase_bank1", (cmd_handler)stm32l4_cmd_erase_bank1, "Erase entire bank1 flash memory"},
-	{"erase_bank2", (cmd_handler)stm32l4_cmd_erase_bank2, "Erase entire bank2 flash memory"},
-	{"option", (cmd_handler)stm32l4_cmd_option, "Manipulate option bytes"},
-	{NULL, NULL, NULL}
-};
-
-
-static int stm32l4_flash_erase(struct target_flash *f, target_addr addr, size_t len);
-static int stm32l4_flash_write(struct target_flash *f,
-                               target_addr dest, const void *src, size_t len);
-
-static const char stm32l4_driver_str[] = "STM32L4xx";
-
-#define PAGE_SIZE   0x800
-/* Flash Program ad Erase Controller Register Map */
-#define FPEC_BASE			0x40022000
-#define FLASH_ACR			(FPEC_BASE+0x00)
-#define FLASH_KEYR			(FPEC_BASE+0x08)
-#define FLASH_OPTKEYR		(FPEC_BASE+0x0c)
-#define FLASH_SR			(FPEC_BASE+0x10)
-#define FLASH_CR			(FPEC_BASE+0x14)
-#define FLASH_OPTR			(FPEC_BASE+0x20)
-//#define FLASH_OPTCR		(FPEC_BASE+0x14)
-
-#define FLASH_CR_PG			(1 << 0)
-#define FLASH_CR_PER		(1 << 1)
-#define FLASH_CR_MER1		(1 << 2)
-#define FLASH_CR_PAGE_SHIFT	3
-#define FLASH_CR_BKER		(1 << 11)
-#define FLASH_CR_MER2		(1 << 15)
-#define FLASH_CR_STRT		(1 << 16)
-#define FLASH_CR_OPTSTRT	(1 << 17)
-#define FLASH_CR_FSTPG	 	(1 << 18)
-#define FLASH_CR_EOPIE		(1 << 24)
-#define FLASH_CR_ERRIE		(1 << 25)
-#define FLASH_CR_OBL_LAUNCH	(1 << 27)
-#define FLASH_CR_OPTLOCK	(1 << 30)
-#define FLASH_CR_LOCK		(1 << 31)
-
-#define FLASH_SR_EOP		(1 << 0)
-#define FLASH_SR_OPERR		(1 << 1)
-#define FLASH_SR_PROGERR	(1 << 3)
-#define FLASH_SR_WRPERR		(1 << 4)
-#define FLASH_SR_PGAERR		(1 << 5)
-#define FLASH_SR_SIZERR		(1 << 6)
-#define FLASH_SR_PGSERR		(1 << 7)
-#define FLASH_SR_MSERR		(1 << 8)
-#define FLASH_SR_FASTERR	(1 << 9)
-#define FLASH_SR_RDERR		(1 << 14)
-#define FLASH_SR_OPTVERR	(1 << 15)
-#define FLASH_SR_ERROR_MASK	0xC3FA
-#define FLASH_SR_BSY		(1 << 16)
-
-#define KEY1 0x45670123
-#define KEY2 0xCDEF89AB
-
-#define OPTKEY1 0x08192A3B
-#define OPTKEY2 0x4C5D6E7F
-
-#define SR_ERROR_MASK	0xF2
-
-#define OR_DUALBANK		(1 << 21)
-
-#define DBGMCU_IDCODE	0xE0042000
-#define FLASH_SIZE_REG  0x1FFF75E0
-
-/* This routine is uses double word access.*/
-static const uint16_t stm32l4_flash_write_stub[] = {
-#include "flashstub/stm32l4.stub"
-};
-
-#define SRAM_BASE 0x20000000
-#define STUB_BUFFER_BASE ALIGN(SRAM_BASE + sizeof(stm32l4_flash_write_stub), 8)
-
-struct stm32l4_flash {
-	struct target_flash f;
-	uint32_t bank1_start;
-};
-
-static void stm32l4_add_flash(target *t,
-                              uint32_t addr, size_t length, size_t blocksize,
-                              uint32_t bank1_start)
-{
-	struct stm32l4_flash *sf = calloc(1, sizeof(*sf));
-	struct target_flash *f = &sf->f;
-	f->start = addr;
-	f->length = length;
-	f->blocksize = blocksize;
-	f->erase = stm32l4_flash_erase;
-	f->write = target_flash_write_buffered;
-	f->done = target_flash_done_buffered;
-	f->write_buf = stm32l4_flash_write;
-	f->buf_size = 2048;
-	f->erased = 0xff;
-	sf->bank1_start = bank1_start;
-	target_add_flash(t, f);
-}
-
-bool stm32l4_probe(target *t)
-{
-	uint32_t idcode;
-	uint32_t size;
-	uint32_t options;
-	uint32_t bank1_start = 0x08040000;
-
-	idcode = target_mem_read32(t, DBGMCU_IDCODE) & 0xFFF;
-	switch(idcode) {
-	case 0x461: /* L496/RM0351 */
-	case 0x415: /* L471/RM0392, L475/RM0395, L476/RM0351 */
-		t->driver = stm32l4_driver_str;
-		if (idcode == 0x415) {
-			target_add_ram(t, 0x10000000, 0x08000);
-			target_add_ram(t, 0x20000000, 0x18000);
-		} else {
-			target_add_ram(t, 0x10000000, 0x10000);
-			target_add_ram(t, 0x20000000, 0x40000);
-		}
-		size    = (target_mem_read32(t, FLASH_SIZE_REG) & 0xffff);
-		options =  target_mem_read32(t, FLASH_OPTR);
-		if ((size < 0x400) && (options & OR_DUALBANK))
-			bank1_start =  0x08000000 + (size << 9);
-		stm32l4_add_flash(t, 0x08000000, size << 10, PAGE_SIZE, bank1_start);
-		target_add_commands(t, stm32l4_cmd_list, "STM32L4 Dual bank");
-		return true;
-	case 0x462: /* L45x L46x / RM0394  */
-	case 0x435: /* L43x L44x / RM0394  */
-		t->driver = stm32l4_driver_str;
-		if (idcode == 0x452) {
-			target_add_ram(t, 0x10000000, 0x08000);
-			target_add_ram(t, 0x20000000, 0x20000);
-		} else {
-			target_add_ram(t, 0x10000000, 0x04000);
-			target_add_ram(t, 0x20000000, 0x0c000);
-		}
-		size    = (target_mem_read32(t, FLASH_SIZE_REG) & 0xffff);
-		options =  target_mem_read32(t, FLASH_OPTR);
-		stm32l4_add_flash(t, 0x08000000, size << 10, PAGE_SIZE, bank1_start);
-		target_add_commands(t, stm32l4_cmd_list, "STM32L4");
-		return true;
-	}
-	return false;
-}
-
-static void stm32l4_flash_unlock(target *t)
-{
-	if (target_mem_read32(t, FLASH_CR) & FLASH_CR_LOCK) {
-		/* Enable FPEC controller access */
-		target_mem_write32(t, FLASH_KEYR, KEY1);
-		target_mem_write32(t, FLASH_KEYR, KEY2);
-	}
-}
-
-static int stm32l4_flash_erase(struct target_flash *f, target_addr addr, size_t len)
-{
-	target *t = f->t;
-	uint16_t sr;
-	uint32_t bank1_start = ((struct stm32l4_flash *)f)->bank1_start;
-	uint32_t page;
-
-	stm32l4_flash_unlock(t);
-
-	page = (addr - 0x08000000) / PAGE_SIZE;
-	while(len) {
-		uint32_t cr;
-
-		cr = FLASH_CR_PER | (page << FLASH_CR_PAGE_SHIFT );
-		if (addr >= bank1_start)
-			cr |= FLASH_CR_BKER;
-		/* Flash page erase instruction */
-		target_mem_write32(t, FLASH_CR, cr);
-		/* write address to FMA */
-		cr |= FLASH_CR_STRT;
-		target_mem_write32(t, FLASH_CR, cr);
-
-		/* Read FLASH_SR to poll for BSY bit */
-		while(target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
-			if(target_check_error(t))
-				return -1;
-
-		len  -= PAGE_SIZE;
-		addr += PAGE_SIZE;
-		page++;
-	}
-
-	/* Check for error */
-	sr = target_mem_read32(t, FLASH_SR);
-	if(sr & FLASH_SR_ERROR_MASK)
-		return -1;
-
-	return 0;
-}
-
-static int stm32l4_flash_write(struct target_flash *f,
-                               target_addr dest, const void *src, size_t len)
-{
-	/* Write buffer to target ram call stub */
-	target_mem_write(f->t, SRAM_BASE, stm32l4_flash_write_stub,
-	                 sizeof(stm32l4_flash_write_stub));
-	target_mem_write(f->t, STUB_BUFFER_BASE, src, len);
-	return cortexm_run_stub(f->t, SRAM_BASE, dest,
-	                        STUB_BUFFER_BASE, len, 0);
-}
-
-static bool stm32l4_cmd_erase(target *t, uint32_t action)
-{
-	const char spinner[] = "|/-\\";
-	int spinindex = 0;
-
-	tc_printf(t, "Erasing flash... This may take a few seconds.  ");
-	stm32l4_flash_unlock(t);
-
-	/* Flash erase action start instruction */
-	target_mem_write32(t, FLASH_CR, action);
-	target_mem_write32(t, FLASH_CR, action | FLASH_CR_STRT);
-
-	/* Read FLASH_SR to poll for BSY bit */
-	while (target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY) {
-		tc_printf(t, "\b%c", spinner[spinindex++ % 4]);
-		if(target_check_error(t)) {
-			tc_printf(t, "\n");
-			return false;
-		}
-	}
-	tc_printf(t, "\n");
-
-	/* Check for error */
-	uint16_t sr = target_mem_read32(t, FLASH_SR);
-	if (sr & FLASH_SR_ERROR_MASK)
-		return false;
-	return true;
-}
-
-static bool stm32l4_cmd_erase_mass(target *t)
-{
-	return stm32l4_cmd_erase(t, FLASH_CR_MER1 | FLASH_CR_MER2);
-}
-
-static bool stm32l4_cmd_erase_bank1(target *t)
-{
-	return stm32l4_cmd_erase(t, FLASH_CR_MER1);
-}
-
-static bool stm32l4_cmd_erase_bank2(target *t)
-{
-	return stm32l4_cmd_erase(t, FLASH_CR_MER2);
-}
-
-static const uint8_t i2offset[9] = {
-	0x20, 0x24, 0x28, 0x2c, 0x30, 0x44, 0x48, 0x4c, 0x50
-};
-
-static bool stm32l4_option_write(target *t, const uint32_t *values, int len)
-{
-	stm32l4_flash_unlock(t);
-	target_mem_write32(t, FLASH_OPTKEYR, OPTKEY1);
-	target_mem_write32(t, FLASH_OPTKEYR, OPTKEY2);
-	while (target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
-		if(target_check_error(t))
-			return true;
-	for (int i = 0; i < len; i++)
-		target_mem_write32(t, FPEC_BASE + i2offset[i], values[i]);
-	target_mem_write32(t, FLASH_CR, FLASH_CR_OPTSTRT);
-	while (target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
-		if(target_check_error(t))
-			return true;
-	target_mem_write32(t, FLASH_CR, FLASH_CR_LOCK);
-	target_mem_write32(t, FLASH_CR, FLASH_CR_OBL_LAUNCH);
-	while (target_mem_read32(t, FLASH_CR) & FLASH_CR_OBL_LAUNCH)
-		if(target_check_error(t))
-			return true;
-	return false;
-}
-
-/* Chip       L43X/mask  L43x/def   L47x/mask  L47x/def
- *                                  L49x/mask  L49x/def
- * Option
- * 0X1FFF7800 0x0f8f77ff 0xFFEFF8AA 0x0FDF77FF 0xFFEFF8AA
- * 0X1FFF7808 0x0000FFFF 0xFFFFFFFF 0x0000FFFF 0xFFFFFFFF
- * 0X1FFF7810 0x8000FFFF 0          0x8000FFFF 0
- * 0X1FFF7818 0x00FF00FF 0x000000ff 0x00FF00FF 0x000000ff
- * 0X1FFF7820 0x00FF00FF 0x000000ff 0x00FF00FF 0x000000ff
- * 0X1FFFF808 0          0          0x8000FFFF 0xffffffff
- * 0X1FFFF810 0          0          0x8000FFFF 0
- * 0X1FFFF818 0          0          0x00FF00FF 0
- * 0X1FFFF820 0          0          0x00FF00FF 0x000000ff
- */
-
-static bool stm32l4_cmd_option(target *t, int argc, char *argv[])
-{
-	uint32_t val;
-	uint32_t values[9] = { 0xFFEFF8AA, 0xFFFFFFFF, 0, 0x000000ff,
-						   0x000000ff, 0xffffffff, 0, 0, 0x000000ff};
-	int len;
-	bool res = false;
-
-	if (t->idcode == 0x435) /* L43x */
-		len = 5;
-	else
-		len = 9;
-	if ((argc == 2) && !strcmp(argv[1], "erase")) {
-		res = stm32l4_option_write(t, values, len);
-	} else if ((argc >  2) && !strcmp(argv[1], "write")) {
-		int i;
-		for (i = 2; i < argc; i++)
-			values[i - 2] = strtoul(argv[i], NULL, 0);
-		for (i = i - 2; i < len; i++) {
-			uint32_t addr = FPEC_BASE + i2offset[i];
-			values[i] = target_mem_read32(t, addr);
-		}
-		if ((values[0] & 0xff) == 0xCC) {
-			values[0]++;
-			tc_printf(t, "Changing Level 2 request to Level 1!");
-		}
-		res = stm32l4_option_write(t, values, len);
-	} else {
-		tc_printf(t, "usage: monitor option erase\n");
-		tc_printf(t, "usage: monitor option write <value> ...\n");
-	}
-	if (res) {
-		tc_printf(t, "Writing options failed!\n");
-		return false;
-	}
-	for (int i = 0; i < len; i ++) {
-		uint32_t addr = FPEC_BASE + i2offset[i];
-		val = target_mem_read32(t, FPEC_BASE + i2offset[i]);
-		tc_printf(t, "0x%08X: 0x%08X\n", addr, val);
-	}
-	return true;
-}
diff --git a/src/target/swdptap_generic.c b/src/target/swdptap_generic.c
deleted file mode 100644
index 13ee02f..0000000
--- a/src/target/swdptap_generic.c
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * This file is part of the Black Magic Debug project.
- *
- * Copyright (C) 2016  Black Sphere Technologies Ltd.
- * Written by Gareth McMullin <gareth@blacksphere.co.nz>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-#include "general.h"
-#include "swdptap.h"
-
-uint32_t __attribute__((weak))
-swdptap_seq_in(int ticks)
-{
-	uint32_t index = 1;
-	uint32_t ret = 0;
-
-	while (ticks--) {
-		if (swdptap_bit_in())
-			ret |= index;
-		index <<= 1;
-	}
-
-	return ret;
-}
-
-bool __attribute__((weak))
-swdptap_seq_in_parity(uint32_t *ret, int ticks)
-{
-	uint32_t index = 1;
-	uint8_t parity = 0;
-	*ret = 0;
-
-	while (ticks--) {
-		if (swdptap_bit_in()) {
-			*ret |= index;
-			parity ^= 1;
-		}
-		index <<= 1;
-	}
-	if (swdptap_bit_in())
-		parity ^= 1;
-
-	return parity;
-}
-
-void __attribute__((weak))
-swdptap_seq_out(uint32_t MS, int ticks)
-{
-	while (ticks--) {
-		swdptap_bit_out(MS & 1);
-		MS >>= 1;
-	}
-}
-
-void __attribute__((weak))
-swdptap_seq_out_parity(uint32_t MS, int ticks)
-{
-	uint8_t parity = 0;
-
-	while (ticks--) {
-		swdptap_bit_out(MS & 1);
-		parity ^= MS;
-		MS >>= 1;
-	}
-	swdptap_bit_out(parity & 1);
-}
-
